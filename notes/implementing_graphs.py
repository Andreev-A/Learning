# Графы — это сети, состоящие из узлов, соединенных ребрами или дугами. В ориентированных графах связи между узлами
# имеют направление и называются дугами; в неориентированных графах соединения не имеют направления и называются ребрами
# . В основном мы обсуждаем ориентированные графы. Алгоритмы в графах включают поиск пути между двумя узлами, поиск
# кратчайшего пути между двумя узлами, определение циклов в графе (цикл — непустой путь от узла к самому себе), поиск
# пути, который достигает всех узлов (знаменитый «задача коммивояжера») и так далее. Иногда узлы или дуги графа имеют
# веса или связанные с ними затраты, и нас интересует поиск самого дешевого пути.
# Существует значительная литература по графовым алгоритмам, которые являются важной частью дискретной математики. Графы
# также имеют большое практическое применение в компьютерных алгоритмах. Очевидные примеры можно найти в управлении
# сетями, но их много и во многих других областях. Например, отношения вызывающий-вызываемый в компьютерной программе
# можно рассматривать как граф (где циклы указывают на рекурсию, а недостижимые узлы представляют мертвый код).
# Немногие языки программирования обеспечивают прямую поддержку графов как типа данных, и Python не является исключением
# . Однако графы легко строятся из списков и словарей. Например, вот простой график (я не могу использовать рисунки в
# этих колонках, поэтому я записываю дуги графика):
# A -> B
# A -> C
# B -> C
# B -> D
# C -> D
# D -> C
# E -> F
# F -> C
# Этот граф имеет шесть узлов (AF) и восемь дуг. Его можно представить следующей структурой данных Python:
# graph = {'A': ['B', 'C'],
#          'B': ['C', 'D'],
#          'C': ['D'],
#          'D': ['C'],
#          'E': ['F'],
#          'F': ['C']}
# Это словарь, ключами которого являются узлы графа. Для каждого ключа соответствующим значением является список,
# содержащий узлы, соединенные прямой дугой с этим узлом. Это настолько просто, насколько это возможно (еще проще, узлы
# могут быть представлены числами вместо имен, но имена более удобны и могут легко содержать больше информации, например
# , названия городов).
# Давайте напишем простую функцию для определения пути между двумя узлами. Он принимает граф и начальный и конечный узлы
# в качестве аргументов. Он вернет список узлов (включая начальный и конечный узлы), составляющих путь. Если путь не
# найден, возвращается None. Один и тот же узел не будет встречаться на возвращаемом пути более одного раза (т. е. он не
# будет содержать циклов). Алгоритм использует важную технику, называемую поиском с возвратом : он пробует каждую
# возможность по очереди, пока не найдет решение.
# def find_path(graph, start, end, path=[]):
#     path = path + [start]
#     if start == end:
#         return path
#     if not graph.has_key(start):
#         return None
#     for node in graph[start]:
#         if node not in path:
#             newpath = find_path(graph, node, end, path)
#             if newpath: return newpath
#     return None
# Пример запуска (с использованием графика выше):
# >>> find_path(graph, 'A', 'D')
# ['A', 'B', 'C', 'D']
# >>>
# Второй оператор if необходим только в том случае, если есть узлы, которые указаны как конечные точки дуг, но сами не
# имеют исходящих дуг и вообще не указаны на графе. Такие узлы также могут содержаться в графе с пустым списком
# исходящих дуг, но иногда удобнее этого не требовать.
# Обратите внимание, что хотя пользователь вызывает find_path()с тремя аргументами, он вызывает себя с четвертым
# аргументом: путь, который уже был пройден. Значением по умолчанию для этого аргумента является пустой список, '[]',
# означающий, что ни один узел еще не был пройден. Этот аргумент используется, чтобы избежать циклов (первый if внутри
# цикла for). Аргумент «путь» не изменяется: присваивание «путь = путь + [начало]» создает новый список. Если бы вместо
# этого мы написали «path.append(start)», мы бы изменили переменную «path» в вызывающей программе, что привело бы к
# катастрофическим результатам. (Используя кортежи, мы могли быть уверены, что этого не произойдет, за счет
# необходимости писать «путь = путь + (начало)», поскольку «(начало)» не является одноэлементным кортежем — это просто
# скобки выражение.)
# Эту функцию легко изменить, чтобы она возвращала список всех путей (без циклов) вместо первого найденного пути:
# def find_all_paths(graph, start, end, path=[]):
#     path = path + [start]
#     if start == end:
#         return [path]
#     if not graph.has_key(start):
#         return []
#     paths = []
#     for node in graph[start]:
#         if node not in path:
#             newpaths = find_all_paths(graph, node, end, path)
#             for newpath in newpaths:
#                 paths.append(newpath)
#     return paths
# Пример запуска:
# >>> find_all_paths(graph, 'A', 'D')
# [['A', 'B', 'C', 'D'], ['A', 'B', 'D'], ['A', 'C', 'D']]
# >>>
# Другой вариант находит кратчайший путь:
# def find_shortest_path(graph, start, end, path=[]):
#     path = path + [start]
#     if start == end:
#         return path
#     if not graph.has_key(start):
#         return None
#     shortest = None
#     for node in graph[start]:
#         if node not in path:
#             newpath = find_shortest_path(graph, node, end, path)
#             if newpath:
#                 if not shortest or len(newpath) < len(shortest):
#                     shortest = newpath
#     return shortest
# Пример запуска:
# >>> find_shortest_path(graph, 'A', 'D')
# ['A', 'C', 'D']
# >>>

# ОБНОВЛЕНИЕ: Эрик Копчиньски указал, что эти функции не оптимальны. Напротив, «эта программа выполняется за
# экспоненциальное время, в то время как find_shortest_path можно выполнить за линейное время, используя BFS [поиск в
# ширину]. Кроме того, линейный BFS проще:»
# # Code by Eryk Kopczyński
#     def find_shortest_path(graph, start, end):
#         dist = {start: [start]}
#         q = deque(start)
#         while len(q):
#             at = q.popleft()
#             for next in graph[at]:
#                 if next not in dist:
#                     dist[next] = [dist[at], next]
#                     q.append(next)
#         return dist.get(end)
# Обратите внимание, что это возвращает путь в странном формате, например, [[['A'], 'B'], 'D']. В частности,
# len(find_shortest_path(graph, 'A', 'D'))даст неправильный ответ (2, потому что внешний список имеет длину 2). Это
# связано с тем, что добавление выполняется как [dist[at], next]вместо dist[at]+[next]. Второй метод будет использовать
# квадратичное время и память, но все же подойдет для относительно небольших графов; в противном случае список легко
# привести к нужному формату.
# Другой вариант — добавить больше абстракции данных: создать класс для представления графов, методы которого реализуют
# различные алгоритмы. Хотя это апеллирует к стремлению к структурному программированию, это не делает код более
# эффективным (наоборот). Это упрощает добавление различных меток к узлам или дугам и добавление алгоритмов, учитывающих
# эти метки (например, для поиска кратчайшего маршрута между двумя городами на карте).
