# Строковые методы не будут производить дополнительных действий и не будут менять начальные строки
# Метод center()
# Этот метод нужно применять в тех случаях, если нужно выравнять строку по центру. Выравнивание будет выполняться с
# пробела. Сам метод составляет в себя несколько параметров: это length (есть обязательным параметром и показывает
# длину строки) и fillchar (символ выравнивания). Если вы указали новое число для ширины новой строки, чем той, которая
# была в начальной строке, то вы получите такой же код какой был в начале.
# value = "bad"
# some_value = value.center(11, "-")
# print(some_value)  # ----bad----

# Метод .find()   (rfind() — возвращает последнее совпадение)
# Этот метод просто необходим, если вам нужно найти индексы совпадений подстроки в строке. Если данные вы не нашли, то
# метод возвратит -1. Данная функция может принимать такие параметры: substring (символ/подстрока) – это необходимая для
# вас подстрока; start – первый индекс со значением 0; end – индекс, который заканчивает отыскивание нужной подстроки.
# С помощью метода find() можно находить необходимые индексы первого вхождения подстроки в последовательности (строке).
# my_question = "Когда пары?"
# print("Индекс буквы ‘р’:", my_question.find("р"))  # Индекс буквы 'р': 8
# Метод find() помогает найти индекс первого совпадения подстроки в данной строке. Возвращает -1, если подстрока не
# была найдена.
# В метод передаются три параметра: подстрока, которую нужно найти, start со значением по умолчанию равным 0 и end со
# значением по умолчанию равным длине строки.
# Можно искать подстроку в данной строке, задав начальное положение, с которого следует начинать поиск.
# С помощью параметров start и end можно ограничить зону поиска, чтобы не выполнять его по всей строке.
# Функция rfind() повторяет возможности find(), но возвращает максимальный индекс (то есть, место последнего совпадения)
# . В обоих случаях возвращается -1, если подстрока не была найдена.
# index() — еще одна функция, которая возвращает положение подстроки. Отличие лишь в том, что index() бросает исключение
# , если подстрока не была найдена, а find() возвращает -1.
# find() можно использовать в том числе и для поиска общего числа совпадений подстроки.

# Метод .isalnum()
# Метод isalnum() нужен для того, чтобы выяснить есть ли в строке буквы или цифры. isalnum() вернет True в тех случаях,
# когда строка заполнена либо символами, либо числами.
# my_var = 'kfc429'
# print(my_var.isalnum())  # True
# myVar = 'kfc@429'
# print(myVar.isalnum())  # False
# var = '333-kfc'
# print(var.isalnum())  # False

# Метод .replace()
# Метод replace() нужен для того, чтобы вернуть копии строки или заменить небольшую ее часть.
# my_variant='Lilia, Vita, Sasha, Masha'  # Нужно заменить все подстроки “Vita” в строке
# print(my_variant.replace('Vita', 'Vitochka'))  # Lilia, Vitochka, Sasha, Masha

# Метод .casefold()
# Этот метод необходим для того, чтобы преобразовать строку в сложенный регистр. Сложенный регистр это почти тоже самое
# что нижний регистр, но более агрессивно.
# text = 'РозЫ, ПИоны, МаКИ'
# print(text.casefold())  # розы, пионы, маки

# Метод .endswith()
# Метод нужен для того, чтобы вернуть True, если строка имеет искомый суффикс. Данный метод может принимать такие три
# параметра в позициях: суффиксы-строки или кортежи с суффиксами, чтобы проверять данные в строках; start — это
# необязательный параметр, который помогает проверять суффиксы в строках; end — тоже необязательный параметр, который
# нужен для проверки суффиксов в строках.
# Итак, сам метод нужен чтобы возвратить True или False, если строки заканчиваются суффиксом или не заканчиваются
# никакими суффиксами. Также в языке Python есть возможность передавать суффиксы кортежей. Если в вашей строке есть
# окончания на элемент кортежа, то данный метод вернет True. Если этого нет, то вернется False.
# my_text = "Разве ты купил книгу?"
# new = my_text.endswith("книгу?")
# print(new)  # True

# Метод .index()
# Данный метод возвращает индексы подстрок в середине строк. Если во время проверки не найдётся нужная подстрока, то
# пишется, что нашлась ошибка (ValueError). Метод может принимать данные параметров: sub (главная подстрока, которую
# нужно искать в строке), start (начало поиска подстроки), end (необязательный параметр, конец поиска подстроки).
# По данному методу можно обнаружить начало указанной подстроки в исходной. Необязательные позиции start и end нужны для
# того, чтобы принимать любые значения и поддерживать механизмы срезов.
# Методом можно воспользоваться в случаях необходимости найти начальные индексы подстроки.
# variant = 'В аудиторию вошел преподаватель'
# print(variant.index('преподаватель'))  # 18
# print(variant.index('пришел'))  # ValueError: substring not found

# Метод .isdecimal()
# С помощью этого метода можно вернуть True, в тех случаях, когда символы в строках являются десятичными числами. Если
# десятичных чисел в строке не нашлось, то возвращается False. Данный метод определяет есть ли цифры в строке. В таком
# случае возвращается True. Если в строке есть пробелы, буквы, точка или вообще пустая строка, возвращается False.
# my_text = "12345"
# print(my_text.isdecimal())  # True (в строке только цифры)
# my_text_2 = "1_2345"
# print(my_text_2.isdecimal())  # False (в строке есть нижнее подчеркивание)

# Метод .isdigit()
# Данный метод похож на метод isdecimal(). True появляется в результате, если цифры в строке есть и False, если в строке
# появляется пробел или другой символ, буква, нижнее подчеркивание или смайлик.
# С помощью метода isdigit() вы можете понять, что необходимая строка содержит цифры.
# Но есть одно но: данный метод работать в тех случаях, если ваши числа являются положительными, на отрицательные данный
# метод не работает.
# text1 = '_'
# print(text1.isdigit())  # False
# text2 = '1235'
# print(text2.isdigit())  # True
# text3 = '12 563'
# print(text3.isdigit())  # False

# Метод .join()
# Он помогает собирать строки из списков с определёнными разделителями.
# Данный метод отвечает за превращение списка в строку. Он может использоваться тогда, когда нужно принять итерируемые
# объекты как аргумент, а список очень часто выступает аргументом. Нужно знать, что этот список должен состоять из строк
# Очень часто начинающие python-программисты задаются вопросом: почему метод join() относится к методам строки, а не
# методам списка. Отвечаю: функцию join() вы можете использовать в разных целях и с разными итерируемыми объектами, но в
# результате вы получаете только строку.
# Метод join() нельзя использовать в тех случаях, где объединять элементы разного типа. Чтобы не сделать ошибку,
# превращайте все объекты списка в строки. Это обязательное требование. С помощью метода join() вы можете разбивать
# строки и обратно преобразовать строку в список.
# flower = ["r", "o", "s", "e"]
# flower_str = ",".join(flower)
# print("Цветок:", flower_str)  # Цветок: r,o,s,e

# Метод split()
# Метод split() есть противоположностью методу join. С его помощью можно разбить строки по нужному вам разделителю и
# получить список строк.
# Метод split() может принимать несколько параметров. Первый параметр — это разделитель, по которому будет разделяться
# строка. Если вы не указали разделитель, то любой символ (пробел или даже другая строка) уже автоматически считается
# новым разделителем. Другой параметр — это maxsplit. Он нужен для того, чтобы показать какое будет число разделений в
# строке. Если вы укажите maxsplit, то ваш список будет иметь maxsplit и еще один объект.
# food = 'Water, Bread, Bun, Grape'
# print(food.split(',', 2))  # ['Water', ' Bread', ' Bun, Grape']
# print(food.split(',', 3))  # ['Water', ' Bread', ' Bun', ' Grape']
# Метод isnumeric()
# Мы прекрасно помним, что Python имеет динамическую типизацию (когда в объектах хранится информация о значении и
# информации о типах объектов; сама типизация имеет ряд преимуществ). Очень часто с помощью различных строковых методов
# не нужно менять тип данных. В Python есть встроенный метод isnumeric(). Он нужен чтобы обрабатывать строки.
# Метод isnumeric() возвращает True в тех случаях, если символы оказываются числовыми символами. Если этого не
# происходит, то выводится False.
# С помощью метода isnumeric() можно определить есть ли в аргументе дроби, целые числа, индекса (верхние и нижние),
# арабские и римские цифры.
# x = "Демяновка_деревня"
# print(x.isnumeric())  # False (в строке буквы)
# x = "5896"
# print(x.isnumeric())  # True (в строке цифры)

# Метод isspace()
# С помощью данного метода вы сможете проверить есть ли в строке пробелы. Этот метод не имеет никаких параметров. Если
# строка пуста или имеет один пробел, то вы в результате увидите False. Если наоборот, то True.
# var = ' b '
# print(var.isspace())  # False

# Метод isupper()
# Данная строковая функция (метод) нужна для того, чтобы вы могли проверить все ли введенные буквы находятся в верхнем
# регистре. Метод isupper() позволяет вам вернуть True в тех случаях, если ваши буквы будут в строке прописными. Если
# нет — то будет выводится False.
# Нужно помнить о том, что данный метод не будет принимать других аргументов, а будет работать только с указанными вами
# аргументами.
# text = 'Косая строчка'
# print(text.isupper())  # False

# Метод partition()
# Данный метод нужен для того, чтобы строка разбилась на начало, середину и конец. В результате будет кортеж. В основном
# строка будет разбиваться слева направо.
# Метод имеет один параметр sep. Он может содержать один или несколько букв или символов.
# string = 'The lion is the king of beasts'
# print(string.partition('lion'))  # ('The ', 'lion', ' is the king of beasts')
# print(string.partition('king'))  # ('The lion is the ', 'king', ' of beasts')
# string = "The tiger is not king of beasts"
# print(string.partition('is not'))  # ('The tiger ', 'is not', ' king of beasts')


# Текстовую информацию в языке Python мы храним в объектах строкового типа.
# Проверка вхождения одной строки в другую:
# print('abc' in 'abcba')  # True
# print('abce' in 'abcba')  # False
# Даже для стандартных функций очень полезно читать документацию по ним через метод __doc__. Так можно найти интересные
# возможности у стандартных функций
# .
# Поиск позиции вхождения подстроки в строке, метод find():
# print('cabcd'.find('abc', 1))  # индекс первого вхождения или -1
# print('cabcd'[1:].find('abc'))
# print(str.find.__doc__)

# Аналогичное действие у метода index(). Но если он не находит подстроку, то бросает исключение ValueError
# print('cabcd'.index('abc'))  # индекс первого вхождения или ValueError
# print('cabcd'.index('aec'))

# Метод startswith() позволяет проверить начинается ли строка с указанной подстроки:
# s = 'as df ghjk'
# print(s.startswith('as df'))
# print(s.startswith.__doc__)
# Если мы посмотрим описание метода startswith(), то увидим, что вместо одной строки можно проводить проверку сразу по
# кортежу строк. Функция будет возвращать True в случае, если строка начинается на любое из переданных в кортеже
# значений.
# s = 'aas df ghjk'
# print(s.startswith(('as df', 'asdf', 'aas df')))

# Метод endswith() позволяет проверить заканчивается ли строка на указанную подстроку:
# s = 'image.png'
# print(s.endswith('.png'))
# Его удобно использовать, например, для проверки расширений у файлов.

# Метод count() позволяет узнать число непересекающихся вхождений одной строки в другой:
# s = 'abcaabc'
# print(s.count('abc'))  # 2
# print(s.count.__doc__)
# У части из функций есть правосторонние аналоги. Они делают все тоже самое, но начинают читать строку справа налево:
# s = 'abcaabc'
# print(s.find('abc'))  # 0
# print(s.rfind('abc'))  # 4
# help(str.count)
# В Python две строки с одинаковыми буквами, но в разных регистрах, будут считаться разными.
# Методы lower() и upper() переводят строку в нижний и верхний регистр соответственно:
# s = 'Abcaabc'
# print(s.lower())
# print(s.upper())
# print(s.count('abc'))  # 1
# print(s.lower().count('abc'))  # 2
# Замена в строке всех подстрок, переданных первым аргументом, на подстроку, переданную вторым аргументом:
# s = '1,2,3,4,5'
# print(s.replace(',', ' ,', 2))  # 1 ,2 ,3,4,5
# Метод split() разделяет строку по заданному разделителю и возвращает список:
# s = '1 2 3 4 5'
# print(s.split(' '))  # ['1', '2', '3', '4', '5']
# Параметр maxsplit позволяет задать количество разделений, которые нужно сделать.
# Например, так можно разделить строку только 2 раза:
# s = '1 2 3 4 5'
# print(s.split(' ', 2))  # ['1', '2', '3 4 5']
# Прочитав строку документации, мы увидим, что если мы не указываем разделитель или он равен None, то мы будем
# использовать в качестве разделителя любую последовательность пробельных символов (под пробельными символами
# подразумеваются в том числе символы табуляции, переносы строк и т.д.) и пустые строки будут удалены из ответа:
# s = '1      2' \
#     ' 3   4 5  '
# print(s.split())  # ['1', '2', '3', '4', '5']
# Методы strip(), lstrip(), rstrip() удаляют ведущие пробельные символы:
# s = '  1 2 3 4 5        '
# print(repr(s.lstrip()))  # '1 2 3 4 5        '
# print(repr(s.rstrip()))  # '  1 2 3 4 5'
# print(repr(s.strip()))  # '1 2 3 4 5'
# Также эти методы позволяют удалять любую другую строку, которая находится справа или слева основной строки:
# s = '_*___1 2 3 4 5__*_*___'
# print(repr(s.lstrip('*_ ')))  # '1 2 3 4 5__*_*___'
# print(repr(s.rstrip('*_')))  # '_*___1 2 3 4 5'
# print(repr(s.strip('*_')))  # '1 2 3 4 5'
# Метод join() вставляет строку, от которой его вызывали, между всеми элементами последовательности:
# s = map(str, [1, 2, 3, 4, 5])
# print(repr(' '.join(s)))  # '1 2 3 4 5'
# Важно помнить, что элементы последовательности всегда должны быть строками.
# Метод format() используется для форматирования строк (подстановки значений):
# template = '{} is the capital of {}'  # позиционные аргументы по порядку
# print(template.format('Moscow', 'Russia'))
# print(template.format('london', 'Great Britian'))
# Можно с помощью индексов указывать какой из параметров нужно вывести:
# template = '{1} is the capital of {0}'
# print(template.format('Moscow', 'Russia'))
# print(template.format('london', 'Great Britian'))
# Также мы можем использовать именованные параметры. При этом порядок перечисления параметров будет неважен:
# template = '{capital} is the capital of {country}'
# print(template.format(capital='Moscow', country='Russia'))
# print(template.format(country='Great Britian', capital='london'))
# Можно сделать еще круче. Благодаря форматированию в языке Python мы можем обращаться к атрибутам объектов, которые мы
# передали:
# import requests
# template = "Response from {0.url} with code {0.status_code}"
# res = requests.get("https://docs.python.org/3.5/")
# print(template.format(res))  # Response from https://docs.python.org/3.5/ with code 200
# res = requests.get("https://docs.python.org/3.5/random")
# print(template.format(res))  # Response from https://docs.python.org/3.5/random with code 404
# откуда и как format узнает значение полей {0.url} {0.status_code}?
# Возьмет их у requests.models.Response, на который ссылается res, ну или аналогично:
# class MyClass:
#     def __init__(self, id, name):
#         self.id = id
#         self.name = name
#
# template = 'что-то там {0.id}, что-то там {0.name}'
# mc = MyClass(42, 'mc')
# print(template.format(mc))  # что-то там 42, что-то там mc
# меня тоже немного сбило с толку обозначение в фигурных скобках.
# Если экземпляр класса имеет параметр url и status_code, зачем перед ними стоят "0", отделенные "."?
# Затем, что ф-ия format может принимать позиционные аргументы и обращаться к ним по индексу.
#
# class ArgForFormatFunction:
#     def __init__(self, argname):
#         self.argname = argname
# template = '''первый аргумент из позиционных аргументов,
# которые принимает функция format,
# индекс соответственно - 0, далее точка для доступа к полю аргумента - {0.argname},
# теперь второй аргумент:
# индекс - 1, дальнейшее - аналогично - {1.argname}'''
# arg0 = ArgForFormatFunction('first arg')
# arg1 = ArgForFormatFunction('second arg')
# print(template.format(arg0, arg1))
# первый аргумент из позиционных аргументов,
# которые принимает функция format,
# индекс соответственно - 0, далее точка для доступа к полю аргумента - first arg,
# теперь второй аргумент
# индекс - 1, дальнейшее - аналогично - second arg


# Аналогичным образом можно получать элементы списка или значения словаря.
# С помощью специального синтаксиса мы можем указать, что нужно вывести только 3 знака после запятой в числе:
# from random import random
# x = random()
# print(x)  # 0.5073550487196168
# print("{:.3}".format(x))  # 0.507


# f-строки в Python
# Начиная с версии 3.6 в Python появился новый тип строк — f-строки, которые буквально означают «formatted string».
# Эти строки улучшают читаемость кода, а также работают быстрее чем другие способы форматирования. F-строки задаются с
# помощью литерала «f» перед кавычками.
# >>> "обычная строка"
# >>> f"f-строка"
# f-строки - это пятый способ (sic!) форматирования строк в Python, который очень похож на использование метода format()
# Вспомним все 5 способов форматирования.

# 5 СПОСОБОВ ФОРМАТИРОВАНИЯ СТРОК
# 1. Конкатенация. Грубый способ форматирования, в котором мы просто склеиваем несколько строк с помощью операции
# сложения:
# >>> name = "Дмитрий"
# >>> age = 25
# >>> print("Меня зовут " + name + ". Мне " + str(age) + " лет.")
# >>> Меня зовут Дмитрий. Мне 25 лет.
# 2. %-форматирование. Самый популярный способ, который перешел в Python из языка С. Передавать значения в строку можно
# через списки и кортежи , а также и с помощью словаря. Во втором случае значения помещаются не по позиции, а в
# соответствии с именами.
# >>> name = "Дмитрий"
# >>> age = 25
# >>> print("Меня зовут %s. Мне %d лет." % (name, age))
# >>> Меня зовут Дмитрий. Мне 25 лет.
# >>> print("Меня зовут %(name)s. Мне %(age)d лет." % {"name": name, "age": age})
# >>> Меня зовут Дмитрий. Мне 25 лет.
# 3. Template-строки. Этот способ появился в Python 2.4, как замена %-форматированию (PEP 292), но популярным так и не
# стал. Поддерживает передачу значений по имени и использует $-синтаксис как в PHP.
# >>> from string import Template
# >>> name = "Дмитрий"
# >>> age = 25
# >>> s = Template('Меня зовут $name. Мне $age лет.')
# >>> print(s.substitute(name=name, age=age))
# >>> Меня зовут Дмитрий. Мне 25 лет.
# 4. Форматирование с помощью метода format(). Этот способ появился в Python 3 в качестве замены %-форматированию. Он
# также поддерживает передачу значений по позиции и по имени.
# >>> name = "Дмитрий"
# >>> age = 25
# >>> print("Меня зовут {}. Мне {} лет.".format(name, age)
# >>> Меня зовут Дмитрий. Мне 25 лет.
# >>> print("Меня зовут {name} Мне {age} лет.".format(age=age, name=name)
# >>> Меня зовут Дмитрий. Мне 25 лет.
# 5. f-строки. Форматирование, которое появилось в Python 3.6 (PEP 498). Этот способ похож на форматирование с помощью
# метода format(), но гибче, читабельней и быстрей.
# >>> name = "Дмитрий"
# >>> age = 25
# >>> print(f"Меня зовут {name} Мне {age} лет.")
# >>> Меня зовут Дмитрий. Мне 25 лет.

# ПОГРУЖЕНЕ В F-СТРОКИ
# f-строки делают очень простую вещь — они берут значения переменных, которые есть в текущей области видимости, и
# подставляют их в строку. В самой строке вам лишь нужно указать имя этой переменной в фигурных скобках.
# >>> name = "Дмитрий"
# >>> age = 25
# >>> print(f"Меня зовут {name} Мне {age} лет.")
# >>> Меня зовут Дмитрий. Мне 25 лет.
#
# f-строки также поддерживают расширенное форматирование чисел:
# >>> from math import pi
# >>> print(f"Значение числа pi: {pi:.2f}")
# >>> Значение числа pi: 3.14
#
# С помощью f-строк можно форматировать дату без вызова метода strftime():
# >>> from datetime import datetime as dt
# >>> now = dt.now()
# >>> print(f"Текущее время {now:%d.%m.%Y %H:%M}")
# >>> Текущее время 24.02.2017 15:51

# Они поддерживают базовые арифметические операции. Да, прямо в строках:
# >>> x = 10
# >>> y = 5
# >>> print(f"{x} x {y} / 2 = {x * y / 2}")
# >>> 10 x 5 / 2 = 25.0
#
# Позволяют обращаться к значениям списков по индексу:
# >>> planets = ["Меркурий", "Венера", "Земля", "Марс"]
# >>> print(f"Мы живим на планете {planets[2]}")
# >>> Мы живим не планете Земля
#
# А также к элементам словаря по ключу:
# >>> planet = {"name": "Земля", "radius": 6378000}
# >>> print(f"Планета {planet['name']}. Радиус {planet['radius']/1000} км.")
# >>> Планета Земля. Радиус 6378.0 км.
#
# Причем вы можете использовать как строковые, так и числовые ключи. Точно также как в обычном Python коде:
# >>> digits = {0: 'ноль', 'one': 'один'}
# >>> print(f"0 - {digits[0]}, 1 - {digits['one']}")
# >>> 0 - ноль, 1 - один

# Вы можете вызывать в f-строках методы объектов:
# >>> name = "Дмитрий"
# >>> print(f"Имя: {name.upper()}")
# >>> Имя: ДМИТИРИЙ
#
# А также вызывать функции:
# >>> print(f"13 / 3 = {round(13/3)}")
# >>> 13 / 3 = 4
#
# f-строки очень гибкий и мощный инструмент для создания самых разнообразных шаблонов.

# После двоеточия в f-строках можно указывать те же значения,
# что и при использовании format:
# oct1, oct2, oct3, oct4 = [10, 1, 1, 1]
# print(f'''
# IP address:
# {oct1:<8} {oct2:<8} {oct3:<8} {oct4:<8}
# {oct1:08b} {oct2:08b} {oct3:08b} {oct4:08b}''')
# IP address:
# 10       1        1        1
# 00001010 00000001 00000001 00000001

# ====================

# Ширина столбцов может быть указана через переменную:
# topology = [['sw1', 'Gi0/1', 'r1', 'Gi0/2'],
#             ['sw1', 'Gi0/2', 'r2', 'Gi0/1'],
#             ['sw1', 'Gi0/3', 'r3', 'Gi0/0'],
#             ['sw1', 'Gi0/5', 'sw4', 'Gi0/2']]
# width = 10
# for connection in topology:
#     l_device, l_port, r_device, r_port = connection
#     print(f'{l_device:{width}} '
#           f'{l_port:{width}} '
#           f'{r_device:{width}} '
#           f'{r_port:{width}}')
# sw1        Gi0/1      r1         Gi0/2
# sw1        Gi0/2      r2         Gi0/1
# sw1        Gi0/3      r3         Gi0/0
# sw1        Gi0/5      sw4        Gi0/2

# ====================

# Конвертация чисел в двоичный формат:
# ip = '10.1.1.1'
# oct1, oct2, oct3, oct4 = ip.split('.')
# print(f'{int(oct1):08b} {int(oct2):08b} {int(oct3):08b} {int(oct4):08b}')
# 00001010 00000001 00000001 00000001

# ====================

# Пример функции шаблона f-строки:
# def show_me_ip(i_p, mask):
#     return f'IP: {i_p}, mask: {mask}'
#
# print(show_me_ip('10.1.1.1', 24))
# # IP: 10.1.1.1, mask: 24
#
# template = '{}'
# print(template.format(42))  # 42
# template = "'{}'"
# print(template.format(42))  # '42'
# template = '"{}"'
# print(template.format(42))  # "42"
# template = '{{{}}}'
# print(template.format(42))  # {42}
#
# # а вообще начиная с python 3.6 f-string завезли
# print(f'{42}')  # 42
# print(f'{{42}}')  # {42}

# метод format
# f - строки
# так вот, так вот, это не взаимоисключающие вещи и не так что второе моднее или новее первого. Это два разных
# инструмента для разных задач.
# Метод format удобно использовать когда ты делаешь один шаблон вывода, а потом в коде у тебя меняются объекты,
# создаются новые, но всё выводится в одном формате.
# С f - строками так не получится. Они выполняются (выражения и функции внутри них) в момент вызова.  И фарш сложно
# провернуть назад. (ну только если удастся выполнить time.time(-1))

# В Python 3.9 для строк подвезли методы removeprefix и removesuffix

# вот аккуратный метод, который иллюстрирует гибкость понимания списка. Это вспомогательный метод, который проверяет,
# если строка содержит пробелы.
# import string
# def contains_whitespace(s):
#     return True in [c in s for c in string.whitespace]
# >>> contains_whitespace("BB")
# False
# >>> contains_whitespace("B B")
# True

# f-строки в Python
# Начиная с версии 3.6 в Python появился новый тип строк — f-строки, которые буквально означают «formatted string». Эти строки улучшают читаемость кода, а также работают быстрее чем другие способы форматирования. F-строки задаются с помощью литерала «f» перед кавычками.
#
# >>> "обычная строка"
# >>> f"f-строка"
# f-строки - это пятый способ (sic!) форматирования строк в Python, который очень похож на использование метода format().
#
# Вспомним все 5 способов форматирования.
#
# 5 СПОСОБОВ ФОРМАТИРОВАНИЯ СТРОК
# 1. Конкатенация. Грубый способ форматирования, в котором мы просто склеиваем несколько строк с помощью операции сложения:
#
# >>> name = "Дмитрий"
# >>> age = 25
# >>> print("Меня зовут " + name + ". Мне " + str(age) + " лет.")
# >>> Меня зовут Дмитрий. Мне 25 лет.
# 2. %-форматирование. Самый популярный способ, который перешел в Python из языка С. Передавать значения в строку можно через списки и кортежи , а также и с помощью словаря. Во втором случае значения помещаются не по позиции, а в соответствии с именами.
#
# >>> name = "Дмитрий"
# >>> age = 25
# >>> print("Меня зовут %s. Мне %d лет." % (name, age))
# >>> Меня зовут Дмитрий. Мне 25 лет.
# >>> print("Меня зовут %(name)s. Мне %(age)d лет." % {"name": name, "age": age})
# >>> Меня зовут Дмитрий. Мне 25 лет.
# 3. Template-строки. Этот способ появился в Python 2.4, как замена %-форматированию (PEP 292), но популярным так и не стал. Поддерживает передачу значений по имени и использует $-синтаксис как в PHP.
#
# >>> from string import Template
# >>> name = "Дмитрий"
# >>> age = 25
# >>> s = Template('Меня зовут $name. Мне $age лет.')
# >>> print(s.substitute(name=name, age=age))
# >>> Меня зовут Дмитрий. Мне 25 лет.
# 4. Форматирование с помощью метода format(). Этот способ появился в Python 3 в качестве замены %-форматированию. Он также поддерживает передачу значений по позиции и по имени.
#
# >>> name = "Дмитрий"
# >>> age = 25
# >>> print("Меня зовут {}. Мне {} лет.".format(name, age)
# >>> Меня зовут Дмитрий. Мне 25 лет.
# >>> print("Меня зовут {name} Мне {age} лет.".format(age=age, name=name)
# >>> Меня зовут Дмитрий. Мне 25 лет.
# 5. f-строки. Форматирование, которое появилось в Python 3.6 (PEP 498). Этот способ похож на форматирование с помощью метода format(), но гибче, читабельней и быстрей.
#
# >>> name = "Дмитрий"
# >>> age = 25
# >>> print(f"Меня зовут {name} Мне {age} лет.")
# >>> Меня зовут Дмитрий. Мне 25 лет.
# ПОГРУЖЕНЕ В F-СТРОКИ
# f-строки делают очень простую вещь — они берут значения переменных, которые есть в текущей области видимости, и подставляют их в строку. В самой строке вам лишь нужно указать имя этой переменной в фигурных скобках.
#
# >>> name = "Дмитрий"
# >>> age = 25
# >>> print(f"Меня зовут {name} Мне {age} лет.")
# >>> Меня зовут Дмитрий. Мне 25 лет.
# f-строки также поддерживают расширенное форматирование чисел:
#
# >>> from math import pi
# >>> print(f"Значение числа pi: {pi:.2f}")
# >>> Значение числа pi: 3.14
# С помощью f-строк можно форматировать дату без вызова метода strftime():
#
# >>> from datetime import datetime as dt
# >>> now = dt.now()
# >>> print(f"Текущее время {now:%d.%m.%Y %H:%M}")
# >>> Текущее время 24.02.2017 15:51
# Они поддерживают базовые арифметические операции. Да, прямо в строках:
#
# >>> x = 10
# >>> y = 5
# >>> print(f"{x} x {y} / 2 = {x * y / 2}")
# >>> 10 x 5 / 2 = 25.0
# Позволяют обращаться к значениям списков по индексу:
#
# >>> planets = ["Меркурий", "Венера", "Земля", "Марс"]
# >>> print(f"Мы живим не планете {planets[2]}")
# >>> Мы живим не планете Земля
# А также к элементам словаря по ключу:
#
# >>> planet = {"name": "Земля", "radius": 6378000}
# >>> print(f"Планета {planet['name']}. Радиус {planet['radius']/1000} км.")
# >>> Планета Земля. Радиус 6378.0 км.
# Причем вы можете использовать как строковые, так и числовые ключи. Точно также как в обычном Python коде:
#
# >>> digits = {0: 'ноль', 'one': 'один'}
# >>> print(f"0 - {digits[0]}, 1 - {digits['one']}")
# >>> 0 - ноль, 1 - один
# Вы можете вызывать в f-строках методы объектов:
#
# >>> name = "Дмитрий"
# >>> print(f"Имя: {name.upper()}")
# >>> Имя: ДМИТИРИЙ
# А также вызывать функции:
#
# >>> print(f"13 / 3 = {round(13/3)}")
# >>> 13 / 3 = 4
# f-строки очень гибкий и мощный инструмент для создания самых разнообразных шаблонов.
#
# Со всеми возможностя f-строк вы можете ознакомится в PEP498.
#
# ПРОИЗВОДИТЕЛЬНОСТЬ
# На простых примерах f-строки показывают самые лучшие результаты. На 25% быстрее %-форматирования и метода format().
# На сложных шаблонах f-строки ведут себя также как %-форматирование (разница в пользу %-форматирования не превышает
# величину погрешности). А вот относительно метода format() f-строки быстрее на 27%.


# Вашей программе на вход подаются три строки s, a, b, состоящие из строчных латинских букв.
# За одну операцию вы можете заменить все вхождения строки a в строку s на строку b.
# Например, s = "abab", a = "ab", b = "ba", тогда после выполнения одной операции строка s перейдет в строку "baba",
# после выполнения двух и операций – в строку "bbaa", и дальнейшие операции не будут изменять строку s.
# Необходимо узнать, после какого минимального количества операций в строке s не останется вхождений строки a. Если
# операций потребуется более 1000, выведите Impossible.
# str = input()
# a = input()
# b = input()
# for i in range(1001):
#     if a not in str:
#         break
#     str = str.replace(a, b)
# print(i if i < 1000 else "Impossible")

# Вашей программе на вход подаются две строки s и t, состоящие из строчных латинских букв.
# Выведите одно число – количество вхождений строки t в строку s.
# str = input()ababa
# name = input()
# count = 0
# while str:
#     if str.startswith(name):
#         count += 1
#     str = str[1:]
# print(count)

# str = input()
# name = input()
# count = 0
# for i in range(len(str)):
#     if str[i:].startswith(name):
#         count += 1
# print(count)

# print(summa(1 for i in range(len(str)) if str[i:].startswith(name)))
# print(summa(1 for i in range(len(str)) if str.startswith(name, i)))