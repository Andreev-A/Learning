# Все ошибки в языке Python делятся на 2 типа:
# 1. синтаксические - когда мы даем инструкцию интерпретатору, а интерпретатор не может ее разобрать, потому что в
# ней мы допустили синтаксическую ошибку
# 2. исключения - ошибки, возникающие в процессе исполнения самого кода
# Когда мы запускаем файл на исполнение, он проверяется целиком. И если в нем есть синтаксические ошибки, то он не
# начнет свое исполнение.
# В случае, если синтаксических ошибок нет, он будет выполняться строка за строкой.
# Сообщения об ошибках важно правильно уметь читать.
# У любой ошибки есть 3 обязательные вещи:
# ●	ошибки являются объектами и поэтому у любой ошибки есть тип (TypeError, NameError и т.д., по которым уже можно
# догадаться, какую ошибку мы совершили)
# ●	дополнительное сообщение, в котором более подробно расписано, что пошло не так
# ●	состояние стека вызовов на момент совершения ошибки

# Обработка исключений
# В теле конструкции try: указываем код, который мы хотели запустить проверить.
# Далее указываем ключевое слово except и тип того исключения, которое мы хотели бы обработать. Внутри except указываем
# инструкции, что делать, если исключение действительно возникло внутри тела try.
# Если внутри try блока происходит исключение, которое мы не ловим внутри блока except, то это исключение ведет себя
# также, как если бы этого try блока не было.
# Когда мы пишем несколько except блоков, важно помнить, что любое исключение будет обработано лишь одним из них
# - первым, под которое оно подойдет. Остальные except блоки просто не будут исполняться.
# Важно помнить, что мы можем ловить исключения в любой момент исполнения на стеке.
# В примере ниже мы ловим исключение деления на ноль не в момент выполнения деления, а в процессе исполнения функции f:
# def f(x, y):
#     try:
#         return x / y
#     except TypeError:
#         print('TypeError')
# try:
#     print(f(5, 0))
# except ZeroDivisionError:
#     print('ZeroDivisionError')
# Одним except блоком можно поймать сразу несколько типов исключений. Для этого в except блок нужно передавать кортеж с
# типами этих исключений.
# В языке Python мы можем поймать и сам объект ошибки:
# def f(x, y):
#     try:
#         return x / y
#     except (TypeError, ZeroDivisionError) as e:
#         print(type(e))
#         print(e)
#         print(e.args)
# print(f(5, 0))  # return вернет None
# print(f(5, []))  # return вернет None
# Если мы не знаем какой конкретный тип ошибки может произойти, потому что не ожидаем в исполнении блока ошибок, то
# можно указать пустой except без указания типа ошибки. Он поймает любую ошибку, которая произошла внутри кода:
# def f(x, y):
#     try:
#         return x / y
#     except:
#         print('Error')
# Все ошибки в языке Python представляют собой иерархию.
# При этом ошибки не используют множественное наследование. Можно точно гарантировать, что ZeroDivisionError наследуется
# от класса ArithmeticError, который, в свою очередь, наследуется только от Exception и т.д.:
# print(ZeroDivisionError.mro())
# try:
#     15 / 0
#     # e
# except ArithmeticError:  # isinstance(e, ArithmeticError) == True
#     print('ArithmeticError')
# Ключевое слово else используется тогда, когда внутри блока try не возникло никакого исключения.
# Блок finally запускается в любом случае (чтобы закрыть сессию, файл, базу данных, отменить транзакцию, вывести
# окончательное сообщение о совершенных процедурах и т.д, и т.п. перед тем, как приложение крашнется):
# ●	когда исключения не было
# ●	когда мы обработали исключение
# ●	и даже когда есть такое исключение, которое мы обработать не смогли
# Что интересно, блок finally выполняется даже в случае исполнения return внутри try. При этом его код никак не влияет
# на возвращаемое значение, если оно - неизменяемый тип, и влияет, если тип изменяем.
# Синтаксис try-except таков, что только:
# try
# except
# except
# ...........
# else
# finally
# Иерархия исключений:
# https://docs.python.org/3/library/exceptions.html#exception-hierarchy
# def divide(x, y):
#     try:
#         result = x / y
#     except ZeroDivisionError:
#         print('ZeroDivisionError')
#     else:
#         print('result', result)
#     finally:
#         print('finally')
# divide(2, 1)
# divide(2, 0)
# divide(2, [])
# А если требуется поймать все исключение и поработать с инстансом ошибки, то как быть? Просто except: не дает работать
# с инстансом. Правильно в этом случае писать следующий код:
# try:
#     # code
# except Exception as e:
#     print(e)
# Использование except без указания конкретного класса исключения считается плохой практикой, поскольку может
# значительно усложнить отладку. Кроме того, пустая ветка `except` перехватывает специальные исключения, наследующиеся
# от класса `BaseException`, например `SystemExit` или `KeyboardInterrupt` (происходит при нажатии Ctrl+C).
# Поэтому для того чтобы обработать "любое" исключение пишут `except Exception` а не просто `except`