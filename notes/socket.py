# https://docs-python.ru/standart-library/modul-socket-setevoj-interfejs-python/obekt-socket-modulja-socket/

# Атрибуты и методы, определяемые объектом Socket
# Все методы объекта Socket, за исключением метода Socket.makefile(), соответствуют системным вызовам Unix, применимым
# к сокетам.
# Объекты Socket поддерживают протокол диспетчера контекста. Выход из диспетчера контекста эквивалентен вызову функции
# socket.close().
# Содержание:
# Socket.accept() принимает соединение,
# Socket.bind() привязывает сокет к адресу,
# Socket.close() закрывает сокет,
# Socket.connect() подключает к удаленному сокету,
# Socket.connect_ex() работает подобно методу Socket.connect(address),
# Socket.detach() переводит сокет в закрытое состояние,
# Socket.dup() дублирует объект сокета,
# Socket.fileno() возвращает файловый дескриптор сокета,
# Socket.get_inheritable() получает наследуемый флаг дескриптора сокета,
# Socket.getpeername() возвращает удаленный адрес,
# Socket.getsockname() возвращает собственный адрес,
# Socket.getsockopt() возвращает значение заданной опции сокета,
# Socket.getblocking() проверяет режим блокировки,
# Socket.gettimeout() возвращает значение тайм-аут,
# Socket.ioctl() ограниченный интерфейс для WSAIoctl,
# Socket.listen() переводит сервер для приема подключений,
# Socket.makefile() возвращает объект файла, связанный с сокетом,
# Socket.recv() получает данные из сокета,
# Socket.recvfrom() получает данные из сокета,
# Socket.recvmsg() получает обычные и вспомогательные данные из сокета,
# Socket.recvmsg_into() получает нормальные и вспомогательные данные из сокета,
# Socket.recvfrom_into() получает данные из сокета,
# Socket.recv_into() получает от сокета до nbytes байтов,
# Socket.send() отправляет данные в сокет,
# Socket.sendall() отправляет данные в сокет,
# Socket.sendto() отправляет данные в сокет,
# Socket.sendmsg() отправляет обычные и вспомогательные данные в сокет,
# Socket.sendmsg_afalg() специализированная версия Socket.sendmsg(),
# Socket.send_fds() отправляет через сокет список файловых дескрипторов,
# Socket.recv_fds() получает до maxfds файловых дескрипторов,
# Socket.sendfile() отправляет файл до достижения EOF,
# Socket.set_inheritable() устанавливает наследуемый флаг файлового дескриптора,
# Socket.setblocking() устанавливает блокирующий или неблокирующий режим сокета,
# Socket.settimeout() устанавливает тайм-аут для сокета,
# Socket.setsockopt() устанавливает значение опции сокета,
# Socket.shutdown() отключает одну или обе половины соединения,
# Socket.share() копирует сокет и подготавливает его для использования с процессом,
# Socket.family возвращает семейство сокетов,
# Socket.type возвращает тип сокета,
# Socket.proto возвращает протокол сокета,
# Примечания о тайм-аутах сокетов.
#
# Socket.accept():
# Метод Socket.accept() принимает соединение.
# Сокет должен быть привязан к адресу и прослушивать соединения. Возвращаемое значение - это пара (conn, address), где
# - conn - это новый объект сокета, который можно использовать для отправки и получения данных в соединении,
# - address - это адрес, привязанный к сокету на другом конце соединения.
# Вновь созданный сокет не наследуется.
#
# Socket.bind(address):
# Метод Socket.bind() привязывает сокет к адресу address. Сокет еще не должен быть привязан.
# Формат адреса зависит от семейства адресов.
# Вызывает событие аудита socket.bind с аргументами self, address.
#
# Socket.close():
# Метод Socket.close() закрывает сокет.
# Базовый системный ресурс (например, файловый дескриптор) также закрывается, когда закрываются все файловые объекты из
# Socket.makefile(). Как только это произойдет, все будущие операции с объектом сокета завершатся ошибкой.
# После того, как данные из очереди будут сброшены, удаленный сокет не будет получать больше данных.
# Сокеты автоматически закрываются, когда они собираются сборщиком мусора, но рекомендуется явно закрыть их
# Socket.close() или использовать для них оператор with.
# Изменено в Python 3.6: Если возникает ошибка при выполнении базового вызова Socket.close(), то возникает исключение
# OSError.
# Обратите внимание, что Socket.close() освобождает ресурс, связанный с соединением, но не обязательно немедленно
# закрывает соединение. Если необходимо своевременно закрыть соединение, то перед закрытием сокета Socket.close()
# вызовите метод Socket.shutdown().
#
# Socket.connect(address):
# Метод Socket.connect() подключается к удаленному сокету по адресу address. Формат адреса address зависит от семейства
# адресов.
# Если соединение прерывается сигналом, а обработчик сигнала не вызывает исключение и сокет блокируется или имеет
# тайм-аут, то метод ожидает завершения соединения или вызывает по таймауту Socket.timeout.
# Для неблокирующих сокетов, если соединение прерывается сигналом или исключением, созданным обработчиком сигнала, то
# метод вызывает исключение InterruptedError, .
# Вызывает событие аудита socket.connect с аргументами self, address.
# Изменено в Python 3.5: теперь метод ожидает завершения соединения вместо вызова исключения InterruptedError, если
# соединение прерывается сигналом, а обработчик сигнала не вызывает исключения и сокет блокируется или имеет тайм-аут.
#
# Socket.connect_ex(address):
# Метод Socket.connect_ex() работает подобно методу Socket.connect(address), но вместо вызова исключения (возвращаемых
# вызовом connect() языка C) возвращает индикатор ошибки (Исключение может возникнуть, если не найден хост -
# "host not found").
# Индикатор ошибки равен 0, если операция прошла успешно, в противном случае, индикатор ошибки равен значению переменной
# errno. Метод Socket.connect_ex() полезен для поддержки, например, асинхронных подключений.
# Вызывает событие аудита socket.connect с аргументами self, address.
#
# Socket.detach():
# Метод Socket.detach() переводит объект сокета в закрытое состояние, не закрывая дескриптор файла.
# Возвращает дескриптор файла, который может быть повторно использован для других целей.
#
# Socket.dup():
# Метод Socket.dup() дублирует объект сокета Socket. Вновь созданный сокет не наследуется.
#
# Socket.fileno():
# Метод Socket.fileno() возвращает файловый дескриптор сокета (небольшое целое число) или -1 в случае ошибки.
# Метод Socket.fileno() полезен с системным вызовом Unix select.select().
# В Windows возвращаемое этим методом малое целое число, нельзя использовать там, где можно использовать дескриптор
# файла, например os.fdopen(). Unix не имеет этого ограничения.
#
# Socket.get_inheritable():
# Метод Socket.get_inheritable() получает наследуемый флаг дескриптора файла или дескриптора сокета.
# Метод возвращает True, если сокет может быть унаследован в дочерних процессах, False, если нет.
#
# Socket.getpeername():
# Метод Socket.getpeername() возвращает удаленный адрес, к которому подключен сокет.
# Метод полезен, например, для определения номера порта удаленного сокета IPv4/v6. Формат возвращаемого адреса зависит
# от семейства адресов.
# В некоторых системах эта функция не поддерживается.
#
# Socket.getsockname():
# Метод Socket.getsockname() возвращает собственный адрес сокета.
# Метод полезен, например, для определения номера порта сокета IPv4/v6. Формат возвращаемого адреса зависит от семейства
# адресов.
#
# Socket.getsockopt(level, optname[, buflen]):
# Метод Socket.getsockopt() возвращает значение заданной опции сокета (смотрите man-страницу Unix командой $ man
# getsockopt).
# Необходимые символьные константы socket.SO_* и т. д. определены в модуле socket.
# Если аргумент buflen отсутствует, то предполагается целочисленный параметр, и метод возвращает его целое значение.
# Если аргумент buflen присутствует, то он указывает максимальную длину буфера, используемого для приема опции, и этот
# буфер возвращается как байтовый объект.
# Вызывающий объект должен декодировать содержимое возвращаемого буфера. Чтобы узнать, как декодировать структуры
# языка С, закодированные как байтовые строки смотрите встроенный модуль struct.
#
# Socket.getblocking():
# Метод Socket.getblocking() возвращает True, если сокет находится в режиме блокировки, False, если в неблокирующем
# режиме.
# Вызов метода эквивалентен проверке Socket.gettimeout() == 0.

# Новое в Python 3.7.
#
# Socket.gettimeout():
# Метод Socket.gettimeout() возвращает значение тайм-аут float в секундах или None, если тайм-аут не установлен.
# Метод отражает последний вызов Socket.setblocking() или Socket.settimeout().
#
# Socket.ioctl(control, option):
# Только для операционной системы Windows.
# Метод Socket.ioctl() - это ограниченный интерфейс для системного интерфейса WSAIoctl. Для получения дополнительной
# информации, обратитесь к документации Win32.
# На других платформах могут использоваться общие функции |fcntl.fcntl()| и |fcntl.ioctl()|. Они принимают объект сокета
# в качестве своего первого аргумента.
# В настоящее время поддерживаются только следующие управляющие коды: socket.SIO_RCVALL, socket.SIO_KEEPALIVE_VALS и
# socket.SIO_LOOPBACK_FAST_PATH.
# Изменено в Python 3.6: добавлен socket.SIO_LOOPBACK_FAST_PATH.
#
# Socket.listen([backlog]):
# Метод Socket.listen() переводит сервер для приема подключений.
# Если задан необязательный аргумент backlog, то он должен быть не менее 0 (если меньше, то это равно 0).
# Аргумент backlog указывает количество подключений, которые система поставит в очередь, перед отказом от новых подключений. Если не указано, то выбирается разумное значение по умолчанию.
#
#
# Socket.makefile(mode='r', buffering=None, *, encoding=None, errors=None, newline=None):
# Метод Socket.makefile() возвращает объект файла, связанный с сокетом. Точный возвращаемый тип зависит от аргументов, переданных в метод Socket.makefile(). Эти аргументы интерпретируются так же, как и встроенной функцией функции open(), за исключением того, что поддерживаются только значения mode 'r' (по умолчанию), 'w' и 'b'.
#
# Сокет должен находиться в режиме блокировки. У него может быть установлен тайм-аут, но при этом, внутренний буфер файлового объекта может оказаться в несогласованном состоянии, если произойдет этот тайм-аут.
#
# Закрытие файлового объекта, Socket.makefile(), не приведет к закрытию исходного сокета, если все остальные файловые объекты не были закрыты и Socket.close() не был вызван для объекта сокета.
#
# Примечание. В Windows файловый объект, созданный методом Socket.makefile(), нельзя использовать там, где ожидается файловый объект с файловым дескриптором, например как потоковые аргументы функции subprocess.Popen().
#
#
# Socket.recv(bufsize[, flags]):
# Метод Socket.recv() получает данные из сокета. Возвращаемое значение - байтовый объект, представляющий полученные данные.
#
# Максимальный объем данных, которые должны быть получены за один раз, указывается в bufsize.
# Информацию о значении необязательного аргумента flags (по умолчанию он равен нулю) смотрите на справочной странице по recv(2) Unix, командой $ man recv.
# Примечание. Для наилучшего соответствия с аппаратными и сетевыми реалиями значение bufsize должно быть относительно небольшим, например 4096.
#
#
# Socket.recvfrom(bufsize[, flags]):
# Метод Socket.recvfrom() получает данные из сокета. Возвращаемое значение - это парный кортеж (bytes, address), где bytes - это байтовый объект, представляющий полученные данные, а address - это адрес сокета, отправляющего данные. Формат адреса address зависит от семейства адресов.
#
# Информацию о значении необязательного аргумента flags (по умолчанию он равен нулю) смотрите на справочной странице по recv(2) Unix, командой $ man recv.
#
# Изменено в Python 3.7: для адреса IPv6, первый элемент адреса больше не содержит части %scope_id. Чтобы получить полный IPv6-адрес, используйте функцию socket.getnameinfo().
#
#
# Socket.recvmsg(bufsize[, ancbufsize[, flags]]):
# Метод Socket.recvmsg() получает обычные данные до bufsize байтов и вспомогательные данные из сокета.
#
# Аргумент ancbufsize устанавливает размер в байтах внутреннего буфера, используемого для приема вспомогательных данных. По умолчанию он равен 0, это означает, что дополнительные данные не будут получены. Соответствующие размеры буфера для вспомогательных данных можно вычислить с помощью socket.CMSG_SPACE() или socket.CMSG_LEN(), а элементы, которые не помещаются в буфер, могут быть усечены или отброшены.
#
# Информацию о значении необязательного аргумента flags (по умолчанию он равен нулю) смотрите на справочной странице по recv(2) Unix, командой $ man recv.
#
# Возвращаемое значение метода Socket.recvmsg() - это 4-кортеж: (data, ancdata, msg_flags, address).
#
# Элемент данных data - это байтовый объект, содержащий полученные основные данные.
# Элемент ancdata представляет собой список из нуля или более кортежей (cmsg_level, cmsg_type, cmsg_data), представляющих полученные вспомогательные данные (управляющие сообщения):
# cmsg_level и cmsg_type - это целые числа, определяющие уровень протокола и специфичный для протокола тип соответственно,
# cmsg_data - это байтовый объект, содержащий связанные данные.
# Элемент msg_flags - это побитовое ИЛИ различных флагов, указывающих условия в полученном сообщении. подробности смотрите в документации к вашей системы.
# Если принимающий сокет не подключен, то address является адресом отправляющего сокета, если он доступен, в противном случае его значение не указано.
# В некоторых системах методы Socket.sendmsg() и Socket.recvmsg() могут использоваться для передачи файловых дескрипторов между процессами через сокет socket.AF_UNIX. Когда это средство используется (оно часто ограничивается сокетами socket.SOCK_STREAM), то метод Socket.recvmsg() будет возвращать в своих вспомогательных данных элементы формы (socket.SOL_SOCKET, socket.SCM_RIGHTS, fds), где fds - байтовый объект, представляющий новые файловые дескрипторы как двоичный массив собственного типа языка C int. Если метод Socket.sendmsg() вызывает исключение после возврата из системного вызова, то он сначала попытается закрыть все файловые дескрипторы, полученные через этот механизм.
#
# Некоторые системы не указывают усеченную длину элементов вспомогательных данных, которые были получены только частично. Если кажется, что элемент выходит за пределы конца буфера, то Socket.recvmsg() выдаст RuntimeWarning и вернет его часть, которая находится внутри буфера, при условии, что элемент не был усечен до начала связанных с ним данных.
#
# В системах, поддерживающих механизм socket.SCM_RIGHTS, функция recv_fds() (смотрите ниже) будет получать дескрипторы файлов maxfds, возвращая данные сообщения и список, содержащий дескрипторы при игнорировании неожиданных условий, таких как получение несвязанных управляющих сообщений. Смотрите также метод объекта сокета Socket.sendmsg().
#
# import socket, array
#
# def recv_fds(sock, msglen, maxfds):
#     fds = array.array("i")   # Array of ints
#     msg, ancdata, flags, addr = sock.recvmsg(msglen, Socket.CMSG_LEN(maxfds * fds.itemsize))
#     for cmsg_level, cmsg_type, cmsg_data in ancdata:
#         if cmsg_level == Socket.SOL_SOCKET and cmsg_type == Socket.SCM_RIGHTS:
#             # Append data, ignoring any truncated integers at the end.
#             fds.frombytes(cmsg_data[:len(cmsg_data) - (len(cmsg_data) % fds.itemsize)])
#     return msg, list(fds)
# Доступность: большинство платформ Unix, возможно, и другие.
#
#
# Socket.recvmsg_into(buffers[, ancbufsize[, flags]]):
# Метод Socket.recvmsg_into() получает нормальные и вспомогательные данные из сокета, ведя себя как метод Socket.recvmsg(), но разбрасывает нормальные данные в ряд буферов вместо того, чтобы возвращать новый байтовый объект.
#
# Аргумент buffers должен быть итерацией объектов, экспортирующих записываемые буферы, например объекты bytearray). Они будут заполняться последовательными фрагментами нормальных данных до тех пор, пока все они не будут записаны или пока buffers больше не останется. Операционная система может установить ограничение (os.sysconf() со значением SC_IOV_MAX) на количество буферов, которые могут быть использованы.
#
# Аргументы ancbufsize имеет то же значение, что и для метода Socket.recvmsg().
#
# Информацию о значении необязательного аргумента flags (по умолчанию он равен нулю) смотрите на справочной странице по recv(2) Unix, командой $ man recv.
#
# Возвращаемое значение Socket.recvmsg_into() представляет собой 4-кортеж: (nbytes, ancdata, msg_flags, address), где
#
# nbytes - это общее количество байтов нормальных данных, записанных в буферы,
# ancdata, msg_flags и address такие же, как для Socket.recvmsg().
# Пример:
#
# >>> import socket
# >>> s1, s2 = Socket.socketpair()
# >>> b1 = bytearray(b'----')
# >>> b2 = bytearray(b'0123456789')
# >>> b3 = bytearray(b'--------------')
# >>> s1.send(b'Mary had a little lamb')
# # 22
# >>> s2.recvmsg_into([b1, memoryview(b2)[2:9], b3])
# # (22, [], 0, None)
# >>> [b1, b2, b3]
# # [bytearray(b'Mary'), bytearray(b'01 had a 9'), bytearray(b'little lamb---')]
# Доступность: большинство платформ Unix, возможно, и другие.
#
#
# Socket.recvfrom_into(buffer[, nbytes[, flags]]):
# Метод Socket.recvfrom_into() получает данные из сокета, записывая их в буфер вместо создания новой строки байтов.
#
# Возвращаемое значение - это парный кортеж (nbytes, address), где
#
# nbytes - это количество полученных байтов,
# address - адрес сокета, отправляющего данные. Формат адреса address зависит от семейства адресов.
# Информацию о значении необязательного аргумента flags (по умолчанию он равен нулю) смотрите на справочной странице по recv(2) Unix, командой $ man recv.
#
#
# Socket.recv_into(buffer[, nbytes[, flags]]):
# Метод Socket.recv_into() получает от сокета до nbytes байтов, сохраняя данные в буфере buffer, а не создавая новую строку байтов.
#
# Если nbytes не указан или равен 0, то получает до размера, доступного в данном буфере. Возвращает количество полученных байтов.
#
# Информацию о значении необязательного аргумента flags (по умолчанию он равен нулю) смотрите на справочной странице по recv(2) Unix, командой $ man recv.
#
#
# Socket.send(bytes[, flags]):
# Метод Socket.send() отправляет данные в сокет. Отправляющий сокет должен быть подключен к удаленному сокету.
#
# Необязательный аргумент flags имеет то же значение, что и для метода Socket.recv() выше.
#
# Возвращает количество отправленных байтов. Приложения несут ответственность за проверку того, что все данные были отправлены. Если была передана только часть данных, то приложению необходимо попытаться доставить оставшиеся данные.
#
# Для получения дополнительной информации по этой теме обратитесь к разделу "Рекомендации по программированию сокетов".
#
#
# Socket.sendall(bytes[, flags]):
# Метод Socket.sendall() отправляет данные в сокет. Отправляющий сокет должен быть подключен к удаленному сокету.
#
# Необязательный аргумент flags имеет то же значение, что и для метода Socket.recv() выше.
#
# В отличие от метода Socket.send(), этот метод продолжает отправлять байтовые данные до тех пор, пока не будут отправлены все данные или не возникнет ошибка. В случае успеха ничего не возвращается. При ошибке возникает исключение и невозможно определить, сколько данных было успешно отправлено.
#
#
# Socket.sendto(bytes, address)
# Socket.sendto(bytes, flags, address):
# Метод Socket.sendto() отправляет данные в сокет. Отправляющий сокет не должен быть подключен к удаленному сокету, поскольку сокет назначения указан в аргументе address. Формат адреса address зависит от семейства адресов.
#
# Необязательный аргумент flags имеет то же значение, что и для метода Socket.recv() выше.
#
# Метод Socket.sendto() возвращает количество отправленных байтов. Вызывает событие аудита socket.sendto с аргументами self, address.
#
#
# Socket.sendmsg(buffers[, ancdata[, flags[, address]]]):
# Метод Socket.sendmsg() отправляет обычные и вспомогательные данные в сокет, собирая обычные данные из ряда буферов и объединяя их в одно сообщение.
#
# Аргумент buffers определяет обычные данные как итерацию байтоподобных объектов (например, объектов bytes); Операционная система может установить ограничение (os.sysconf() со значением SC_IOV_MAX) на количество buffers, которые могут использоваться.
#
# Аргумент ancdata указывает вспомогательные данные (управляющие сообщения) как итерацию из нуля или более кортежей (cmsg_level, cmsg_type, cmsg_data), где
#
# cmsg_level и cmsg_type - целые числа, определяющие уровень протокола и тип, специфичный для протокола соответственно,
# cmsg_data - это байтоподобный объект, содержащий связанные данные.
# Обратите внимание, что некоторые системы (в частности, системы без socket.CMSG_SPACE()) могут поддерживать отправку только одного управляющего сообщения за вызов.
#
# Необязательный аргумент flags имеет то же значение, что и для метода Socket.recv() выше.
#
# Если аргумент address не равен None, то он устанавливает адрес назначения для сообщения.
#
# Метод Socket.sendmsg() возвращает количество отправленных байтов обычных данных.
#
# В примере ниже функция send_fds() отправляет список файловых дескрипторов fds через сокет socket.AF_UNIX в системах, поддерживающих механизм socket.SCM_RIGHTS. Смотрите также метод Socket.recvmsg().
#
# import socket, array
#
# def send_fds(sock, msg, fds):
#     return sock.sendmsg([msg], [(Socket.SOL_SOCKET, Socket.SCM_RIGHTS, array.array("i", fds))])
# Доступность: большинство платформ Unix, возможно, другие.
#
# Вызывает событие аудита socket.sendmsg с аргументами self, address.
#
#
# Socket.sendmsg_afalg([msg, ]*, op[, iv[, assoclen[, flags]]]):
# Метод Socket.sendmsg_afalg() это специализированная версия Socket.sendmsg() для сокета socket.AF_ALG.
#
# Устанавливает режим, IV, AEAD, связанную длину данных и флаги для сокета socket.AF_ALG.
#
# Доступность: Linux >= 2.6.38.
#
# Новое в Python 3.6.
#
#
# Socket.send_fds(sock, buffers, fds[, flags[, address]]):
# Метод Socket.send_fds() отправляет список файловых дескрипторов fds через сокет socket.AF_UNIX.
#
# Параметр fds представляет собой последовательность файловых дескрипторов.
#
# Значение и поведение остальных аргументов метода смотрите в Socket.sendmsg().
#
# Доступность: Unix поддерживает механизм Socket.sendmsg() и SCM_RIGHTS.
#
# Новое в Python 3.9.
#
#
# Socket.recv_fds(sock, bufsize, maxfds[, flags]):
# Метод Socket.recv_fds() получает до maxfds файловых дескрипторов. Возвращает (msg, list(fds), flags, addr).
#
# Значение и поведение аргументов метода смотрите в Socket.recvmsg().
#
# Доступность: Unix поддерживает механизм Socket.recvmsg() и SCM_RIGHTS.
#
# Новое в Python 3.9.
#
# Обратите внимание на любые усеченные целые числа в конце списка файловых дескрипторов.
#
#
# Socket.sendfile(file, offset=0, count=None):
# Метод Socket.sendfile() отправляет файл до тех пор, пока не будет достигнут EOF с помощью высокопроизводительной системной функции os.sendfile и возвращает общее количество отправленных байтов.
#
# Аргумент file должен быть обычным файловым объектом, открытым в двоичном режиме mode='rb'.
#
# Если системная функция os.sendfile недоступна (например, Windows) или файл не является обычным файлом, вместо него будет использоваться метод Socket.send().
#
# Аргумент offset указывает, откуда начать чтение файла.
#
# Аргумент count, если указан, то это общее количество байтов для передачи в отличие от отправки файла до достижения EOF. Положение файла обновляется при возврате или также в случае ошибки, в этом случае file.tell() можно использовать для определения количества отправленных байтов.
#
# Сокет должен быть типа socket.SOCK_STREAM. Неблокирующие сокеты не поддерживаются.
#
#
# Socket.set_inheritable(inheritable):
# Метод Socket.set_inheritable() устанавливает наследуемый флаг inheritable файлового дескриптора сокета или дескриптора сокета.
#
#
# Socket.setblocking(flag):
# Метод Socket.setblocking() устанавливает блокирующий или неблокирующий режим сокета: если флаг False, то сокет установлен в неблокирующий режим, в противном случае - в режим блокировки.
#
# Этот метод является сокращением для некоторых вызовов Socket.settimeout():
#
# Socket.setblocking(True) эквивалентен Socket.settimeout(None);
# Socket.setblocking(False) эквивалентен Socket.settimeout(0.0).
# Изменено в Python 3.7: метод больше не применяет флаг socket.SOCK_NONBLOCK к Socket.type.
#
#
# Socket.settimeout(value):
# Метод Socket.settimeout() устанавливает тайм-аут для блокировки операций сокета.
#
# Аргумент value может быть неотрицательным числом float, выражающим секунды, или None.
#
# Если аргументу value задано ненулевое значение, то последующие операции сокета вызовут исключение socket.timeout, если значение периода тайм-аута истекло до завершения операции.
# Если value=0, то сокет переводится в неблокирующий режим.
# Если value=None, то сокет переводится в режим блокировки.
# Для получения дополнительной информации смотрите "Примечания о тайм-аутах сокетов".
#
# Изменено в Python 3.7: метод больше не переключает флаг socket.SOCK_NONBLOCK на Socket.type.
#
#
# Socket.setsockopt(level, optname, value: int)
# Socket.setsockopt(level, optname, value: buffer)
# Socket.setsockopt(level, optname, None, optlen: int):
# Метод Socket.setsockopt() устанавливает значение value данной опции optname сокета (см. Страницу руководства Unix setsockopt (2)).
#
# Необходимые символьные константы socket.SO_* и т. д. определены в модуле socket. Значение value может быть целым числом, None или байтовым объектом, представляющим буфер. В последнем случае вызывающая сторона должна убедиться, что строка байтов содержит правильные биты (как кодировать структуры языка С в байтовые строки, смотрите встроенный модуль struct). Если установлено значение None, то требуется аргумент optlen. Это эквивалентно вызову функции C setsockopt() с optval=NULL иoptlen=optlen`.
#
# Изменено Python 3.6: добавлена ​​форма Socket.setsockopt(level, optname, None, optlen: int).
#
#
# Socket.shutdown(how):
# Метод Socket.shutdown() отключает одну или обе половины соединения.
#
# Если how=socket.SHUT_RD, то дальнейшее получение запрещено.
# Если how=socket.SHUT_WR, то дальнейшая отправка запрещена.
# Если how=socket.SHUT_RDWR, то дальнейшая отправка и получение запрещены.
#
# Socket.share(process_id):
# Метод Socket.share() копирует сокет и подготавливает его для совместного использования с целевым процессом.
#
# Целевой процесс должен быть предоставлен с идентификатором процесса process_id. Результирующий объект bytes затем может быть передан целевому процессу с использованием некоторой формы межпроцессного взаимодействия и сокет может быть воссоздан там с помощью функции socket.fromshare().
#
# После вызова этого метода можно безопасно закрыть сокет, поскольку операционная система уже продублировала его для целевого процесса.
#
# Обратите внимание, что нет методов read() или write(), вместо них используйте методы Socket.recv() и Socket.send() без аргумента flags.
#
# Доступность: Windows.
#
#
# Socket.family:
# Атрибут Socket.family возвращает семейство сокетов (только для чтения).
#
#
# Socket.type:
# Атрибут Socket.type возвращает тип сокета (только для чтения).
#
#
# Socket.proto:
# Атрибут Socket.proto возвращает протокол на котором работает сокет (только для чтения).
#
#
# Примечания о тайм-аутах сокетов.
# Объект сокета может находиться в одном из трех режимов: блокирующий, неблокирующий или тайм-аут. По умолчанию сокеты всегда создаются в режиме блокировки, но это можно изменить, вызвав функцию socket.setdefaulttimeout().
#
# В режиме блокировки, операции блокируются до тех пор, пока не будут завершены или система не возвратит ошибку (например, истекло время ожидания соединения).
# В неблокирующем режиме операции завершаются неудачно (с ошибкой, которая, к сожалению, зависит от системы), если они не могут быть выполнены немедленно: можно использовать функции из модуля select для определения того, когда и доступен ли сокет для чтения или записи.
# В режиме тайм-аута операции завершаются ошибкой, если они не могут быть завершены в течение тайм-аута, указанного для сокета (они вызывают исключение socket.timeout) или если система возвращает ошибку.
# Примечание. На уровне операционной системы сокеты в режиме тайм-аута внутренне устанавливаются в неблокирующий режим. Кроме того, режимы блокировки и тайм-аута используются совместно дескрипторами файлов и объектами сокетов, которые относятся к одной и той же конечной точке сети. Эта деталь реализации может иметь видимые последствия, если, например, вы решили использовать метод сокета Socket.fileno().
#
# Тайм-ауты и метод подключения.
# Операция соединения Socket.connect() также зависит от установки тайм-аута, и в целом рекомендуется вызвать Socket.settimeout() перед вызовом Socket.connect() или передать параметр timeout в функцию socket.create_connection().
#
# Однако системный сетевой стек может также возвращать собственную ошибку тайм-аута соединения независимо от любого параметра тайм-аута сокета Python.
#
# Тайм-ауты и метод Socket.accept().
# Если результат функции socket.getdefaulttimeout() не равен None, то сокеты, возвращаемые методом Socket.accept(), наследуют этот тайм-аут. В противном случае поведение зависит от настроек прослушивающего сокета:
#
# если прослушивающий сокет находится в режиме блокировки или в режиме тайм-аута, то сокет, возвращаемый функцией Socket.accept(), находится в режиме блокировки;
# если прослушивающий сокет находится в неблокирующем режиме, то состояние сокета, возвращаемый методом Socket.accept(),
# полностью зависит от операционной системы. Если необходимо обеспечить кросс-платформенное поведение, то рекомендуется
# вручную переопределить этот параметр.

######################################################################################################################

# https://docs-python.ru/standart-library/modul-socket-setevoj-interfejs-python/rekomendatsii-programmirovaniju-soketov/
# Советы по программированию сокетов в Python
# Во первых этот материал для тех, кто уже пробовал программировать сокеты, а во вторых здесь будет говорится только о
# сокетах INET (то есть IPv4) STREAM (т.е. TCP), так как они составляют не менее 99% используемых сокетов. От сокета
# STREAM можно получить лучшую производительность, чем от какого-то другого. Так же приоткроем тайну того, что такое
# сокет и дадим несколько советов, как работать с блокирующими и неблокирующими сокетами. Начнем разбираться с
# блокирующих сокетов, т.к. необходимо знать, как они работают, прежде чем работать с неблокирующими сокетами,

# Содержание.
# Что такое сокет и как он создается?
# Межпроцессорное взаимодействие (IPC),
# Использование сокета,
# Прием/передача двоичных данных,
# Закрытие соединения сокета,
# Когда умирают сокеты,
# Неблокирующие сокеты,
# Пример асинхронного сервера с вызовом select.select().

# Проблема с пониманием работы сокетов заключается в том, что сокет может означать несколько разных тонких вещей в
# зависимости от контекста. Итак, сначала проведем различие между клиентским сокетом - конечной точкой диалога и
# серверным сокетом, который больше похож на оператора коммутатора. Клиентское приложение, например браузер, использует
# исключительно клиентские сокеты, а веб-сервер, с которым он разговаривает, использует как серверные, так и клиентские
# сокеты.
#
# Что такое сокет и как он создается?
# Грубо говоря, когда происходит переход по ссылке на сайте, браузер делает что-то вроде следующего:

# # создал INET, STREAM сокет
# sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# # подключился к веб-серверу по обычному https-порту
# sock.connect((`docs-python.ru`, 443))

# Когда устанавливается соединение sock.connect(), то сокет sock можно использовать для отправки текста страницы. Тот
# же сокет прочитает ответ, а затем будет уничтожен. Клиентские сокеты обычно используются только для разового обмена
# данными или небольшого набора последовательных обменов данными.
# То, что происходит на веб-сервере, немного сложнее. Сначала веб-сервер создает серверный сокет:

# # создает INET, STREAM сокет
# serv_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# # связывает сокет с общедоступным хостом и хорошо известным портом
# serv_sock.bind((socket.gethostname(), 443))
# # и начинает ждать подключений
# serv_sock.listen(5)

# Следует отметить пару вещей: в коде выше использовалась функция socket.gethostname(), чтобы сокет был виден внешнему
# миру. Если использовать вызов serv_sock.bind(('localhost', 443)) или serv_sock.bind(('127.0.0.1', 443)), то серверный
# сокет был бы виден только локальной машине. Вызов serv_sock.bind(('', 443)) указывает, что сокет доступен по любому
# адресу.
# Второе замечание: порты с небольшим числом (обычно до 3-х цифр) зарезервированы для "хорошо известных" служб `(HTTPS, SNMP и т. д.), по этому, в качестве номера порта сокета всегда необходимо использовать числа их 4-х цифр, например 8000.
#
# Наконец, аргумент 5 вызова serv_sock.listen(5), говорит модулю socket, чтобы сервер поставил в очередь до 5 клиентов на подключение (нормальный максимум), прежде чем отклонять остальные запросы. Если остальная часть кода написана правильно, то этого должно быть достаточно.
#
# Теперь, когда есть серверный сокет, прослушивающий 443 порт, можно войти в основной цикл веб-сервера:

# while True:
#     # принимаем подключение
#     (clientsocket, address) = serv_sock.accept()
#     # здесь что-то делают с `serv_sock`...
#     # сделаем вид, что это потоковый сервер
#     client = client_thread(client_sock)
#     client.run()

# Существует 3 основных способа, которыми этот цикл может работать:
# - диспетчеризация потока для работы с клиентским сокетом,
# - создание нового процесса для работы с клиентским сокетом,
# - реструктуризация всего приложения для использования неблокирующих сокетов и мультиплексирование между серверным сокетом и любыми активными клиентскими сокетами используя модуль select.
# Подробнее об этом позже. Сейчас важно понять, что это все, что делает серверный сокет. Он не отправляет и не получает никаких данных. Он просто воспроизводит/создает клиентские сокеты. Каждый клиентский сокет создается в ответ на то, что какой-то новый клиентский сокет выполняет подключение sock.connect() к серверу на определенный хост и порт. На этот запрос, сервер создает новый клиентский сокет, и как только он это сделает то сразу возвращается к прослушиванию следующих подключений. Два клиента могут свободно общаться, например на каком-нибудь динамически выделенном порту, который будет закрыт после общения.
#
#
# Межпроцессорное взаимодействие (IPC).
# Если необходим быстрый IPC между двумя процессами на одной машине, то следует изучить каналы Pipe() или общую память (объекты Value() и Array()). Если все же решите использовать socket.AF_INET сокеты, то необходимо привязать серверный сокет к localhost. На большинстве платформ это позволит сократить несколько уровней сетевого кода и будет работать немного быстрее.
#
# Смотрите также модуль multiprocessing, который интегрирует межплатформенный IPC в API более высокого уровня.
#
#
# Использование сокета.
# Первое, на что следует обратить внимание, это то, что клиентский сокет браузера и клиентский сокет веб-сервера - полностью идентичны. То есть, это диалог одноранговый. Обычно сокет, который подключается к серверу начинает диалог, отправляя запрос или возможно, вход в систему. Но это уже решение программиста, а не сокета, как построить диалог.
#
# Для приема/передачи данных можно использовать методы объекта сокета Socket.send() и Socket.recv(), а можно превратить клиентский сокет в файловый объект и использовать чтение/запись. По поводу использования сокета, как файлового объекта, необходимо сделать предупреждение, что в сокетах, при выполнении записи, нужно использовать вызов file.flush(). Сокеты имеют дело с буферизованными "файлами" и распространенной ошибкой является - записать что-то и не вызвать file.flush(), а затем перейти в режим чтения ответа. При этом можно бесконечно долго ждать ответа, т. к. записанные данные все еще могут оставаться в выходном буфере.
#
# Теперь о главном в программировании сокетов, методы Socket.send() и Socket.recv() основное внимание уделяют обработке сетевых буферов. Эти методы не обязательно обработают все байты, которые им передаются или считываются из них, за один вызов. Методы возвращают количество обработанных байтов, когда сетевой буфер заполняется Socket.send() или считывается/извлекается Socket.recv(). Программист несет ответственность за то, чтобы вызывать эти методы снова и снова, пока сообщение не будет полностью обработано (передано или считано).
#
# Когда метод Socket.recv() возвращает 0 байтов, это означает, что другая сторона закрыла или находится в процессе закрытия соединения. Следовательно данные из этого подключении больше не будут поступать. Например протокол HTTP/HTTPS использует сокет только для одной передачи. Клиент отправляет запрос, затем читает ответ, сокет закрывается, это означает, что клиент (браузер) может определить конец ответа, получив 0 байтов.
#
# Но если в планах повторно использовать открытый сокет для каких-то задач, то нужно понимать, что в сокетах нет EOT - "end of trensfer" (конец файла). ЕЩЕ РАЗ: если сокет после вызова методов Socket.send() или Socket.recv() возвращает 0 байтов, то соединение было разорвано. Если соединение не было разорвано, то можно вечно ждать получения данных вызовом Socket.recv(), т. к. сокет не может сказать, что читать больше нечего.
#
# Теперь должно прийти понимание фундаментальной истины сокетов: сообщения должны быть либо определенной фиксированной длины, либо разделены на несколько частей маркерами, либо с указанием длины сообщения (что намного лучше), либо заканчиваться отключением соединения. Выбор полностью за программистом.
#
# В общем, самым простым решением являются сообщения фиксированной длины:

# class MySocket:
#     """демонстрационный класс -  этот код
#        представлен для понимания процесса,
#        а не для эффективности
#     """
#
#     def __init__(self, sock=None):
#         if sock is None:
#             self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
#         else:
#             self.sock = sock
#
#     def connect(self, host, port):
#         self.sock.connect((host, port))
#
#     def mysend(self, msg):
#         totalsent = 0
#         while totalsent < MSGLEN:
#             sent = self.sock.send(msg[totalsent:])
#             if sent == 0:
#                 raise RuntimeError("Соединение сокета нарушено")
#             totalsent = totalsent + sent
#
#     def myreceive(self):
#         chunks = []
#         bytes_recd = 0
#         while bytes_recd < MSGLEN:
#             chunk = self.sock.recv(min(MSGLEN - bytes_recd, 2048))
#             if chunk == b'':
#                 raise RuntimeError("Соединение сокета нарушено")
#             chunks.append(chunk)
#             bytes_recd = bytes_recd + len(chunk)
#         return b''.join(chunks)

# Например можно использовать какой то определенный код отправки практически для любой схемы обмена сообщениями. В Python сокетах ведь отправляются строки, следовательно можно использовать функцию len() для определения их длины. В основном, усложняется код приема.
#
# Самое простое решение, это сделать первый символ сообщения индикатором "типа" сообщения и в этом "типе" передавать длину сообщения. Теперь, когда в начале сообщения передается его длина, то необходимо вызвать метод Socket.recv() два раза: первый - чтобы получить длину сообщения, и второй в цикле, для получения частями самого сообщения (если оно большое), ориентируясь на эту длину.
#
# Если идти по пути сообщений с маркерами, то необходимо получать фрагменты произвольного размера и сканировать полученное сообщение в поисках этих маркеров. Фрагменты по 4096 или 8192 часто хорошо подходят для размеров сетевого буфера. При этом следует помнить об одной сложности: если используемый протокол позволяет отправлять несколько сообщений друг за другом без какого-либо ответа, а вызов Socket.recv() читает произвольный размер фрагмента, то можно в конечном итоге, не чайно, прочитать начало следующего сообщения. В этом случае нужно его запомнить и держать, пока оно не понадобится.
#
# Добавление в начало сообщения его длины больше 4-х цифр, скажем 5 цифровых символов становится более сложным, потому что (хотите верьте, хотите нет) нельзя получить все 5 символов за один вызов, следовательно количество циклов Socket.recv() увеличивается до 3-х, а то и больше. При высоких нагрузках код, не использующий два цикла вызова Socket.recv() - первый для определения длины, второй для получения сообщения с данными, очень быстро сломается. В этот момент еще обнаружите, что методу Socket.send() не всегда удается отослать все сообщение за один вызов. И несмотря на то, что здесь про это написано, в конечном итоге ВЫ все равно наступите на эти грабли!
#
# В интересах создания первого приложения с использованием сокетов, вышесказанные улучшения оставлены как упражнение для читателя.
#
#
# Прием/передача двоичных данных.
# Вполне возможно отправлять двоичные данные через сокет. Основная проблема заключается в том, что не все машины используют одни и те же форматы для двоичных данных. Например, чип Motorola будет представлять 16-битное целое число, например 1 в виде двух шестнадцатеричных байтов - 00 01. Intel и DEC переворачивают байты - то же самое число 1 здесь будет выглядеть как 01 00. Модуль socket имеет функции для преобразования 16 и 32-битных целых чисел - socket.ntohl(), socket.htonl(), socket.ntohs() и socket.htons(), где в названиях первая буква означает n - сеть, а h - хост, а последняя s - короткий, а l - длинный. Там, где сетевой порядок является порядком хоста, функции ничего делать не будут, но там, где машина перевернула байты, они соответствующим образом все поменяют.
#
# Ascii-представление двоичных данных часто меньше по размеру, чем двоичное представление этих же данных. Строка '0' будет состоять из двух байтов, а двоичная - из четырех. Конечно, это не очень хорошо сочетается с сообщениями фиксированной длины.
#
#
# Закрытие соединения сокета.
# Строго говоря, сначала необходимо использовать вызов объекта сокета shutdown(), прежде чем закрыть его командой Socket.close(). Вызов Socket.shutdown() - это предупреждение для сокета на другом конце. В зависимости от аргумента, который передавать, это может означать "Я больше не буду отправлять, но я все равно буду слушать" или "Я не слушаю, мне по барабану". Разработчики библиотек сокетов настолько привыкли к тому, что программисты пренебрегают этим элементом этикета, что у некоторых, обычный вызов Socket.close() - означает последовательность вызовов: Socket.shutdown(); Socket.close(). Поэтому в большинстве ситуаций явный вызов Socket.shutdown() не требуется.
#
# Один из способов эффективного использования shutdown(), это обмен данными, подобный HTTP. Клиент отправляет запрос и затем завершает работу вызовом Socket.shutdown(1). Это сообщает серверу: "Этот клиент завершил отправку, но все еще может получать". Сервер читая запрос, в конце получает 0 байтов, это сигнализирует о том, что от клиента весь запрос получен и надо готовить и отправлять ответ. Если отправка ответа завершилась успешно, то клиент действительно слушал и получил все отправленные данные.
#
# Python делает еще один шаг к автоматическому завершению соединения, это постоянный мониторинг открытых сокетов сборщиком мусора. Сборщик мусора автоматически закрывает соединение, если это необходимо. Но полагаться на это - очень плохая привычка. Если сокет просто исчезнет без закрытия, то сокет на другом конце может зависнуть бесконечно думая, что сервер просто медленно работает и когда закончит, то закроет сокет.
#
#
# Когда умирают сокеты.
# Худшее в использовании блокирующих сокетов - это то, что происходит, когда одна из сторон соединения резко падает (без закрытия). Сокет скорее всего зависнет. TCP - надежный протокол и он будет долго ждать, прежде чем отказаться от соединения. Если использовать потоки, то весь поток практически умрет. С этим ничего не поделаешь и если не делать глупостей, таких как держать блокировку при выполнении чтения, то поток не съест много ресурсов.
#
# Не пытайтесь убить поток - одна из причин того, что потоки более эффективны, чем процессы, заключается в том, что у них нет накладных расходов, связанных с автоматическим повторным использованием ресурсов. Другими словами, если удастся убить поток, то вся программа, скорее всего, упадет.
#
#
# Неблокирующие сокеты
# Чтобы сделать сокет неблокирующим, в Python используют вызов Socket.setblocking(False). Вызов делается после создания сокета, но перед его использованием. Если программист не очень умный, то скорее всего попытается переключаться туда и обратно (с блокирующего сокета на неблокирующий).
#
# Основное механическое отличие состоит в том, что вызовы Socket.send(), Socket.recv(), Socket.connect() и Socket.accept() могут возвращать результат без каких-либо действий. И здесь есть несколько вариантов. Можно проверить ответ, который вернул соответствующий вызов и код ошибки и вообще свести себя с ума. Если не верите, попробуйте как-нибудь. Приложение будет разрастаться, глючить и загружать процессор. Так что давайте пропустим безумные решения и сделаем все правильно.
#
# Одним из возможных решений является делегирование работы с клиентами отдельным потокам. Однако создание потоков и переключение контекстов между ними на самом деле не является дешевой операцией. Для решения этой проблемы существует так называемый асинхронный способ работы с сокетами. Основная идея состоит в том, чтобы делегировать поддержание состояния сокета операционной системе и позволить ей уведомлять программу, когда есть что-то для чтения из сокета или когда он готов к записи. Для этого можно использовать вызов операционной системы select, подробнее о нем можно посмотреть командой терминала Unix $ man select
#
# В Python такой вызов сделать совсем несложно, для этой цели используйте встроенный модуль select, в частности вызов select.select():

# ready_to_read, ready_to_write, in_error = \
#     select.select(
#                   potential_readers,
#                   potential_writers,
#                   potential_errs,
#                   timeout
#                   )

# Здесь передается в select.select() три списка:
# - potential_readers содержит все сокеты, которые нужно прочитать,
# - potential_writers содержит все сокеты, в которые надо что-то записать,
# - potential_errs - которые нужно проверять на наличие ошибок (обычно оставляют пустым).
# Следует отметить, что один сокет может входить в разные списки. Вызов select.select() блокируется, но можно задать ему таймаут. Как правило, это разумный поступок - дайте ему длительный таймаут (скажем, минуту), если нет веских причин поступить иначе.
#
# Взамен получаем три списка. Они содержат сокеты, которые действительно доступны для чтения, записи и содержат ошибки. Каждый из этих списков является подмножеством, возможно пустым, соответствующего переданного списка в select.select().
#
# Если сокет находится в выходном списке ready_to_read, то вызов метода Socket.recv() на этом сокете может что-то вернуть. Та же идея для списка сокетов ready_to_write - можно что-нибудь отправить. Может быть, не все, но что-то лучше, чем ничего. На самом деле, любой достаточно здоровый сокет будет возвращен как доступный для записи - это означает, что доступно исходящее сетевое буферное пространство.
#
# Если есть "серверный" сокет, то поместим его в список potential_readers. Если он появится в списке ready_to_read, то вызов .accept почти наверняка сработает. Если сервер создал новый сокет для подключения, то поместим его в список potential_writers. Если он отображается в списке ready_to_write, то есть неплохие шансы, что он подключился.
#
# Предупреждение о переносимости: в Unix, модуль select работает как с сокетами, так и с файлами. Не пытайтесь использовать это в Windows. В Windows, модуль select работает только с сокетами. Также обратите внимание, что в языке C многие из более продвинутых параметров сокетов в Windows выполняются иначе. Фактически, в Windows обычно используют потоки, которые работают очень и очень хорошо с сокетами.
#
#
# Пример асинхронного сервера с вызовом select.select().
# В примере вызывается select.select(), для опроса сокетов операционной системой, готовы ли они к записи, чтению или есть ли какое-то ошибки в сокетах. Этот вызов блокирует программу (если не передан аргумент тайм-аута) до тех пор, пока не будут готовы какие нибудь из переданных сокетов. По готовности хоты-бы одного из сокетов, вызов select.select() вернет три списка с сокетами для указанных операций. Затем программа последовательно перебирает эти списки и выполняет соответствующие операции.

# import select, socket, queue
#
# server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# server.setblocking(False)
# server.bind(('localhost', 50000))
# server.listen(5)
# inputs = [server]
# outputs = []
# message_queues = {}
#
# while inputs:
#     readable, writable, exceptional = select.select(inputs, outputs, inputs)
#     for s in readable:
#         if s is server:
#             connection, client_address = s.accept()
#             connection.setblocking(False)
#             inputs.append(connection)
#             message_queues[connection] = queue.Queue()
#         else:
#             data = s.recv(1024)
#             if data:
#                 message_queues[s].put(data)
#                 if s not in outputs:
#                     outputs.append(s)
#             else:
#                 if s in outputs:
#                     outputs.remove(s)
#                 inputs.remove(s)
#                 s.close()
#                 del message_queues[s]
#
#     for s in writable:
#         try:
#             next_msg = message_queues[s].get_nowait()
#         except queue.Empty:
#             outputs.remove(s)
#         else:
#             s.send(next_msg)
#
#     for s in exceptional:
#         inputs.remove(s)
#         if s in outputs:
#             outputs.remove(s)
#         s.close()
#         del message_queues[s]

# Когда в списке readable присутствует сокет сервера, это означает, что пришел новый клиент. Поэтому программа вызывает
# метод Socket.accept() и добавляет возвращаемый методом клиентский сокет, в список inputs, а так же создает для него очередь входящих сообщений message_queues. Если в списке readable есть НЕ серверный сокет, то это означает, что от клиента прибыли некоторые сообщения и готовы к чтению. В этом случае производится чтение сообщения и добавления его в очередь с ключом этого сокета.
#
# Для сокетов из списка writable программа извлекает сообщение из соответствующей очереди message_queues (если есть) и записывает их в сокет. Если в сокете есть ошибка, он удаляет сокет из всех списков опроса (inputs и outputs).
#
# Так работают сокеты на низком уровне. В большинстве случаев нет необходимости реализовывать логику на таком низком уровне. Рекомендуется использовать некоторые абстракции более высокого уровня, такие как |Twisted|, |Tornado| или |ZeroMQ|, в зависимости от ситуации.