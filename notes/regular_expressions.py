# Регулярные выражения в Python
# Оригинальная документация на английском:
# https://docs.python.org/3/library/re.html
# Очень подробный и обстоятельный материал на английском:
# https://www.regular-expressions.info/
# Удобный сервис для тестирования и отладки регулярных выражений (не забудьте выбрать Python):
# https://regex101.com/
# Онлайн визуализация регулярок (не забудьте выбрать Python):
# https://www.debuggex.com/
# Лист с подсказками синтаксиса сгруппированный и компактный:
# https://www.debuggex.com/cheatsheet/regex/python
# Статья -  https://tproger.ru/translations/regular-expression-python
# Шпаргалка - http://www.exlab.net/files/tools/sheets/regexp/regexp.pdf
# http://pythex.org/ - весьма удобный инструмент, позволяющий "в живую" смотреть на то, как работают reg exp.
# Хорошая статья по регуляркам в python - https://habrahabr.ru/post/349860/

# Для того, чтобы указать, что строка является сырой (raw), перед ней нужно добавить символ r
# x = 'Hello\nword'
# print(x)
# x = r'Hello\nword'  # raw
# print(x)
# Сырые строки используют тогда, когда нужно в записи строки использовать обратный слеш. В частности, в регулярных
# выражениях.
# Для использования регулярных выражений подключаем модуль re (regular expressions):
# import re
# print(re.match)
# print(re.search)
# print(re.findall)
# print(re.sub)

# Функция match
# Ищет совпадение по заданному шаблону в начале строки.
# pattern = r"abc"
# string = "abcd"
# match_object = re.match(pattern, string)
# print(match_object)  # <re.Match object; span=(0, 3), match='abc'>
# [] можно указывать множество подходящих символов (любой из указанных)
# pattern = r"a[abc]c"
# string = "accd"

# Функция search
# Находит в строке первую подстроку, которая подходит под заданный шаблон.
# pattern = r"abc"
# string = "babcd"
# match_object = re.search(pattern, string)
# print(match_object)  # <re.Match object; span=(1, 4), match='abc'>

# Функция findall
# Находит в строке все подстроки, которые подходят под заданный шаблон. Возвращает все непересекающиеся подстроки.
# pattern = r"a[abc]c"
# string = "abc, a.c, aac, a-c, aBc, azc, aaa"
# all_inclusions = re.findall(pattern, string)
# print(all_inclusions)  # ['abc', 'aac']

# Функция sub
# Позволит заменить все подстроки, которые подходят под заданный шаблон, чем-нибудь другим.
# pattern = r"a[abc]c"
# string = "abc, a.c, aac, a-c, aBc, azc, aaa"
# fixed_typos = re.sub(pattern, "abc", string)
# print(fixed_typos)  # abc, a.c, abc, a-c, aBc, azc, aaa

# Собственно, регулярные выражения и будут описывать шаблон.

# match сравнивает - подходит ли вся строка под наш шаблон, а search - просто ищет вхождение шаблона в строку.
# Т.е., если грубо, то в шаблоне может быть забит пример регулярки для email вида foo@bar.tld. И match проверяет -
# действительно ли в строке электропочта (email@gmail.com), а search может найти подходящий под шаблон кусок строки,
# хотя сама строка не является валидным адресом (em@am@email@gmail.com111).

# Можно из dir(match_object) вытащить, чего в нем есть:
# import re
# mo = re.search(r"a[xyz]c", "abc_axc_azc")
# print(dir(mo))  # [ ...все атрибуты...]
# print(mo)       # <re.Match object; span=(4, 7), match='axc'>
# print(mo.string, mo.pos, mo.endpos)     # abc_axc_azc 0 11
# print(mo.group(), mo[0])                # axc axc
# print(mo.span(), mo.start(), mo.end())  # (4, 7) 4 7

# Пример использования регулярных выражений:
# pattern = r"a.c"
# string = "acc"
# match_object = re.match(pattern, string)
# print(match_object)  # <re.Match object; span=(0, 3), match='acc'>
#
# string = "abc, a.c, aac, a-c, aBc, azc, aaa"
# all_inclusions = re.findall(pattern, string)
# print(all_inclusions)  # ['abc', 'a.c', 'aac', 'a-c', 'aBc', 'azc']
#
# fixed_typos = re.sub(pattern, "abc", string)
# print(fixed_typos)  # abc, abc, abc, abc, abc, abc, aaa

# Метосимвол обозначает, что нам надо сделать что-то специальное. Если надо использовать метасимвол в качестве обычного
# символа его надо экранировать обратным слешем - \?.
# [] -- можно указать множество подходящих символов
# [abc] - указанные символы
# [a-zA-Z] - указанный диапазон (в примере все символы алфавита)
# [^a-zA-Z] - символ карет(циркум флекс) ^ позволяет задать множество символов, которые не подходят
# ^ - карет, обозначает либо начало строки, либо инвертирование группы символов. (например: "^[^0-9]" — не цифра в
# начале строки).
# . ^ $ * + ? { } [ ] \ | ( ) -- метасимволы
# короткая запись часто используемых выражений:
# \d ~ [0-9] -- цифры
# \D ~ [^0-9]
# \s ~ [ \t\n\r\f\v] -- пробельные символы
# \S ~ [^ \t\n\r\f\v]
# \w ~ [a-zA-Z0-9_] -- буквы + цифры + _
# \W ~ [^a-zA-Z0-9_]
# пример - r"a[\w.]c" - буквы + цифры + _ и точка (дополнить короткую запись)
# пример - r"a.c" - любой символ, кроме переноса строки
# пример - r"ab*c" - любое число повторений заданного символа, включая 0
# пример - r"ab+c" - любое число повторений заданного символа, большее 0
# пример - r"ab?c" - означает 0 или 1 вхождение символа
# пример - r"ab{3}c" - задает конкретное количество или диапазон вхождений символа - {2, 5}. В фигурных скобках после
# запятой можно ничего не ставить и искать больше или равно символов чем n - {3, }, { , 3}.
# pattern = r"ab{2,4}a"
# string = "aa, aba, abba, abbba, abbbba, abbbbba"
# all_inclusions = re.findall(pattern, string)
# print(all_inclusions)  # ['abba', 'abbba', 'abbbba']
# Метасимволы являются “жадными”. Поэтому по умолчанию, если под шаблон подходят несколько вариантов вхождений, то
# вернется самый длинный из них.
# pattern = r"a[ab]+a"
# string = "abaaba"
# print(re.match(pattern, string))  # <re.Match object; span=(0, 6), match='abaaba'>
# print(re.findall(pattern, string))  # ['abaaba']
# Мы можем указать функции, что хотим искать не жадным способом (ленивым) Т.е. найти наименьшее вхождение, которое бы
# удовлетворило нашему регулярному выражению. Для этого мы можем использовать ? после нашего метасимвола:
# pattern = r"a[ab]+?a"
# string = "abaaba"
# print(re.match(pattern, string))  # <re.Match object; span=(0, 3), match='aba'>
# print(re.findall(pattern, string))  # ['aba', 'aba']
# То есть можем использовать для нахождения повторов символа или группы, но аккуратно - т.к. по умолчанию он "жадный".
# пример - r"(test)*" - группировка нескольких символов
# pattern = r"(test)*"
# string = "testtest"
# print(re.match(pattern, string))  # <re.Match object; span=(0, 8), match='testtest'>
# пример - r"(test|text)*" - операция или к элементам. Обладает наименьшим приоритетом в регулярных выражениях.
# pattern = r"(test|text)*"
# string = "texttest"
# print(re.match(pattern, string))  # <re.Match object; span=(0, 8), match='texttest'>
# Методы группировки
# pattern = r"((abc)|(test|text)*)"
# string = "texttest"
# match = re.match(pattern, string)
# print(match)  # <re.Match object; span=(0, 8), match='texttest'>
# print(match.groups())  # ('texttest', None, 'test') 3 группа последнее вхождение test
# Метод групп с явной передачей номера группы
# pattern = r"Hello (abc|text)"
# string = "Hello abc"
# match = re.match(pattern, string)
# print(match)  # <re.Match object; span=(0, 9), match='Hello abc'>
# print(match.group())  # Hello abc
# print(match.group(1))  # abc
# Использование группы внутри регулярного выражения
# pattern = r"(\w+)-\1"  # \1 - говорит - найди такую же группу, как ты собрал ранее (номер группы по открывающей скобке)
# string = "test-test"  # не допустим "test-text" потому что не совпадает с первой группой
# match = re.match(pattern, string)
# print(match)  # <re.Match object; span=(0, 9), match='test-test'>
# Оставить только первую группу из повторяющихся
# pattern = r"(\w+)-\1"
# string = "test-test chow-chow"
# duplicates = re.sub(pattern, r'\1', string)
# print(duplicates)  # test chow
# Аккуратно с группами с findall - будет возвращать кортеж групп
# pattern = r"(\w+)-\1"
# string = "test-test chow-chow"
# duplicates = re.findall(pattern, string)
# print(duplicates)  # ['test', 'chow']
#
# pattern = r"((\w+)-\2)"  # кортеж - первое поймали сначала группу, а второй наше слово, которое через дефис удвоили
# string = "test-test chow-chow"
# duplicates = re.findall(pattern, string)
# print(duplicates)  # [('test-test', 'test'), ('chow-chow', 'chow')]

# Если нам нужно найти " english\?"
# ? тогда - "  english\\\?"
# символ карет удобно и быстро вводить альт-кодом 94, зажимаете alt и набираете 94
# \r перенос каретки как бы все подтирает, что было в строке до нее, начиная строку с начала (добавляя еще белое
# пространство).
# Дефис внутри квадратных скобок будет считаться как обычный символ только в двух случаях:
# дефис экранирован слэшем [a\-c] - это значит, что допускается один из трех символов a, с, -
# дефис идет в начале или в конце выражения: [-ac] или [ac-]
# Во всех остальных случаях дефис будет идти как идентификартор рейнджа. Так как рейнджа w-. не существует, то
# интерпретатор выдает ошибку. А вот на [\w.-] не ругается.

# А почему если :
# pattern = r'(test)*'
# string = 'testtest'
# то,
# print(re.findall(pattern, string))  # ['test', ''] ????
# почему не
# ['test', 'test'] ??
# Если в паттерне присутствует одна или более групп, то возвращается список групп. А пустая строка вторым элементом в
# выдаче потому, что *, а её устраивает 0. Если pattern = r'(test)+', то пустой строки не будет.


# Зачем использовать сырые строки, если модуль re все равно воспринимает их как "несырые", т.е. экранирование не
# отключается?
# Все правильно. Потому, что для \? нет escape-последовательности. Попробуем по другому:
# Дана строка
# str_01 = 'one\\t'
# print(str_01)  # one\t
# Два шаблона
# pat_01 = 'one\\t'
# pat_02 = r'one\\t'
# print(re.match(pat_01, str_01))  # None
# print(re.match(pat_02, str_01))  # < re.Match object; span = (0, 5), match = 'one\\t' >
# В первом случаем мы искали Табуляцию (\t), (после экранирующего слеша получилось \t, в регулярном выражение - это
# значит искать табуляцию). Во втором случае искали \\t (то есть \t  в "голом" тексте).
# Рекомендуют сразу применять "сырые" строки, чтобы таких накладок не было. Применил, и думать забыл.
# Escape-последовательности, это такой набор символов, с помощью которого можно вывести на экран невидимые, или
# управляющие символы. Например:
# перевод строки (\n):
# print("Hello\nHello")
# Hello
# Hello
# Или горизонтальная табуляция (\t) - аналогична клавише Tab:
# print("Hello\tHello")
# Hello    Hello
# Или клавиша backspace (удалить последний символ) - \b:
# print("Hello\b")
# Hell
# Сырые строки работаю везде, не только в модуле re.
# Например:
# print(r"Hello\tHello")
# Hello\tHello
# Обратите внимание, что в строке не сработала последовательность- \t . Табуляции уже нет. То есть строка отобразилась
# на экране, как есть. То есть "сырая", без обработки.
# А вообще, совет такой. Возьмите себе за привычку, везде применять обычные строки. В шаблонах модуля re, применять
# сырые строки.
# И для примера. Вам вдруг понадобилось вывести такую строку на экран "Тут будет перевод строки\nА это новая строка".
# То лучшем решением будет сделать так:
# print("Тут будет перевод строки\\nА это новая строка") - то есть добавить экранирующий слэш (\)
# А вот если шаблон для регулярного выражения, то сразу без раздумий пишите:
# pattern = r"*.A{2}"
# Так принято в народе. Да и вы перестанете думать, где надо сырая, а где нет. Как и я.

# Нашла опытным путем, что [а-яё] можно заменить на [а-ё], а вот с [A-Ё] так не получится. Потому что судя по всем
# алфавит идет так эюяё ЁАБВ. Поэтому заглавные пишем так: [Ё-Я]. Итого, ваш код можно переписать так:
# import re
# regex1 = r"\b[а-яА-Я]+"
# regex2 = r"\b[а-ёЁ-Я]+"
# s = "Ежиха ела ёлку. Ёжик сел на ель."
# print(re.findall(regex1, s))
# print(re.findall(regex2, s))

# def print_chr(start=1000, end=1111):
#     print('      ', end='')
#     for i in range(10):
#         print(i, end=' ')
# for i in range(1000, 1111):
#     if i % 10 == 0:
#         print('\n', i, end=' ')
#     print(chr(i), end=' ')
# print()
# print_chr()
# 0 1 2 3 4 5 6 7 8 9
#  1000 Ϩ ϩ Ϫ ϫ Ϭ ϭ Ϯ ϯ ϰ ϱ
#  1010 ϲ ϳ ϴ ϵ ϶ Ϸ ϸ Ϲ Ϻ ϻ
#  1020 ϼ Ͻ Ͼ Ͽ Ѐ Ё Ђ Ѓ Є Ѕ
#  1030 І Ї Ј Љ Њ Ћ Ќ Ѝ Ў Џ
#  1040 А Б В Г Д Е Ж З И Й
#  1050 К Л М Н О П Р С Т У
#  1060 Ф Х Ц Ч Ш Щ Ъ Ы Ь Э
#  1070 Ю Я а б в г д е ж з
#  1080 и й к л м н о п р с
#  1090 т у ф х ц ч ш щ ъ ы
#  1100 ь э ю я ѐ ё ђ ѓ є ѕ
#  1110 і

# Регулярное выражение — это строка, задающая шаблон поиска подстрок в тексте. Одному шаблону может соответствовать
# много разных строчек.
# Регулярное выражение, или коротко «регулярка», состоит из обычных символов и специальных командных
# последовательностей. Например, \d задаёт любую цифру, а \d+ — задает любую последовательность из одной или более цифр.
# import re
#
# x = re.match(r"(te)*?xt", "TEXT", re.IGNORECASE | re.DEBUG)
# print(x)

# При использовании re.sub так флаг работать не будет:
# print(re.sub(r'(te)*?xt', 'color', 'TEXT', re.IGNORECASE))
# документация говорит, что будет работать только при явном использовании именованного аргумента:
# print(re.sub(r'(te)*?xt', 'color', 'TEXT', flags=re.IGNORECASE))

# Использование такой конструкции, как "cat.*cat". То есть мы ищем строки, в которых есть хотя бы два слова cat, между
# которыми может быть любое количество любых символов

# Если мы указываем строку '\\', то в итоге у нас получится строка '\', при обработке (первый символ экранирования,
# второй уже непосредственно символ). Нам же надо, чтобы в модуль re ушла строка '\\'. Т.е. если не использовать raw,
# то надо передовать в модуль строку '\\\\'. В этом случае при работе программы модуль получит строку '\\', и один из
# символов \ будет считаться служебным.

# Вам дана последовательность строк.
# Выведите строки, содержащие "cat" в качестве подстроки хотя бы два раза.
# import sys
# import re
# for line in sys.stdin:
#     line = line.rstrip()
#     if len(re.findall(r"cat", line)) > 1:
#         print(line)
#
# for line in sys.stdin:  # пример правильного решения и регулярного выражения
#     line = line.strip()
#     if re.search(r"cat.*cat", line):
#         print(line)
#
# pattern = r"(.*(cat).*){2,}"
# [print(line.rstrip()) for line in sys.stdin if re.match(pattern, line)]

# Вам дана последовательность строк.
# Выведите строки, содержащие "cat" в качестве слова.
# import sys
# import re
# for line in sys.stdin:
#     line = line.strip()
#     if re.search(r"\bcat\b", line):
#         print(line)

# Вам дана последовательность строк.
# Выведите строки, содержащие две буквы "z", между которыми ровно три символа.
# import sys
# import re
# for line in sys.stdin:
#     line = line.strip()
#     if re.search(r"z...z", line):  # if re.search(r'z.{3}z', line):
#         print(line)

# Вам дана последовательность строк.
# Выведите строки, содержащие обратный слеш "\".
# import sys
# import re
# for line in sys.stdin:
#     line = line.strip()
#     if re.search(r"\\", line):  # f chr(92) in line:
#         print(line)

# Вам дана последовательность строк.
# Выведите строки, содержащие слово, состоящее из двух одинаковых частей (тандемный повтор).
# import sys
# import re
# for line in sys.stdin:
#     line = line.strip()
#     if re.search(r"\b(\w+)\1\b", line):  # (r"(\b.*\B)\1\b", line)  if re.match(r'\b(.+)\1\b', line):
#         print(line)
# '\B' обозначает, что после предыдущего символа нет пробела. В варианте r"(\b.*\B)\1\b" представьте, что мы  сначала
# ищем блок (пробел + любое количество любых символов кроме пробела + не пробел), а потом проверяем есть ли рядом с ним
# такая же последовательность символов и пробел.

# Вам дана последовательность строк.
# В каждой строке замените все вхождения подстроки "human" на подстроку "computer" и выведите полученные строки.
# import sys
# import re
# for line in sys.stdin:
#     line = line.strip()
#     print(re.sub(r"human", "computer", line))  #
#
# print(re.sub(r'human', 'computer', sys.stdin.read()), end='')