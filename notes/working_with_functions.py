# Класс map - применяет функцию к каждому члену последовательности
# n, k = map(int, input().split())  # f [a, b, c, ...] -> f(a), f(b), f(c) ...
# print(n + k)
# x = input().split()
# n, k = (int(i) for i in x)  # то же действие другим синтаксисом
# print(n + k)
# map не выдает все значения сразу, а является итератором и по нему можно итерироваться:
# map_obj = map(int, ['10', '20', '30'])
# a = next(map_obj)
# b = next(map_obj)
# c = next(map_obj)
# print(a + b + c)
# Важно понимать, что объекты класса map вычисляют значения достаточно лениво.
# В тот момент, когда мы создаем объект нашего класса map, мы на самом деле запоминаем лишь две ссылки: на функцию и на
# итератор второго аргумента. Лишь в момент когда нас спрашивают какой элемент является следующим, мы считаем следующий
# элемент из итератора и применяем к нему ту функцию, которую нам передали.

# Класс filter
# Также принимает 2 аргумента: функцию и последовательность - элементы которой мы хотим отфильтровать.
# Функция должна возвращать True, если элемент последовательности нам подходит и False, если не подходит.
# x = input().split()
# xs = (int(i) for i in x)
# def even(x):
#     return x % 2 == 0
# evens = filter(even, xs)
# for i in evens:
#     print(i)
# Конструктор класса filter возвращает нам filter object. Он, в свою очередь, является итератором и внутри него
# реализован метод next().
# Если в конструктор класса list мы поместим итератор, он попробует собрать все элементы из данного итератора и
# поместить их внутрь данного списка.
# Однако, пользоваться им стоит аккуратно. Если вы уверены, что ваш итератор, во-первых, возвращает конечное число
# элементов, а, во-вторых, если они разумно умещаются в оперативной памяти.
# evens = list(filter(even, xs))
# print(evens)

# Сначала мы не знали функций и методов:
# print(' '.join([i for i in input().split() if int(i)%2 == 0]))
# Затем мы познакомились с функциями и методами:
# def even(x):
#     return x%2 == 0
# print(' '.join([i for i in input().split() if even(int(i))]))
# И наконец, освоили лямбда-функции:
# print(' '.join([i for i in input().split() if (lambda x: x%2 == 0)(int(i))]))

# Чем отличается filter от map? Обе функции принимают в качестве аргументов функцию и последовательность. Разница в том,
# что map применяет свою функцию ко всем объектам, а функция в filter должна возвращать логическое значение True/False
# и сама возвращает элементы для которых выполнилось True. map просто применяет функцию (любую) к элементам любой
# последовательности (данные типа float и str).

# lambda функции
# lambda функции в языке Python - это простой синтаксис для создания новых объектов функций (коротко и лаконично писать
# короткие функции для передачи внутрь другой функции). Лямбда функции предоставляют нам удобный способ создать функцию
# «прямо на месте».
# def even(x):
#     return x%2 == 0
# even = lambda x: x % 2 == 0  # заменим функцию выше
# evens = list(filter(lambda x: x % 2 == 0, xs))  # потом заменим even созданной функцией
# print(evens)
# Синтаксис использования:
# ●	Сначала идет ключевое слово lambda
# ●	Затем до двоеточия мы указываем аргументы, которые принимает наша функция. И здесь верны все те же правила, что
# верны и для аргументов обычных функций. Мы можем определить аргументы со звездочкой, с двумя звездочками и аргументы
# со значением по умолчанию.
# ●	После двоеточия следует одно выражение. Оно должно быть возвращаемым значением функции.
# Удобство использования lambda функций заключается в том, что их можно передавать внутрь других функций.
# x = [
#     ("Guido", "van", "Rossum"),
#     ("Haskell", "Curry"),
#     ("John", "Backus")
# ]
# def length(name):
#     return len(''.join(name))
# # name_lengths = [length(name) for name in x]
# # print(name_lengths)
# x.sort(key=length)
# print(x)
# x.sort(key=lambda name: len(''.join(name)))  # заменили функцию выше короткой записью
# print(x)
#
# never_use_this_at_production_code = lambda x: lambda y: lambda z: x * y * z
# mul2 = never_use_this_at_production_code(2)
# mul3 = mul2(3)
# print(mul3(4))  # 24
# Пример лямбды в лямбде в лямбде, и вызова в скрипте, можно наверное и с рекурсией что нибудь придумать, но я бы вместо
# этого воспользовался обычными функциями :)

# f = [lambda x, i=i: x ** i for i in range(10)]
# print(f[3](2))  # 8print(f[9](2))  # 512
# онкость тут в том, что i - именованный аргумент, а такие аргументы вычисляются / присваиваются один раз при создании
# функции (актуально для любой функции, просто в данном случае у нас лямбда). Тут каждая лямбда вычисляет / сохраняет
# свою i  в момент генерации списка, если что.
# Тонкость в том, что, когда мы объявляем функцию, то переменные, которые мы в ней пишем, не вычисляются в момент
# объявления (за исключением значений по умолчанию). Поэтому когда мы пишем:
# f = [lambda x: x ** i for i in range(10)]
# То просто создаем список из 10 одинаковых функций вида: lambda x: x**i
# Вариант, когда мы передаем i в качестве значения по умолчанию, рассмотрен выше, значение по умолчанию вычисляется в
# момент создания функции, поэтому мы получим список, состоящий из функций вида: [(lambda x, i=0: x**i),
# (lambda x, i=1: x**i), ..., (lambda x, i=9: x**i)]
# Есть ещё один вариант, без использования значений по умолчанию:
# f = [eval('lambda x: x ** ' + str(i)) for i in range(10)]
# Здесь мы сначала конструируем строку, содержащую текст функции, а затем исполняем указанное выражение, создавая
# нужную нам функцию.

# Модуль operator
# Модуль operator экспортирует набор эффективных функций, которые соответствуют внутренним операторам Python.
# Например operator.add(x, y) эквивалентен выражению x + y.
# import operator as op
# print(op.add(4, 5))
# print(op.mul(4, 5))
# print(op.contains([1, 2, 3], 4))  # 4 in [1, 2, 3]  # вхождение в список
# Самыми интересными функциями в данной библиотеке являются itemgetter(), который позволяет нам достать элемент
# какой-нибудь коллекции и attrgetter(), который позволяет достать атрибут у какого-нибудь объекта.
# x = [1, 2, 3]
# f = op.itemgetter(1)  # f(x) == x[1]
# print(f(x))
# В результате Python выведет 2, так как она является 1-м элементом списка x (отчет с нуля).
# По аналогии с помощью этого метода можно обращаться к элементам словаря:
# x = {"123": 3}
# f = op.itemgetter("123")  # f(x) == x["123"]
# print(f(x))
# Конструктор attrgetter() ведет себя почти подобным образом, но он пытается взять атрибут у объекта:
# f = op.attrgetter("sort")  # f(x) == x.sort
# print(f([]))

# x = [
#     ("Guido", "van", "Rossum"),
#     ("Haskell", "Curry"),
#     ("John", "Backus")
# ]
# import operator as op
# x.sort(key=op.itemgetter(-1))  # сортировка по последнему элементу
# print(x)
# можем легко взять атрибуты объектов, которые у тебя объявлены в твоем классе, если класс делает столы и у него
# (у объекта-стола)есть атрибут площадь ты можем его быстренько достать. Кажется в этом удобство. Читать  с атрибутами
# объектов: https://habrahabr.ru/post/137415/
# как бы значит, что вы взяли ссылку на атрибут sort у list, т.е. f(x) == x.sort . Если вы теперь вызовите этот метод,
# т.е. напишите f(x)() или g(), а потом выведите список x, то увидите, что теперь он отсортирован.

# Модуль functools
# Функция partial()
# partial() получает функцию A с аргументами и возвращает новую функцию B, вызов которой эквивалентен вызову функции A
# с указанными аргументами.
# import operator as op
# from functools import partial  # Запомнить некоторые аргументы с которыми мы хотели вызвать функцию, и их не надо
# передавать
# x = int('1001', base=2)  # перевод двоичного в десятичное
# print(x)
# int_2 = partial(int, base=2)  # Запомнили
# x = int_2('1001')
# print(x)
#
# x = [
#     ("Guido", "van", "Rossum"),
#     ("Haskell", "Curry"),
#     ("John", "Backus")
# ]
# sort_by_last = partial(list.sort, key=op.itemgetter(-1))  # Запомнили
# print(x)
# sort_by_last(x)  # применили
# print(x)
#
# y = ["abc", "cba", "abb"]
# sort_by_last(y)  # применили на других данных
# print(y)

# Конечно reduce творит чудеса. Жаль, что про данный метод не рассказали. На мой взгляд наглядный пример её
# использования - подсчет факториала:
# from functools import reduce
# def factorial(n):
#    return reduce(lambda x, y: x*y, range(1, n+1))
# Разница между map() и reduce()?. map применяет функцию к каждому элементу коллекции в отдельности. На выходе список.
# reduce  же множит вашу операцию на весь список. Например reduce(lambda x,y: x+y, range(1,10)) - это сумма элементов
# от 1 до 9. Как будто вы суммируете не 2 элемента а все 9.
# from functools import reduce
# x = [1, 2, 3, 4, 5, 6, 7]
# print(list(map(lambda x: x + x, x)))  # каждый элемент складывается сам на себя
# print(reduce(lambda x, y: x + y, x))  # первый и второй элемент складываются, на следующей итерации первым элементом
# # становятся сложенные элементы, а вторым становится 3 элемент
# Вывод:
# [2, 4, 6, 8, 10, 12, 14]
# 28
# import this. Гвидо не любит лямбда функции, в питоне 3 их вообще хотели выпилить.
# Еще partial возвращает функцию с всякими встроенными атрибутами, такие как args, keywords и func.
# А еще мы можем поменять те аргументы которые "забросили" с помощью partial.
# int_2('31', base=8)
# partial ведет себя как обычная функция, только с заранее заполнеными аргументами, а lambda - это есть недофункция.
# Если вы говорите что у partial куча доп. кода, лагов, значит и у функций то же самое, что звучит как бред.


# Лямбда функции предоставляют нам удобный способ создать функцию «прямо на месте».
# Но иногда, когда нужно создавать много однотипных лямбда функций, еще удобнее будет создать функцию, которая будет их
# генерировать.
# Реализуйте функцию mod_checker(x, mod=0), которая будет генерировать лямбда функцию от одного аргумента y, которая
# будет возвращать True, если остаток от деления y на x равен mod, и False иначе.

def mod_checker(x, mod=0):
    return lambda y: y % x == mod

mod_3 = mod_checker(3)
print(mod_3(3))  # True
print(mod_3(4))  # False
mod_3_1 = mod_checker(3, 1)
print(mod_3_1(4))  # True

mod_checker = lambda x, mod=0: lambda y: y % x == mod  # решение в одну строку
