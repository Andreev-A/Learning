# создание списка  #####################################################################################################
# a = [2, 3, 4]
# a = list([1, 2, 3])
# list(range(10))  # генератор списка

# методы списка  #######################################################################################################

# .append()  # добавить в конец (один элемент)
# .extend([5, 5])  # добавить в конец (несколько элементов)
# .insert(3, 'a')  # вставить в определенное место
# .index('i', 5, 7)  # индекс элемента  (необязат. (5-нач., 7-кон.), возвращает первое вхождение, нет элемента - ошибка)
# .pop(0) - получить элемент по индексу [0], удаляя его из последовательности (по умолчанию () - последний)
# my_list[1] = 200  # заменить в списке
# del my_list[5]  # удалить элемент (с конкретного места)
# my_list.remove('s')  # удаляет первый по порядку элемент 's'
# my_list.count('d')  # количество элементов в списке
# min(my_list), max(my_list), summa(my_list)  # найти мин, макс, сумму (для списка чисел)
# my_list.sort()  # сортировать список
# sorted(my_list)  # если не надо изменить сам список (создает в памяти отсортированную копию)

#   zip() - profit = [100, 20]
#   days = ['пн', 'вт']
#   res = zip(profit, days)
#   print(list(res)) или res = list(zip(profit, days)) или print(dict(zip(days, profit)))
# ___сортировка по второму элементу: work_list.sort(name=lambda x: x[1]) или lst.sort(name=itemgetter(1)) с
# from operator import itemgetter
# ___получить элемент по индексу удаляя его из последовательности: dots = [segments.pop(0)[1]] for l, r in segments:

# Метод isupper() проверяет, все ли символы в строке находятся в верхнем регистре.
# Метод не принимает никаких параметров
# Метод в Python возвращает: Истинно, если все символы в строке являются прописными. False, если какие-либо символы в
# строке являются строчными.
# a = 'sdf'
# a.isupper()
# print(a)
# В python-е все функции/методы что-то возвращают - либо значение, либо None. reverse() изменяет сам объект и ничего не
# возвращает - только и всего

# Хранение в памяти
# При создании списка, в памяти резервируется пустая область. С одной стороны, это ничем не отличается от создания
# любого другого типа данных, но разница в том, что содержимое list может меняться:
# numbers = [1, 2]
# numbers[1] = 3
# # обновлённый список: [1, 3]
# До замены элемента последовательности print(numbers[1]) выведет 2, а после замены — 3.
# Создание списка в Python
# Это можно сделать несколькими способами, например перечислением элементов списка в квадратных скобках:
# numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
# При этом единица будет на позиции 0, то есть print(numbers[0]) выведет 1.
# Также можно использовать обработку итерируемого объекта функцией list(). Пусть у нас будет некоторая строка, тогда:
# list('tproger')
# # ['t', 'p', 'r', 'o', 'g', 'e', 'r']
# Также существуют генераторы списков, которые позволяют применить заданное выражение к каждому элементу
# последовательности. Допустим, необходимо создать list, состоящий из чисел от 1 до 5 включительно:
# numbers = [i for i in range(1,6)]
# # [1, 2, 3, 4, 5]
# Срезы (slice) списка
# Срезы позволяют получить некое подмножество значений. Следующий код вернёт список с элементами, начиная индексом 0 и
# не включая при этом индекс 2 и выше:
# numbers = [1, 5, 9, 6]
# print(numbers[0:2])
# # вывод [1, 5]
# Далее выведем всё, за исключением элемента на позиции 3:
# print(numbers[:3])
# # вывод [1, 5, 9]
# А теперь начиная с индекса 1 и до конца:
# print(numbers[1:])
# # вывод [5, 9, 6]
# Операции над списками Python
# x in l — true, если элемент x есть в списке l;
# x not in l — true, если элемент x отсутствует в l;
# l1 + l2 — объединение двух списков;
# l * n_test , n_test * l — копирует список n_test раз;
# len(l) — количество элементов в l;
# min(l) — наименьший элемент;
# max(l) — наибольший элемент;
# sum(l) — сумма чисел списка;
# for i in list() — перебирает элементы слева направо.
# Методы списков Python
# Index
# Возвращает положение первого совпавшего элемента. Поиск совпадения происходит слева направо. Пример:
# numbers = [1, 5, 9, 6, 1, 2, 1]
# print(numbers.index(1))
# # вывод 0: первая найденная единица на позиции 0
# Count
# Данный метод считает, сколько раз указанное значение появляется в списке Python:
# numbers = [1, 5, 9, 6, 1, 2, 1]
# print(numbers.count(1))
# # вывод 3, потому что единица встречается 3 раза
# Append
# Добавляет указанное значение в конец:
# numbers = [1, 5, 9, 6]
# numbers.append(3)
# # обновлённый список: [1, 5, 9, 6, 3]
# Sort
# Сортирует список в Пайтоне. По умолчанию от меньшего к большему:
# numbers = [1, 5, 9, 6]
# numbers.sort()
# # обновлённый список: [1, 5, 6, 9]
# Также можно сортировать последовательность элементов от большего к меньшему:
# numbers = [1, 5, 9, 6]
# numbers.sort(reverse = true)
# # обновлённый список: [9, 6, 5, 1]
# Insert
# Вставляет элемент перед указанным индексом:
# numbers = [1, 5, 9, 6]
# numbers.insert(3, [2, 3])
# # обновлённый список: [1, 5, 9, [2, 3], 6]
# Remove
# Удаляет первое попавшееся вхождение элемента в списке Python:
# numbers = [1, 5, 9, 6, 1, 2, 1]
# numbers.remove(1)
# # обновлённый список: [5, 9, 6, 1, 2, 1]
# Extend
# Подобно методу append(), добавляет элементы, но преимущество метода extend() в том, что он также позволяет добавлять
# списки:
# numbers = [1, 5, 9, 6]
# numbers.extend([2, 3])
# # обновлённый список: [1, 5, 9, 6, 2, 3]
# Pop
# Данный метод удаляет элемент в конкретно указанном индексе, а также выводит удалённый элемент. Если индекс не указан,
# метод по умолчанию удалит последний элемент:
# numbers = [1, 5, 9, 6]
# numbers.pop(1)
# # получаем:
# # 5
# # [1, 9, 6]
# Join
# Преобразовывает список в строку. Разделитель элементов пишут в кавычках перед методом, а сам список Питона должен
# состоять из строк:
# mylist = ['сайт', 'типичный', 'программист']
# print(', '.join(mylist))
# # вывод 'сайт, типичный, программист'

# x = ['abc', 'a', 'ab', 'abcd']
# # Сортировка элементов списка по возрастанию:
# # 1
# x.sort(name=len)
# print(x)
# # ['a', 'ab', 'abc', 'abcd']
# # 2
# new_x = sorted(x, name=len)
# print(new_x)
# # ['a', 'ab', 'abc', 'abcd']
# # В обратном порядке:
# # 1
# x.sort(name=len, reverse=True)
# print(x)
# # ['abcd', 'abc', 'ab', 'a']
# # 2
# new_x = sorted(x, name=len, reverse=True)
# print(new_x)
# # ['abcd', 'abc', 'ab', 'a']
# # Разница между sort() и sorted() в том, что первый - сортирует список на месте, возвращая None. Второй - возвращает
# # новый отсортированный список.

# Для преобразования листа листов в лист можно использовать вот такую функцию:
# def flatten(lst):
#     return [y for x in lst for y in x]
# Пример:
# lst = [[1, 2, 3], [4, 5, 6]]
# print(flatten(lst))
# [1, 2, 3, 4, 5, 6]

# lst.sort(key = lambda x: (x[0], x[1]))  # отсортирует по первому элементу туплей, с учётом второго, если первые совпадают

# l.sort(key=lambda x: (-x[0], x[1]), reverse=True)  # в порядке убывания 0, 1 - по алфавиту

# Python-код для преобразования списка кортежей в список
# Список инициализации кортежа
lt = [('Geeks', 2), ('For', 4), ('geek', '6')]
# использование списка понимания
out = [item for t in lt for item in t]
# вывод на печать
print(out)

# Импорт
import itertools
# Список инициализации кортежа
tuple = [(1, 2), (3, 4), (5, 6)]
# Использование itertools
out = list(itertools.chain(*tuple))
# вывод на печать
print(out)

# Добавление элемента в множество осуществляется с помощью метода add,
# Чтобы удалить элемент из множества, можно воспользоваться одним из двух методов: discard или remove. Если удаляемого
# элемента в множестве не было, то discard не изменит состояния множества, а remove выпадет с ошибкой.