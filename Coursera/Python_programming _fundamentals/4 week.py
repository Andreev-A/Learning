"""Напишите функцию min4(a, b, c, d), вычисляющую минимум четырех чисел, которая не содержит инструкции if, а использует
стандартную функцию min от двух чисел. Считайте четыре целых числа и выведите их минимум."""
# def min4(a, b, c, d):
#     return min(min(a, b), min(c, d))
# a1, b1, c1, d1 = int(input()), int(input()), int(input()), int(input())
# print(min4(a1, b1, c1, d1))

"""Даны четыре действительных числа: x₁, y₁, x₂, y₂. Напишите функцию distance(x1, y1, x2, y2), вычисляющую расстояние
между точками (x₁,y₁) и (x₂,y₂). Считайте четыре действительных числа и выведите результат работы этой функции."""
# def distance(x_1, y_1, x_2, y_2):
#     return ((x_2 - x_1) ** 2 + (y_2 - y_1) ** 2) ** 0.5
# x1, y1, x2, y2 = float(input()), float(input()), float(input()), float(input())
# print(round(distance(x1, y1, x2, y2), 5))

"""Напишите функцию, вычисляющую длину отрезка по координатам его концов. С помощью этой функции напишите программу,
вычисляющую периметр треугольника по координатам трех его вершин."""
# def perimeter_triangle(x_1, y_1, x_2, y_2, x_3, y_3):
#     a = ((x_2 - x_1) ** 2 + (y_2 - y_1) ** 2) ** 0.5
#     b = ((x_3 - x_2) ** 2 + (y_3 - y_2) ** 2) ** 0.5
#     c = ((x_3 - x_1) ** 2 + (y_3 - y_1) ** 2) ** 0.5
#     return a + b + c
# x1, y1, x2, y2 = float(input()), float(input()), float(input()), float(input())
# x3, y3 = float(input()), float(input())
# print(round(perimeter_triangle(x1, y1, x2, y2, x3, y3), 6))

"""Даны два действительных числа x и y. Проверьте, принадлежит ли точка с координатами(x,y) заштрихованному квадрату
(включая его границу). Если точка принадлежит квадрату, выведите слово YES, иначе выведите слово NO. На рисунке сетка
проведена с шагом 1. (нарисован ромб с координатами (диагоналями) -1, 1 по оси и x и y)."""
# def IsPointInSquare(x, y):
#     x_f = round(1 - abs(y), 6)
#     y_f = round(1 - abs(x), 6)
#     return -x_f <= x <= x_f and -y_f <= y <= y_f
# x, y = float(input()), float(input())
# if IsPointInSquare(x, y):
#     print('YES')
# else:
#     print('NO')

"""Даны пять действительных чисел: x, y, xc, yc, r.
Проверьте, принадлежит ли точка (x,y) кругу с центром (xc, yc) и радиусом r.
Если точка принадлежит кругу, выведите слово YES, иначе выведите слово NO.
Решение должно содержать функцию IsPointInCircle(x, y, xc, yc, r), возвращающую True, если точка принадлежит кругу и
False, если не принадлежит.
Основная программа должна считать координаты точки, вызвать функцию IsPointInCircle и в зависимости от возвращенного
значения вывести на экран необходимое сообщение. Функция IsPointInCircle не должна содержать инструкцию if.
Формат ввода - Вводится пять действительных чисел.
Формат вывода - Выведите ответ на задачу."""
# x, y = float(input()), float(input())
# xc, yc, r = float(input()), float(input()), float(input())
# def IsPointInCircle(x, y, xc, yc, r):
#     return ((x - xc) ** 2 + (y - yc) ** 2) ** 0.5 <= r
# print('YES' if IsPointInCircle(x, y, xc, yc, r) else 'NO')

"""Проверьте, принадлежит ли точка данной закрашенной области:
Если точка принадлежит области (область включает границы), выведите слово YES, иначе выведите слово NO. Решение должно
содержать функцию IsPointInArea(x, y), возвращающую True, если точка принадлежит области и False, если не принадлежит.
Основная программа должна считать координаты точки, вызвать функцию IsPointInArea и в зависимости от возвращенного
значения вывести на экран необходимое сообщение. Функция IsPointInArea не должна содержать инструкцию if."""
# x, y = float(input()), float(input()),
# def IsPointInArea(x, y):
#     in_circle_top = ((x + 1) ** 2 + (y - 1) ** 2) ** 0.5 <= 2
#     in_circle_bottom = ((x + 1) ** 2 + (y - 1) ** 2) ** 0.5 < 2
#     top_area = y >= 2 / 3 and -y <= x <= (y - 2) / 2
#     bottom_area = y <= 2 / 3 and (y - 2) / 2 <= x <= -y
#     top = in_circle_top and top_area
#     bottom = bottom_area and not in_circle_bottom
#     return top or bottom
# # y = -x
# # y = 2 + 2x
# #
# # x = -2 /3
# # y = 2 /3
# print('YES' if IsPointInArea(x, y) else 'NO')

"""Дано натуральное число n>1. Проверьте, является ли оно простым. Программа должна вывести слово YES, если число
простое и NO, если число составное. Решение оформите в виде функции IsPrime(n), которая возвращает True для простых
чисел и False для составных чисел. Программа должна иметь сложность O(корень из n): количество действий в программе
должно быть пропорционально квадратному корню из n (иначе говоря, при увеличении входного числа в k раз, время
выполнения программы должно увеличиваться примерно в корень из k раз)."""
# n = int(input())
# def isPrime(n):
#     i = 2
#     while i <= n ** 0.5:
#         if n % i == 0:
#             return False
#         i += 1
#     return True
# print('YES' if isPrime(n) else 'NO')

"""Формализуем задачу. Пусть задается последовательность натуральных чисел, заканчивающаяся нулем. Необходимо развернуть
ее с помощью рекурсии."""
# def rec():
#     n = int(input())
#     if n != 0:
#         rec()
#         print(n)
# rec()

"""Дано действительное положительное число a и целое неотрицательное число n. Вычислите aⁿ, не используя циклы и
стандартную функцию pow, но используя рекуррентное соотношение aⁿ=a⋅aⁿ⁻¹.
Решение оформите в виде функции power(a, n) (которая возвращает aⁿ).
Формат ввода - Вводятся действительное положительное число a и целое неотрицательное число n.
Формат вывода - Выведите ответ на задачу: print(power(a, n))."""
# a, n = float(input()), int(input())
# def power(a, n):
#     if n == 0:
#         return 1
#     elif n == 1:
#         return a
#     return a * power(a, n - 1)
# print(power(a, n))

"""Дано действительное положительное число a и целоe число n. Вычислите aⁿ. Решение оформите в виде функции power(a, n).
Стандартной функцией возведения в степерь пользоваться нельзя.
Формат ввода - Вводится действительное положительное число a и целоe число n.
Формат вывода - Выведите ответ на задачу.
Примечания - Здесь не нужна рекурсия."""
# a, n = float(input()), int(input())
# def power(a, n):
#     s = 1
#     for i in range(abs(n)):
#         if n > 0:
#             s *= a
#         else:
#             s /= a
#     return s
# print(power(a, n))

"""Напишите рекурсивную функцию sum(a, b), возвращающую сумму двух целых неотрицательных чисел. Из всех арифметических
операций допускаются только +1 и -1. Также нельзя использовать циклы.
Формат ввода
Вводятся два удовлетворяющих условию задачи числа. Числа не превышают 900.
Формат вывода
Выведите ответ на задачу."""
# a, b = int(input()), int(input())
# def sum(a, b):
#     if b == 0:
#         return a
#     return 1 + sum(a, b - 1)
# print(sum(a, b))

"""Возводить в степень можно гораздо быстрее, чем за n умножений! Для этого нужно воспользоваться следующими
рекуррентными соотношениями: aⁿ = (a²)ⁿ/² при четном n, aⁿ=a⋅aⁿ⁻¹ при нечетном n. Реализуйте алгоритм быстрого
возведения в степень. Если вы все сделаете правильно,то сложность вашего алгоритма будет O(logn).
Формат ввода -  Вводится действительное число a и целое неотрицательное число n.
Формат вывода - # Выведите ответ на задачу."""
# a, n = float(input()), int(input())
# def power(a, n):
#     if n == 0:
#         return 1
#     if n == 2:
#         return a * a
#     if n % 2 == 1:
#         return a * power(a, n - 1)
#     return a ** (n / 2) * power(a, n / 2)
# print(power(a, n))

"""Для быстрого вычисления наибольшего общего делителя двух чисел используют алгоритм Евклида. Он построен на следующем
соотношении: НОД(a,b)=НОД(b,a % b).
Реализуйте рекурсивный алгоритм Евклида в виде функции gcd(a, b).
Формат ввода - Вводится два целых положительных числа.
Формат вывода - Выведите ответ на задачу."""
# a, b = int(input()), int(input())
# def gcd(a, b):
#     if b == 0:
#         return a
#     return gcd(b, a % b)
# print(gcd(a, b))

"""Даны два натуральных числа n и m.
Сократите дробь (n / m), то есть выведите два других числа p и q таких, что (n / m) = (p / q) и дробь (p / q) —
несократимая.
Решение оформите в виде функции ReduceFraction(n, m), получающая значения n и m и возвращающей кортеж из двух чисел:
return p, q.
Тогда вывод можно будет оформить как print(*ReduceFraction(n, m)).
Формат ввода - Вводятся два натуральных числа.
Формат вывода - Выведите ответ на задачу."""
# n, m = int(input()), int(input())
# def gcd(a, b):
#     if b == 0:
#         return a
#     return gcd(b, a % b)
# def ReduceFraction(n, m):
#     s = gcd(n, m)
#     p = n // s
#     q = m // s
#     return p, q
# print(*ReduceFraction(n, m))


"""Напишите функцию phib(n), которая по данному целому неотрицательному n возвращает n-e число Фибоначчи. В этой задаче
нельзя использовать циклы - используйте рекурсию.
Формат ввода - Вводится удовлетворяющее условию задачи число.
Формат вывода - Выведите ответ на задачу.
Примечание - Обратите внимание на нумерацию чисел, показанную в примерах."""
# n = int(input())
# def phib(n):
#     a, b = 1, 2
#     if n < 3:
#         return 1
#     elif n > 3:
#         a, b = b, phib(n - 1) + phib(n - 2)
#     return b
# print(phib(n))
#
# def fib(n):
#     if n == 1 or n == 2:
#         return 1
#     else:
#         return fib(n - 1) + fib(n - 2)
# print(fib(int(input())))

"""По данным целым числам n и k  (0≤k≤n) вычислите C из n по k. Решение оформите в виде функции C(n, k).
Для решения используйте рекуррентное соотношение:
И равенства:
С(n, 1)=n
C(n, n)=1
Формат ввода - Вводятся удовлетворяющие условию задачи числа n и k.
Формат вывода - Выведите ответ на задачу."""
# def C(n, k):
#     if k == n or k == 0:
#         return 1
#     if k != 1:
#         return C(n - 1, k) + C(n - 1, k - 1)
#     else:
#         return n
# print(C(int(input()), int(input())))
# Через факториал медленно и не эффективно.
# В формуле n! / (k! (n - k)!), если сократить, то получится (n-k+1)(n-k+2)..n/k!
# def С(n, k):
#     if 0 <= k <= n:
#         nn = 1
#         kk = 1
#         for t in xrange(1, min(k, n - k) + 1):
#             nn *= n
#             kk *= t
#             n -= 1
#         return nn // kk
#     else:
#         return 0
# Также можно посмотреть библиотеку itertools:
# combinations('ABCD', 2)  # AB AC AD BC BD CD

"""Дана последовательность чисел, завершающаяся числом 0. Найдите сумму всех этих чисел, не используя цикл.
Формат ввода - Вводится последовательность целых чисел, оканчивающаяся числом 0 (само число 0 в последовательность не
входит, а служит как признак ее окончания).
Формат вывода - Выведите ответ на задачу."""
# def summa():
#     n = int(input())
#     if n == 0:
#         return n
#     return n + summa()
# print(summa())

"""Дана последовательность целых чисел, заканчивающаяся числом 0. Выведите эту последовательность в обратном порядке.
При решении этой задачи нельзя пользоваться массивами и прочими динамическими структурами данных.Рекурсия вам поможет.
Формат ввода -  Вводится последовательность целых чисел, оканчивающаяся числом 0.
Формат вывода -  Выведите ответ на задачу."""
# def summa():
#     n = int(input())
#     if n == 0:
#         return print(n)
#     summa()
#     return print(n)
# summa()

"""Головоломка “Ханойские башни” состоит из трех стержней, пронумерованных числами 1, 2, 3. На стержень 1 надета
пирамидка из n дисков различного диаметра в порядке убывания диаметра (снизу находится самый большой диск, а сверху —
самый маленький). Диски можно перекладывать с одного стержня на другой по одному, при этом диск нельзя класть на диск
меньшего диаметра. Необходимо переложить всю пирамидку со стержня 1 на стержень 3 за минимальное число перекладываний.
Напишите программу, которая решает головоломку; для данного числа дисков n печатает последовательность перекладываний
в формате a b c, где a — номер перекладываемого диска, b — номер стержня с которого снимается данный диск, c — номер
стержня на который надевается данный диск.
Например, строка 1 2 3 означает перемещение диска номер 1 со стержня 2 на стержень 3. В одной строке печатается одна
команда. Диски пронумерованы числами от 1 до n в порядке возрастания диаметров.
Программа должна вывести минимальный (по количеству произведенных операций) способ перекладывания пирамидки из данного
числа дисков.
     Указание: подумайте, как переложить пирамидку из одного диска? Из двух дисков? Из трех дисков? Из четырех дисков?
     Пусть мы научились перекладывать пирамидку из n дисков с произвольного стержня на любой другой, как переложить
     пирамидку из n+1 диска, если можно пользоваться решением для n дисков.
Напишите функцию move (n, x, y), которая печатает последовательность перекладываний дисков для перемещения пирамидки
высоты n со стержня номер x на стержень номер y.
Формат ввода - Вводится натуральное число — количество дисков.
Формат вывода - Выведите ответ на задачу."""
# def move(n, x, y):
#     if n == 1:
#         print('1', x, y)
#     else:
#         tmp = 6 - x - y
#         move(n - 1, x, tmp)
#         print(n, x, y)
#         move(n - 1, tmp, y)
# n = int(input())
# move(n, 1, 3)

"""Теорема Лагранжа утверждает, что любое натуральное число можно представить в виде суммы четырех точных квадратов. По
данному числу n найдите такое представление: напечатайте от 1 до 4 натуральных чисел, квадраты которых дают в сумме
данное число.
Формат ввода
Программа получает на вход одно натуральное число n < 10000.
Формат вывода
Программа должна вывести от 1 до 4 натуральных чисел, квадраты которых дают в сумме данное число."""
# def lagrange_theorem(n, level):
#     if not level:
#         return False
#     number = int(n ** 0.5)
#     if number ** 2 == n:
#         return number
#     while number > 0:
#         if lagrange_theorem(n - number ** 2, level - 1):
#             return input_file"{number} {lagrange_theorem(n - number ** 2, level - 1)}"
#         number -= 1 # уменьшаем число, если не получается в четыре слагаемых
#     return False
# print(lagrange_theorem(int(input()), 4))

"""Напишите программу, которая представляет переданное натуральное число в виде суммы не более чем 7 кубов других
натуральных чисел.
Формат ввода - Входная строка содержит целое число N, которое нужно представить в виде суммы кубов.
Формат вывода - Программа должна вывести любое разложение переданного ей числа в виде суммы не более чем 7 кубов
других натуральных чисел. Если такое разложение невозможно, программа должна вывести число 0."""
# def sum_cube(n, level):
#     if not level:
#         return 0
#     number = int(pow(n, 1 / 3))
#     if number ** 3 == n:
#         return number ** 3
#     while number > 0:
#         if sum_cube(n - number ** 3, level - 1):
#             return input_file"{number ** 3} {sum_cube(n - number ** 3, level - 1)}"
#         number -= 1
#     return 0
# print(sum_cube(int(input()), 7))

"""Напишите программу, которая выбирает из полученной последовательности квадраты целых чисел выводит их в обратном
порядке. Использовать массив для хранения последовательности не разрешается.
Формат ввода
Во входных строках записаны целые числа, по одному в каждой строке. В последней строке записано число 0.
Формат вывода
Программа должна вывести элементы полученной последовательности, которые представляют собой квадраты целых чисел, в
обратном порядке в одну строчку, разделив их пробелами. Если таких нет, программа должна вывести число 0."""
# def squares():
#     number = int(input())
#     if number == 0:
#         return None
#     squares()
#     if number ** 0.5 % 1 == 0:
#         print(number, end=' ')
#         global s
#         s = 0
# s = 1
# squares()
# if s:
#     print(0)
#
# def kvadrat(counter):
#     n = int(input())
#     if n != 0:
#         counter = kvadrat(counter)
#         if (int(n ** 0.5)) ** 2 == n:
#             print(n)
#             return (counter + 1)
#         return counter
#     return 0
# if kvadrat(0) == 0:
#     print(0)

# def _sqonly(some_flag=False):
#     x = int(input())
#     if x != 0:
#         if _sqonly(some_flag):
#             some_flag = True
#         if x ** 0.5 % 1 == 0:
#             print(x, ' ', end='')
#             some_flag = True
#     return some_flag
# if _sqonly() is False:
#     print('0')
