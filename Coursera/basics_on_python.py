# Для подсчета модуля числа в Питоне существует функция abs, которая избавляет от необходимости каждый раз писать
# подсчет модуля вручную.

# В отличие от целых чисел, вещественные числа в языке Питон имеют ограниченную длину.
# Подумаем, как хранить десятичную дробь в памяти. Поскольку вещественных чисел бесконечно много (даже больше, чем
# натуральных), то нам придется ограничить точность. Например, мы можем хранить только несколько первых значащих цифр,
# не храня незначащие нули. Будем отдельно хранить целое число с первыми значащими цифрами и отдельно хранить
# числа 10, на которую нужно умножить это число.
# Например, число 5.972*10**24 (это масса Земли в килограммах) можно сохранить как 5972 (цифры числа, мантисса) и 21
# (на какую степень 10 нужно умножить число, экспонента). С помощью такого представления можно хранить вещественные
# числа любой размерности.
# Примерно так и хранятся числа в памяти компьютера, однако вместо десятичной системы используется двоичные. На
# большинстве аппаратных систем в языке Питон для хранения float используется 64 бита, из которых 1 бит уходит на знак,
# 52 бита - на мантиссу и 11 бит - на экспоненту. Это не совсем правда, но достаточно неплохо описывает реальность.
# 52 бита дают около 15-16 десятичных знаков, которые будут храниться точно. 11 бит на экспоненту также накладывает
# ограничения на размерность хранимых чисел (примерно от -1000 до 1000 степени числа 10).
# Любое вещественное число на языке Питон представимо в виде дроби, где в числителе хранится целое число, а в
# знаменателе находится какая-либо степень двойки. Например, 0.125 представимо как 1/8, а 0.1 как
# 3602879701896397/36028797018963968. Несложно заметить, что эта дробь не равно 0.1, т. е. хранение числа 0.1 точно в
# типе float невозможно, как и многих других "красивых" десятичных дробей.
# В целом будет полезно представлять себе вещественное число X как отрезок [X - epsilon; X + epsilon]. Как же определить
# величину epsilon?
# Для этого нужно понять, что погрешность не является абсолютной, т. е. одинаковой для всех чисел, а является
# относительной. Упрощенно, аппаратную погрешность хранения числа X можно оценить как X*2**(-54).
# Чаще всего в задачах входные данные имеют определенную точность. Рассмотрим на примере: заданы два числа X и Y с
# точностью 6 знаков после точки (значит epsilon=5*10**(-7)) и по модулю не превосходящие 10**9. Оценить абсолютную
# погрешность вычисления X * Y. Рассмотрим худший случай, когда X и Y равны 10**9 и отклонились на максимально возможное
# значение epsilon в одну сторону. Тогда результат вычисления будет выглядеть так:
# (X + epsilon) * (Y + epsilon) = XY + (X + Y) * epsilon + epsilon**2
# Величина epsilon**2 пренебрежимо мала, XY - это правильный ответ, а (X + Y) * epsilon - искомое значение абсолютной
# погрешности. Подставим числа и получим:
# 2 * 10**9 * 5 * 10**(-7) = 10**3                               |X - Y| < epsilon
# Абсолютная погрешность вычисления составила 1000 (одну тысячу). Что довольно неожиданно и грустно.
# Таким образом, становится понятно, что нужно аккуратно вычислять значение погрешности для сравнения вещественных чисел
# print(0.1.as_integer_ratio()) - вывод дроби
# Для записи констант или при вводе-выводе может использоваться как привычное представление в виде десятичной дроби,
# например 123.456, так и "инженерная" запись числа, где мантисса записывается в виде вещественного числа с одной цифрой
# до точки и некоторым количеством цифр после точки, затем следует буква ''e'' (или ''E'') и экспонента. Число 123.456 в
# инженерной записи будет выглядеть как 1.23456e2, что означает, что 1.23456 нужно умножить на 10**2. И мантисса и
# экспонента могут быть отрицательными и записываются в десятичной системе.
# Такая запись чисел может применяться при создании вещественных констант, а также при вводе и выводе. Инженерная запись
# удобна для хранения очень больших или очень маленьких чисел, чтобы не считать количество нулей в начале или конце
# числа.
# Если хочется вывести число не в инженерной записи, а с фиксированным количеством знаков после точки, то следует
# воспользоваться методом format, который имеет массу возможностей. Нам нужен только вывод фиксированного количества
# знаков, поэтому воспользуемся готовым рецептом для вывода 25 знаков после десятичной точки у числа 0.1:
# x = 0.1
# print('{0:.25f}'.format(x))
# Если запустить эту программу, то можно легко убедиться в том, что 0.1 + 0.2 не равно 0.3. Хотя можно было надеятся,
# что несмотря на неточное представление, оно окажется одинаково неточным для всех чисел.
# Поэтому при использовании вещественных чисел нужно следовать нескольким простым правилам:
# 1) Если можно обойтись без использования вещественных чисел - нужно это сделать. Вещественные числа проблемные,
# неточные и медленные.
# 2) Два вещественных числа равны между собой, если они отличаются не более чем на epsilon. Число X меньше числа Y,
# если X < Y - epsilon.
# Код для сравнения двух чисел, заданных с точностью 6 знаков после точки, выглядит так:
# x = float(input())
# y = float(input())
# epsilon = 10 ** -6
# if abs(x - y) < epsilon:
#     print('Equal')
# else:
#     print('Not equal')
# При использовании целых и вещественных чисел в одном выражении вычисления производятся в вещественных числах. Тем не
# менее, иногда возникает необходимость преобразовать вещественное число в целое. Для этого можно использовать несколько
# видов функций округления:
# int - округляет в сторону нуля и отрицательные также в сторону нуля (отбрасывет дробную часть)
# round - округляет до ближайшего целого, если ближайших целых несколько (дробная часть равно 0.5), то к чётному
# floor - округляет в меньшую сторону
# ceil - округляет в большую сторону
# Функции floor и ceil находятся в библиотеке math.
# В библиотеке math также есть функция округления trunc, которая работает аналогично int.

# Вызовы функций из функции
# Функцию подсчета факториала можно использовать для подсчета биномиальных коэффициентов (числа сочетаний). Формула для
# подсчета числа сочетаний выглядит так: n! / (k! * (n - k)!).
# Если бы мы не пользовались функциями, то нам потребовалось бы три раза записать почти одно и то же. С помощью функций
# вычисление выглядит намного проще:
# def factorial(num):
#     fact = 1
#     i = 2
#     while i <= num:
#         fact *= i
#         i += 1
#     return fact
# def binomial(n, k):
#     return factorial(n) // (factorial(k) * factorial(n - k))
# n, k = int(input()), int(input())  # n > k
# print(binomial(n, k))

################################################################################################################
# Перед началом тараканьих бегов всем болельщикам было предложено сделать по две ставки на результаты бегов. Каждая
# ставка имеет вид "Таракан №A придет раньше, чем таракан №B". Организаторы бегов решили выяснить, могут ли тараканы
# прийти в таком порядке, чтобы у каждого болельщика сыграла ровно одна ставка из двух (то есть чтобы ровно одно из двух
# утверждений каждого болельщика оказалось верным). Считается, что никакие два таракана не могут прийти к финишу
# одновременно.
# Формат ввода
# В первой строке входных данных содержатся два разделенных пробелом натуральных числа: число K, не превосходящее 10,
# - количество тараканов и число N, не превосходящее 100, - количество болельщиков. Все тараканы пронумерованы числами
# от 1 до K. Каждая из следующих N строк содержит 4 натуральных числа A, B, C, D, не превосходящих K, разделенных
# пробелами. Они соответствуют ставкам болельщика "Таракан №A придет раньше, чем таракан №B" и "Таракан №C придет
# раньше, чем таракан №D".
# Формат вывода
# Если завершить бега так, чтобы у каждого из болельщиков сыграла ровно одна из двух ставок, можно, то следует вывести
# номера тараканов в том порядке, в котором они окажутся в итоговой таблице результатов (сначала номер таракана,
# пришедшего первым, затем номер таракана, пришедшего вторым и т. д.) в одну строку через пробел. Если таких вариантов
# несколько, выведите любой из них. Если требуемого результата добиться нельзя, выведите одно число 0.
# Тест 1
# Входные данные:
# 3 2
# 2 1 2 3
# 1 2 3 2
# Вывод программы:
# 3 2 1
#
# Тест 2
# Входные данные:
# 3 4
# 1 2 1 3
# 1 2 3 1
# 1 2 2 3
# 1 2 3 2
# Вывод программы:
# 0
# import itertools
# import operator
#
# print(next(map(lambda a:
#                ' '.join(map(str, a[0])),
#                filter(lambda a: all(map(lambda b: operator.xor(
#                    *map(lambda c: c in itertools.combinations(a[0], 2), b, )),
#                                         a[1])), (
#                           lambda a, b: zip(itertools.permutations(a),
#                                            itertools.repeat(b)))(
#                    *(lambda k, n: (range(1, k + 1),
#                                    tuple(map(lambda i: (i[:2], i[2:]),
#                                              map(lambda _: tuple(
#                                                  map(int, input().split())),
#                                                  range(n)))))
#                      )(*map(int, input().split()))))), 0))

# from itertools import permutations
# from sys import stdin
# from operator import xor
#
# print(
#     *next(
#         map(
#             lambda d:
#             next(
#                 filter(
#                     lambda y:
#                     all(
#                         map(
#                             lambda x:
#                             xor(y.index(x[0]) < y.index(x[1]), y.index(x[2]) < y.index(x[3])),
#                             d[-1])
#                     ),
#                     d[:-1]
#                 ),
#                 [0, ]
#             ),
#
#             map(
#                 lambda j: [
#                     *permutations(range(j, 0, -1), j),
#                     list(map(lambda z: tuple(map(int, z.split())),
#                              stdin.readlines()))
#                 ],
#                 map(int, input().split())
#             )
#
#         ),
#         [0, ]
#     )
# )
# Т.к. во входных данных через map(int, input().split()) идёт и K и N, то у нас будет считаться два permutations. Чтобы
# не использовать второй мы используем next. Следовательно у Вас ошибка в последовательности. next на 9-й строке должен
# быть перед map на 7-й, а lambda d это filter.
#
# И посмотрите на то, что выдаёт map на 23-й строке (кстати не пойму зачем * на 25-й строке). Вы неправильно берёте из
# неё данные.
#
# И по поводу xor, не факт что грейдер импортирует библиотеку operator. Есть встроенный логический оператор, который
# подходит для наших нужд - ^. Используется как обычно: a ^ b.
#####################9###############################################################################################

