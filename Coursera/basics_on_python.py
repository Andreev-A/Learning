# Нарисовать пингвинов
# number = int(input())
# print('   _~_    ' * number)
# print('  (o o)   ' * number)
# print(' /  V  \\  ' * number)
# print('/(  _  )\\ ' * number)
# print('  ^^ ^^   ' * number)

# Дано натуральное число. Выведите его последнюю цифру
# num = int(input())
# print(num % 10)

# Дано положительное двузначное число. Найдите число десятков в нем.
# num = int(input())
# print(num // 10)

# Дано натуральное число. Найдите цифру, стоящую в разряде десятков в его десятичной записи (вторую справа цифру или 0,
# если число меньше 10).
# num = int(input())
# print(num % 100 // 10)

# Дано трехзначное число. Найдите сумму его цифр.
# num = int(input())
# a = num // 100
# b = num % 100 // 10
# c = num % 10
# print(a, '+', b, '+', c, '=', a + b + c)

# Вводится число N, необходимо отрезать от него K последних цифр.
# n_test = int(input())
# k = int(input())
# print(n_test // 10**k)

# Дано целое число N. Выведите следующее за ним четное число.
# num = int(input())
# print((num + 2) // 2 * 2)  # (num + b - 1) // b или (num - 1) // b + 1 - округление вверх

# В нашей задаче наименьшей единицей являются копейки, поэтому все цены следует перевести в них, затем сложить их, а
# затем перевести результат обратно в рубли и копейки. Код решения будет выглядеть так:
# a = int(input())
# b = int(input())
# c = int(input())
# d = int(input())
# cost1 = a * 100 + b
# cost2 = c * 100 + d
# totalCost = cost1 + cost2
# print(totalCost // 100, totalCost % 100)

# Заданное число N записали 100 раз подряд и затем возвели в квадрат. Что получилось?
# num = input()
# print(int(num*100)**2)

# Электронные часы
# time = int(input())
# h = (time % (24 * 3600)) // 3600
# m_1 = str((time % (24 * 3600)) % 3600 // 60 // 10)
# m_2 = str((time % (24 * 3600)) % 3600 // 60 % 10)
# s_1 = str((time % (24 * 3600)) % 60 // 10)
# s_2 = str((time % (24 * 3600)) % 60 % 10)
# print(h, (m_1 + m_2), (s_1 + s_2), sep=':')

# Улитка ползет по вертикальному шесту высотой H метров, поднимаясь за день на A метров, а за ночь спускаясь на B
# метров. На какой день улитка доползет до вершины шеста?
# h = int(input())  # 30  10
# a = int(input())  # 5  3
# b = int(input())  # 2  2
# print((h - 2 * b + a - 1) // (a - b))  # (h - b) + (a - b) - 1

# Дано четырехзначное число. Определите, является ли его десятичная запись симметричной. Если число симметричное, то
# выведите 1, иначе выведите любое другое целое число. Число может иметь меньше четырех знаков, тогда нужно считать,
# что его десятичная запись дополняется слева нулями.
# num = int(input())
# digit_1 = num % 10000 // 1000 * 10 + num % 1000 // 100
# digit_2 = num % 10 * 10 + num % 100 // 10
# print(1 - (digit_1 - digit_2))

# Напишите программу, которая считывает два целых числа A и B и выводит наибольшее значение из них.
# Числа —  целые от 1 до 1000. Зная, что 0 в степени 0 даёт 1.
# a = int(input())
# b = int(input())
# print(a * 0 ** ((b - 1) // a) + b * 0 ** (a // b))

# В этой задаче необходимо проверить, делится ли число A на число B нацело. Использовать можно только арифметические
# операции, использование любых видов ветвлений, функций и т.п. запрещено. Выведите "YES", если A кратно B и "NO" в
# противном случае.
# a = int(input())
# b = int(input())
# c = 0 ** (a % b)
# d = 1 - c
# print('Y' * c, 'E' * c, 'S' * c, 'N' * d, 'O' * d, sep='')

# Для подсчета модуля числа в Питоне существует функция abs, которая избавляет от необходимости каждый раз писать
# подсчет модуля вручную.

# Дано натуральное число. Требуется определить, является ли год с данным номером високосным. Если год является
# високосным, то выведите YES, иначе выведите NO. Напомним, что в соответствии с григорианским календарем, год является
# високосным, если его номер кратен 4, но не кратен 100, или же если он кратен 400.
# year = int(input())
# if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:
#     print('YES')
# else:
#     print('NO')

# Шахматный король ходит по горизонтали, вертикали и диагонали, но только на 1 клетку. Даны две различные клетки
# шахматной доски, определите, может ли король попасть с первой клетки на вторую одним ходом.
# col_1 = int(input())
# str_1 = int(input())
# col_2 = int(input())
# str_2 = int(input())
# step_col = abs(col_1 - col_2)
# step_str = abs(str_1 - str_2)
# if (step_col == 1 or step_str == 1) and (step_col < 2 and step_str < 2):
#     print('YES')
# else:
#     print('NO')

# В доме несколько подъездов. В каждом подъезде одинаковое количество квартир. Квартиры нумеруются подряд, начиная с
# единицы. Может ли в некотором подъезде первая квартира иметь номер x, а последняя – номер y?
# x = int(input())
# y = int(input())
# if not (x - 1) % (y - x + 1):
#     print('YES')
# else:
#     print('NO')

# Заданы две клетки шахматной доски. Если они покрашены в один цвет, то выведите слово YES, если в разные цвета – то NO.
# x_1 = int(input())
# y_1 = int(input())
# x_2 = int(input())
# y_2 = int(input())
# step_x_0 = abs(x_1 - x_2) % 2
# step_y_0 = abs(y_1 - y_2) % 2
# step_x_1 = abs(x_1 - x_2 + 1) % 2
# step_y_1 = abs(y_1 - y_2 + 1) % 2
# if (step_x_0 == 0 and step_y_0 == 0) or (step_x_1 == 0 and step_y_1 == 0):
#     print('YES')
# else:
#     print('NO')

# Шоколадка имеет вид прямоугольника, разделенного на n_test×m долек. Шоколадку можно один раз разломить по прямой на две
# части. Определите, можно ли таким образом отломить от шоколадки часть, состоящую ровно из k долек.
# n_test = int(input())
# m = int(input())
# k = int(input())
# if n_test * m > k and (k % n_test == 0 or k % m == 0):
#     print('YES')
# else:
#     print('NO')

# Для данного числа n_test<100 закончите фразу “На лугу пасется...” одним из возможных продолжений: “n_test коров”, “n_test корова”,
# “n_test коровы”, правильно склоняя слово “корова”. Программа должна вывести введенное число n_test и одно из слов: korov,
# korova или korovy. Между числом и словом должен стоять ровно один пробел.
# n_test = int(input())
# if 0 <= n_test <= 100:
#     if n_test % 10 == 1 and n_test % 100 != 11:
#         print(n_test, 'korova')
#     elif 2 <= n_test % 10 <= 4 and not 12 <= n_test % 100 <= 14:
#         print(n_test, 'korovy')
#     else:
#         print(n_test, 'korov')

# На доске стоит белая шашка. Требуется определить, может ли она попасть в заданную клетку, делая ходы по правилам и не
# пользуясь ходами дамки (т. е. не используя возможность перемещаться назад после превращения в дамку). Белые шашки
# могут ходить по клеткам одного цвета по диагонали вверх-влево или вверх-вправо. Ходов может быть несколько!
# col_1 = int(input())
# str_1 = int(input())
# col_2 = int(input())
# str_2 = int(input())
# step_col_0 = abs(col_1 - col_2) % 2
# step_str_0 = abs(str_1 - str_2) % 2
# step_col = abs(col_1 - col_2 + 1) % 2
# step_str = abs(str_1 - str_2 + 1) % 2
# if (step_col_0 == 0 and step_str_0 == 0) or (step_col == 0 and step_str == 0):
#     if col_2 - col_1 >= 0 and str_2 - str_1 >= 1 and col_2 - col_1 <= str_2 - str_1:
#         print('YES')
#     else:
#         print('NO')
# else:
#     print('NO')

# Даны три стороны треугольника a,b,c. Определите тип треугольника с заданными сторонами. Выведите одно из четырех слов:
# rectangular для прямоугольного треугольника, acute для остроугольного треугольника, obtuse для тупоугольного
# треугольника или impossible, если треугольника с такими сторонами не существует (считаем, что вырожденный треугольник
# тоже невозможен).
# a, b, c = int(input()), int(input()), int(input())
# if c < a:
#     a, c = c, a
# if c < b:
#     b, c = c, b
# if c >= a + b:
#     print('impossible')
# elif c ** 2 == a ** 2 + b ** 2:
#     print('rectangular')
# elif c ** 2 < a ** 2 + b ** 2:
#     print('acute')
# elif c ** 2 > a ** 2 + b ** 2:
#     print('obtuse')

# Даны три целых числа A, B, C. Определить, есть ли среди них хотя бы одно четное и хотя бы одно нечетное.
# a, b, c = int(input()), int(input()), int(input())
# if (a % 2 or b % 2 or c % 2) and ((a + 1) % 2 or (b + 1) % 2 or (c + 1) % 2):
#     print('YES')
# else:
#     print('NO')

# Даны три целых числа. Определите, сколько среди них совпадающих. Программа должна вывести одно из чисел: 3 (если все
# совпадают), 2 (если два совпадает) или 0 (если все числа различны).
# a, b, c = int(input()), int(input()), int(input())
# if a == b == c:
#     print('3')
# elif a == b or b == c or c == a:
#     print('2')
# else:
#     print('0')

# За многие годы заточения узник замка Иф проделал в стене прямоугольное отверстие размером D×E. Замок Иф сложен из
# кирпичей, размером A×B×C. Определите, сможет ли узник выбрасывать кирпичи в море через это отверстие (очевидно,
# стороны кирпича должны быть параллельны сторонам отверстия).
# a, b, c = int(input()), int(input()), int(input())
# d, e = int(input()), int(input())
# if c < a:
#     a, c = c, a
# if c < b:
#     b, c = c, b
# if (d >= a and e >= b) or (d >= b and e >= a):
#     print('YES')
# else:
#     print('NO')

# Есть две коробки, первая размером A₁×B₁×C₁, вторая размером A₂×B₂×C₂. Определите, можно ли разместить одну из этих
# коробок внутри другой, при условии, что поворачивать коробки можно только на 90 градусов вокруг ребер.
# Программа должна вывести одну из следующих строчек:
# Boxes are equal, если коробки одинаковые,
# The first box is smaller than the second one, если первая коробка может быть положена во вторую,
# The first box is larger than the second one, если вторая коробка может быть положена в первую,
# Boxes are incomparable, во всех остальных случаях.
# a_1, b_1, c_1 = int(input()), int(input()), int(input())
# a_2, b_2, c_2 = int(input()), int(input()), int(input())
# if c_1 < a_1:
#     a_1, c_1 = c_1, a_1
# if c_1 < b_1:
#     b_1, c_1 = c_1, b_1
# if b_1 < a_1:
#     a_1, b_1 = b_1, a_1
# if c_2 < a_2:
#     a_2, c_2 = c_2, a_2
# if c_2 < b_2:
#     b_2, c_2 = c_2, b_2
# if b_2 < a_2:
#     a_2, b_2 = b_2, a_2
# if a_1 == a_2 and b_1 == b_2 and c_1 == c_2:
#     print('Boxes are equal')
# elif a_1 <= a_2 and b_1 <= b_2 and c_1 <= c_2:
#     print('The first box is smaller than the second one')
# elif a_1 >= a_2 and b_1 >= b_2 and c_1 >= c_2:
#     print('The first box is larger than the second one')
# else:
#     print('Boxes are incomparable')

# На склад, который имеет форму прямоугольного параллелепипеда, привезли ноутбуки, упакованные в коробки. Каждая
# коробка также имеет форму прямоугольного параллелепипеда. По правилам хранения коробки с ноутбуками должны быть
# размещены на складе с выполнением следующих двух условий:
# Стороны коробок должны быть параллельны сторонам склада.
# Коробку при помещении на склад разрешается расположить где угодно (с выполнением предыдущего условия), в том числе на
# другой коробке, но все коробки должны быть ориентированы одинаково (т.е. нельзя одну коробку расположить “стоя”, а
# другую —“лежа”)
# Напишите программу, которая по размерам склада и размерам коробки с ноутбуком определит максимальное количество
# ноутбуков, которое может быть размещено на складе.
# a, b, c = int(input()), int(input()), int(input())
# x, y, z = int(input()), int(input()), int(input())
# version_1 = (a // x) * (b // y) * (c // z)
# version_2 = (a // x) * (c // y) * (b // z)
# version_3 = (b // x) * (c // y) * (a // z)
# version_4 = (b // x) * (a // y) * (c // z)
# version_5 = (c // x) * (a // y) * (b // z)
# version_6 = (c // x) * (b // y) * (a // z)
# if version_1 <= version_2:
#     version_1, version_2 = version_2, version_1
# if version_1 <= version_3:
#     version_1, version_3 = version_3, version_1
# if version_1 <= version_4:
#     version_1, version_4 = version_4, version_1
# if version_1 <= version_5:
#     version_1, version_5 = version_5, version_1
# if version_1 <= version_6:
#     version_1, version_6 = version_6, version_1
# print(version_1)

# В кафе мороженое продают по три шарика и по пять шариков. Можно ли купить ровно k шариков мороженого?
# k=3n
# k=3n+1=3(n_test−3)+10
# k=3n−1=3(n_test−2)+5
# Эта задача очень старая и детская, детям ее объясняют так:
# вот от 8 до 10 можно сделать - можно, а потом добавляем по 3 значит от 11 до 13 тоже можно и т.д.
# Короче нужно понять, что если три последовательных числа получились, то все после них тоже получатся
# Добавлю, что множество {3x+5y∣x,y=0,1,2,…} является числовой полугруппой с порождающими 3 и 5. Дополнение к числовой
# полугруппе конечно. Максимальное число, не входящее в полугруппу, называется числом Фробениуса. Оно равно (a−1)(b−1)−1
# в случае двух порождающих a и b  (в данном случае (3-1)(5-1)-1 = 7). Мощность дополнения к полугруппе в случае двух
# образующих есть (a−1)(b−1)/2 (в данном случае (3-1)(5-1)/2 = 4).
# k = int(input())
# if k > 2 and k != 4 and k != 7:
#     print('YES')
# else:
#     print('NO')

# Решить в целых числах уравнение: (ax+b) / (cx+d) =0
# Формат ввода - Вводятся 4 числа: a,b,c,d; c и d не равны нулю одновременно.
# Формат вывода - Необходимо вывести все решения, если их число конечно, “NO” (без кавычек), если решений нет, и “INF”
# (без кавычек), если решений бесконечно много.
#  (ax + b ) : ( cx + d ) = 0
# Сводим уравнение к системе:
# { ax + b = 0
# { cx + d ≠ 0
# { ax = -b
# { cx ≠ -d
# Можно учесть все случаи, используя больше 16 условий, но я предпочту более оптимальный вариант, так как знаю как
# зависит количество корней линейного уравнения от коэффициентов.
# Программа на паскале:
# var a, b, c, d: real;
# begin
#   read(a, b, c, d);
#   if (c = 0) and (d = 0) then writeln('NO')
#   else if (a = 0) and (b = 0) then writeln('INF')
#   else if a = 0 then writeln('NO')
#   else if c = 0 then writeln(-b/a)
#   else if b/a = d/c then writeln('NO')
#   else writeln(-b/a)
# end.
# a = int(input())
# b = int(input())
# c = int(input())
# d = int(input())
# if a == 0 and b == 0:
#     print('INF')
# elif a == 0 or b * c == a * d:
#     print('NO')
# elif c == 0 or b % a == 0:
#     x = -b // a
#     print(x)
# else:
#     print('NO')

# На сковородку одновременно можно положить k котлет. Каждую котлету нужно с каждой стороны обжаривать m минут
# непрерывно. За какое наименьшее время удастся поджарить с обеих сторон n_test котлет?
# Вариант: мест на сковороде 2, время жарки 1, пожарить 3 котлеты. Верный ответ 3, а не 4. Давайте пронумеруем котлеты
# 1,2,3. В первый заход Вы жарите котлеты 1 и 2, во второй - вторую сторону котлеты 2 и котлету 3. В третий -
# дожариваете 1 и 3.
# k, m, n_test = int(input()), int(input()), int(input())
# if n_test <= k:
#     print(2 * m)
# elif (n_test * 2) % k:
#     print(((n_test * 2) // k + 1) * m)
# else:
#     print((n_test * 2) // k * m)

# Вдоль прямой выложены три спички. Необходимо переложить одну из них так, чтобы при поджигании любой спички сгорали все
# три. Чтобы огонь переходил с одной спички на другую, необходимо чтобы эти спички соприкасались (хотя бы концами).
# Требуется написать программу, определяющую, какую из трех спичек необходимо переместить.
# Формат ввода - Вводятся шесть целых чисел : l₁, r₁, l₂, r₂, l₃, r₃ – координаты первой, второй и третьей спичек
# соответственно(0≤lᵢ<rᵢ≤100). Каждая спичка описывается координатами левого и правого концов по горизонтальной оси OX.
# Формат вывода - Выведите номер искомой спички. Если возможных ответов несколько, то выведите наименьший из них
# (наименьший по номеру спички). В случае, когда нет необходимости перемещать какую-либо спичку, выведите 0. Если же
# требуемого результата достигнуть невозможно, то выведите -1.
# l1, r1 = int(input()), int(input())
# l2, r2 = int(input()), int(input())
# l3, r3 = int(input()), int(input())
# # 1 ⋂ 2 ⋂ 3
# # 1 ⋂ 3 ⋂ 2
# # 2 ⋂ 1 ⋂ 3
# # 2 ⋂ 3 ⋂ 1
# # 3 ⋂ 2 ⋂ 1
# # 3 ⋂ 1 ⋂ 2
# # if 0 <= l1 < r1 <= 100 and 0 <= l2 < r2 <= 100 and 0 <= l3 < r3 <= 100:
# if (l1 <= r2 and l2 <= r1 and l2 <= r3 and l3 <= r2) \
#         or (l1 <= r3 and l3 <= r1 and l3 <= r2 and l2 <= r3) \
#         or (l2 <= r1 and l1 <= r2 and l1 <= r3 and l3 <= r1) \
#         or (l2 <= r3 and l3 <= r2 and l3 <= r1 and l1 <= r3) \
#         or (l3 <= r2 and l2 <= r3 and l2 <= r1 and l1 <= r2) \
#         or (l3 <= r1 and l1 <= r3 and l1 <= r2 and l2 <= r1):
#     print(0)
# else:
#     len_1 = r1 - l1
#     len_2 = r2 - l2
#     len_3 = r3 - l3
#     # между 2 и 3 подвинуть 1
#     # между 3 и 2 подвинуть 1
#     # 2 ⋂ 3 к ним подвинуть 1
#     if (l3 > r2 and len_1 >= l3 - r2) \
#             or (l2 > r3 and len_1 >= l2 - r3) \
#             or (l2 <= r3 and l3 <= r2):
#         print(1)
#     elif (l3 > r1 and len_2 >= l3 - r1) \
#             or (l1 > r3 and len_2 >= l1 - r3) \
#             or (l1 <= r3 and l3 <= r1):
#         print(2)
#     elif (l1 > r2 and len_3 >= l1 - r2) \
#             or (l2 > r1 and len_3 >= l2 - r1) \
#             or (l1 <= r2 and l2 <= r1):
#         print(3)
#     else:
#         print(-1)
# # else:
# #     print(-1)

# В одну транспортную компанию поступил заказ на перевозку двух ящиков из одного города в другой. Для перевозки ящики
# решено было упаковать в специальный контейнер. Ящики и контейнер имеют вид прямоугольных параллелепипедов. Длина,
# ширина и высота первого ящика  —  l₁,w₁ и h₁, соответствующие размеры второго ящика – l₂,w₂ и h₂. Контейнер имеет
# длину, ширину и высоту lc,wc и hc. Поскольку ящики содержат хрупкое оборудование, после упаковки в контейнер каждый
# из них должен остаться в строго вертикальном положении. Таким образом, ящики можно разместить рядом или один на другом
# Для надежного закрепления в контейнере стороны ящиков должны быть параллельны его сторонам. Иначе говоря, если исходно
# ящики были расположены так, что все их стороны параллельны соответствующим сторонам контейнера, то каждый из них
# разрешается перемещать и поворачивать относительно вертикальной оси на угол, кратный 90 градусам (относительно
# горизонтальной оси ни контейнер, ни ящики поворачивать нельзя).
# Разумеется, после упаковки оба ящика должны полностью находиться внутри контейнера и не должны пересекаться.
# Выясните, можно ли поместить ящики в контейнер с соблюдением указанных условий.
# l1, w1, h1 = int(input()), int(input()), int(input())
# l2, w2, h2 = int(input()), int(input()), int(input())
# lc, wc, hc = int(input()), int(input()), int(input())
# my_input = 'NO'
# if h1 <= hc and h2 <= hc:
#     if (l1 + l2 <= lc and (w1 <= wc and w2 <= wc)) or (
#             w1 + w2 <= lc and (l1 <= wc and l2 <= wc)) or (
#             l1 + l2 <= wc and (w1 <= lc and w2 <= lc)) or (
#             w1 + w2 <= wc and (l1 <= lc and l2 <= lc)) or (
#             l1 + w2 <= lc and (w1 <= wc and l2 <= wc)) or (
#             l2 + w1 <= lc and (w2 <= wc and l1 <= wc)) or (
#             l1 + w2 <= wc and (w1 <= lc and l2 <= lc)) or (
#             l2 + w1 <= wc and (w2 <= lc and l1 <= lc)):
#         my_input = 'YES'
# if h1 + h2 <= hc:
#     if ((l1 <= lc and l2 <= lc) and (w1 <= wc and w2 <= wc)) or (
#             (w1 <= lc and w2 <= lc) and (l1 <= wc and l2 <= wc)) or (
#             (l1 <= wc and l2 <= wc) and (w1 <= lc and w2 <= lc)) or (
#             (w1 <= wc and w2 <= wc) and (l1 <= lc and l2 <= lc)) or (
#             (l1 <= lc and w2 <= lc) and (w1 <= wc and l2 <= wc)) or (
#             (l2 <= lc and w1 <= lc) and (w2 <= wc and l1 <= wc)) or (
#             (l1 <= wc and w2 <= wc) and (w1 <= lc and l2 <= lc)) or (
#             (l2 <= wc and w1 <= wc) and (w2 <= lc and l1 <= lc)):
#         my_input = 'YES'
# print(my_input)

# # Транспортная компания
# al, aw, ah, bl, bw, bh, cl, cw, ch = (int(input()) for _ in 'контейнер')
# q = 'NO'
# if al > aw:
#     al, aw = aw, al
# if bl > bw:
#     bl, bw = bw, bl
# if cl > cw:
#     cl, cw = cw, cl
# # Ни один ящик не должен превышать контейнер по по размерам
# if ah > ch or bh > ch or al > cl or bl > cl or aw > cw or bw > cw:
#     pass
# elif al + bl > cl and aw + bw > cw and ah + bh > ch:
#     pass  # Ящики не влезают ни по длине, ни по ширине, ни друг на дружке
# else:  # Все остальные случаи работают
#     q = 'YES'
# print(q)

# По данному натуральному числу N выведите такое наименьшее целое число k, что 2ᵏ≥N.
# Операцией возведения в степень пользоваться нельзя!
# n_test = int(input())
# i, degree = 1, 0
# while n_test >= i:
#     if n_test != i:
#         degree += 1
#     i *= 2
# print(degree)

# В первый день спортсмен пробежал X километров, а затем он каждый день увеличивал пробег на 10% от предыдущего значения
# (для решения задачи разрешается использовать числа с запятой, которые в Питоне пишутся через точку).
# По данному числу X определите номер дня, на который пробег спортсмена составит не менее Y километров.
# x = int(input())
# y = int(input())
# day_number = 1
# while y > x:
#     day_number += 1
#     x = x + x * 0.1
# print(day_number)

# Последовательность состоит из натуральных чисел и завершается числом 0. Определите значение второго по величине
# элемента в этой последовательности, то есть элемента, который будет наибольшим, если из последовательности удалить
# одно вхождение наибольшего элемента.
# n_test = int(input())
# max_1 = min_2 = n_test
# n_test = int(input())
# if n_test > max_1:
#     min_2, max_1 = max_1, n_test
# else:
#     min_2 = n_test
# while n_test != 0:
#     n_test = int(input())
#     if n_test > max_1 and n_test:
#         min_2, max_1 = max_1, n_test
#     elif n_test > min_2:
#         min_2 = n_test
# print(min_2)

# Последовательность состоит из натуральных чисел и завершается числом 0. Определите количество элементов этой
# последовательности, которые равны ее наибольшему элементу.
# n_test, max_n, count = 1, 0, 0
# while n_test != 0:
#     n_test = int(input())
#     if n_test == max_n and n_test:
#         count += 1
#     if n_test > max_n and n_test:
#         max_n = n_test
#         count = 1
# print(count)

# Последовательность Фибоначчи определяется так:
# F[0] = 0, F[1] = 1, ..., F[n_test] = F[n_test-1] + F[n_test-2].
# По данному числу n_test определите n_test-е число Фибоначчи F[n_test].
# n_test = int(input())
# i, f_0, f_1 = 2, 0, 1
# if n_test == f_0:
#     print(f_0)
# elif n_test == f_1:
#     print(f_1)
# else:
#     while n_test >= i:
#         f_n = f_0 + f_1
#         f_0, f_1 = f_1, f_n
#         i += 1
#     print(f_n)

# Последовательность Фибоначчи определяется так:
# F[0]=0, F[1]=1, ..., F[n_test]=F[n_test-1]+F[n_test-2].
# Дано натуральное число A. Определите, каким по счету числом Фибоначчи оно является, то есть выведите такое число n_test,
# что F[n_test]=A.
# Если А не является числом Фибоначчи, выведите число -1.
# n_test = int(input())
# i, f_0, f_1, f_n = 1, 0, 1, 0
# if n_test == f_0:
#     print(f_0)
# elif n_test == f_1:
#     print(f_1)
# else:
#     while n_test > f_n:
#         f_n = f_0 + f_1
#         f_0, f_1 = f_1, f_n
#         i += 1
#     if n_test == f_n:
#         print(i)
#     else:
#         print(-1)

# Исполнитель “Раздвоитель” преобразует натуральные числа. У него есть две команды: “Вычесть 1” и “Разделить на 2”,
# первая команда уменьшает число на 1, вторая команда уменьшает число в два раза, если оно чётное,иначе происходит
# ошибка. Дано два натуральных числа A и B (A>B). Напишите алгоритм для Раздвоителя, который преобразует число A в
# число B и при этом содержит минимальное число команд. Команды алгоритма нужно выводить по одной в строке, первая
# команда обозначается, как -1, вторая команда как :2.
# a, b = int(input()), int(input())
# while a > b:
#     if a % 2 or a // 2 < b:
#         a -= 1
#         print("-1")
#     elif a // 2 >= b:
#         a //= 2
#         print(':2')

# Переставьте цифры числа в обратном порядке.
# Формат ввода - Задано единственное число N
# Формат вывода - Необходимо вывести цифры данного числа в обратном порядке.
# n_test = int(input())
# if n_test < 10:
#     print(n_test)
# while n_test // 10:
#     s = n_test % 10
#     print(s, end='')
#     n_test //= 10
#     if not (n_test // 10):
#         print(n_test)

# Назовем число палиндромом, если оно не меняется при перестановке его цифр в обратном порядке. Напишите программу,
# которая по заданному числу K выводит количество натуральных палиндромов, не превосходящих K.
# Формат ввода - Задано единственное число K (1≤K≤100000).
# Формат вывода - Необходимо вывести количество натуральных палиндромов, не превосходящих K.
# n = int(input())
# n_test, count = 10, 0
# if n < 10:
#     count = n
# else:
#     count = 9
# while n >= n_test:
#     test = n_test
#     test_rev = ''
#     while test // 10:
#         s = str(test % 10)
#         test_rev += s
#         test //= 10
#         if not (test // 10):
#             test_rev += str(test)
#     if str(n_test) == test_rev:
#         count += 1
#     n_test += 1
# print(count)

# Дана последовательность натуральных чисел, завершающаяся числом 0. Определите, какое наибольшее число подряд идущих
# элементов этой последовательности равны друг другу.
# n = int(input())
# n_prev, len_max, len_curr = n, 1, 1
# while n != 0:
#     n = int(input())
#     if n == n_prev:
#         len_curr += 1
#     elif n != n_prev:
#         if len_max < len_curr:
#             len_max = len_curr
#         len_curr = 1
#         n_prev = n
# print(len_max)

# Дана последовательность натуральных чисел, завершающаяся числом 0. Определите наибольшую длину монотонного фрагмента
# последовательности (то есть такого фрагмента, где все элементы либо больше предыдущего, либо меньше).
# Формат ввода - Вводится последовательность целых чисел, оканчивающаяся числом 0 (само число 0 в последовательность не
# входит, а служит как признак ее окончания).
# Формат вывода - Выведите ответ на задачу.
# n = int(input())
# n_prev, len_max, len_curr, flag = n, 1, 1, 0
# while n != 0:
#     n = int(input())
#     if n > n_prev and n:
#         if flag == 2:
#             if len_max < len_curr:
#                 len_max = len_curr
#             len_curr = 1
#         len_curr += 1
#         n_prev, flag = n, 1
#     elif n < n_prev and n:
#         if flag == 1:
#             if len_max < len_curr:
#                 len_max = len_curr
#             len_curr = 1
#         len_curr += 1
#         n_prev, flag = n, 2
#     elif n == n_prev or n == 0:
#         if len_max < len_curr:
#             len_max = len_curr
#         len_curr = 1
#         flag = 0
# print(len_max)

# Определите наименьшее расстояние между двумя локальными максимумами последовательности натуральных чисел,
# завершающейся числом 0. Локальным максимумом называется такое число в последовательности, которое больше своих
# соседей. Если в последовательности нет двух локальных максимумов, выведите число 0. Начальное и конечное значение при
# этом локальными максимумами не считаются.
# Формат ввода - Вводится последовательность целых чисел, оканчивающаяся числом 0 (само число 0 в последовательность не
# входит, а служит как признак ее окончания).
# Формат вывода - Выведите ответ на задачу.
# n_1 = int(input())
# n_2 = int(input())
# n_3, len_min, len_curr = 1, 0, 0
# start = False
# while n_3 != 0:
#     n_3 = int(input())
#     if n_2 > n_1 and n_2 > n_3 and n_3:
#         start = True
#         if len_min > len_curr or len_min == 0 and len_curr != 0:
#             len_min = len_curr
#         len_curr = 0
#     n_1, n_2 = n_2, n_3
#     if start:
#         len_curr += 1
# print(len_min)

# В отличие от целых чисел, вещественные числа в языке Питон имеют ограниченную длину.
# Подумаем, как хранить десятичную дробь в памяти. Поскольку вещественных чисел бесконечно много (даже больше, чем
# натуральных), то нам придется ограничить точность. Например, мы можем хранить только несколько первых значащих цифр,
# не храня незначащие нули. Будем отдельно хранить целое число с первыми значащими цифрами и отдельно хранить
# числа 10, на которую нужно умножить это число.
# Например, число 5.972*10**24 (это масса Земли в килограммах) можно сохранить как 5972 (цифры числа, мантисса) и 21
# (на какую степень 10 нужно умножить число, экспонента). С помощью такого представления можно хранить вещественные
# числа любой размерности.
# Примерно так и хранятся числа в памяти компьютера, однако вместо десятичной системы используется двоичные. На
# большинстве аппаратных систем в языке Питон для хранения float используется 64 бита, из которых 1 бит уходит на знак,
# 52 бита - на мантиссу и 11 бит - на экспоненту. Это не совсем правда, но достаточно неплохо описывает реальность.
# 52 бита дают около 15-16 десятичных знаков, которые будут храниться точно. 11 бит на экспоненту также накладывает
# ограничения на размерность хранимых чисел (примерно от -1000 до 1000 степени числа 10).
# Любое вещественное число на языке Питон представимо в виде дроби, где в числителе хранится целое число, а в
# знаменателе находится какая-либо степень двойки. Например, 0.125 представимо как 1/8, а 0.1 как
# 3602879701896397/36028797018963968. Несложно заметить, что эта дробь не равно 0.1, т. е. хранение числа 0.1 точно в
# типе float невозможно, как и многих других "красивых" десятичных дробей.
# В целом будет полезно представлять себе вещественное число X как отрезок [X - epsilon; X + epsilon]. Как же определить
# величину epsilon?
# Для этого нужно понять, что погрешность не является абсолютной, т. е. одинаковой для всех чисел, а является
# относительной. Упрощенно, аппаратную погрешность хранения числа X можно оценить как X*2**(-54).
# Чаще всего в задачах входные данные имеют определенную точность. Рассмотрим на примере: заданы два числа X и Y с
# точностью 6 знаков после точки (значит epsilon=5*10**(-7)) и по модулю не превосходящие 10**9. Оценить абсолютную
# погрешность вычисления X * Y. Рассмотрим худший случай, когда X и Y равны 10**9 и отклонились на максимально возможное
# значение epsilon в одну сторону. Тогда результат вычисления будет выглядеть так:
# (X + epsilon) * (Y + epsilon) = XY + (X + Y) * epsilon + epsilon**2
# Величина epsilon**2 пренебрежимо мала, XY - это правильный ответ, а (X + Y) * epsilon - искомое значение абсолютной
# погрешности. Подставим числа и получим:
# 2 * 10**9 * 5 * 10**(-7) = 10**3                               |X - Y| < epsilon
# Абсолютная погрешность вычисления составила 1000 (одну тысячу). Что довольно неожиданно и грустно.
# Таким образом, становится понятно, что нужно аккуратно вычислять значение погрешности для сравнения вещественных чисел
# print(0.1.as_integer_ratio()) - вывод дроби
# Для записи констант или при вводе-выводе может использоваться как привычное представление в виде десятичной дроби,
# например 123.456, так и "инженерная" запись числа, где мантисса записывается в виде вещественного числа с одной цифрой
# до точки и некоторым количеством цифр после точки, затем следует буква ''e'' (или ''E'') и экспонента. Число 123.456 в
# инженерной записи будет выглядеть как 1.23456e2, что означает, что 1.23456 нужно умножить на 10**2. И мантисса и
# экспонента могут быть отрицательными и записываются в десятичной системе.
# Такая запись чисел может применяться при создании вещественных констант, а также при вводе и выводе. Инженерная запись
# удобна для хранения очень больших или очень маленьких чисел, чтобы не считать количество нулей в начале или конце
# числа.
# Если хочется вывести число не в инженерной записи, а с фиксированным количеством знаков после точки, то следует
# воспользоваться методом format, который имеет массу возможностей. Нам нужен только вывод фиксированного количества
# знаков, поэтому воспользуемся готовым рецептом для вывода 25 знаков после десятичной точки у числа 0.1:
# x = 0.1
# print('{0:.25f}'.format(x))
# Если запустить эту программу, то можно легко убедиться в том, что 0.1 + 0.2 не равно 0.3. Хотя можно было надеятся,
# что несмотря на неточное представление, оно окажется одинаково неточным для всех чисел.
# Поэтому при использовании вещественных чисел нужно следовать нескольким простым правилам:
# 1) Если можно обойтись без использования вещественных чисел - нужно это сделать. Вещественные числа проблемные,
# неточные и медленные.
# 2) Два вещественных числа равны между собой, если они отличаются не более чем на epsilon. Число X меньше числа Y,
# если X < Y - epsilon.
# Код для сравнения двух чисел, заданных с точностью 6 знаков после точки, выглядит так:
# x = float(input())
# y = float(input())
# epsilon = 10 ** -6
# if abs(x - y) < epsilon:
#     print('Equal')
# else:
#     print('Not equal')
# При использовании целых и вещественных чисел в одном выражении вычисления производятся в вещественных числах. Тем не
# менее, иногда возникает необходимость преобразовать вещественное число в целое. Для этого можно использовать несколько
# видов функций округления:
# int - округляет в сторону нуля и отрицательные также в сторону нуля (отбрасывет дробную часть)
# round - округляет до ближайшего целого, если ближайших целых несколько (дробная часть равно 0.5), то к чётному
# floor - округляет в меньшую сторону
# ceil - округляет в большую сторону
# Функции floor и ceil находятся в библиотеке math.
# В библиотеке math также есть функция округления trunc, которая работает аналогично int.

# Даны длины сторон треугольника. Вычислите площадь треугольника.
# Формат ввода - Вводятся три положительных действительных числа.
# Формат вывода - Выведите ответ на задачу.
# a, b, c = float(input()), float(input()), float(input())
# p = (a + b + c) / 2
# s = (p * (p - a) * (p - b) * (p - c)) ** 0.5
# print('{0:.6f}'.format(s))

# По данному числу n вычислите сумму (1 / 1²)+(1 / 2²)+(1 / 3²)+...+(1 / n²).
# Формат ввода - Вводится целое положительное число.
# Формат вывода - Выведите ответ на задачу.
# n = int(input())
# i, summa = 1, 0
# while i <= n:
#     summa += 1 / i ** 2
#     i += 1
# print('{0:.6f}'.format(summa))

# Дано положительное действительное число X. Выведите его дробную часть.
# Формат ввода - Вводится положительное действительное число.
# Формат вывода - Выведите ответ на задачу.
# x = float(input())
# print('{0:.6f}'.format(x - int(x)))

# Цена товара обозначена в рублях с точностью до копеек, то есть действительным числом с двумя цифрами после десятичной
# точки. Запишите в две целочисленные переменные стоимость товара в виде целого числа рублей и целого числа копеек и
# выведите их на экран. При решении этой задачи нельзя пользоваться условными инструкциями и циклами.
# Формат ввода - Вводится неотрицательное действительное число.
# Формат вывода - Выведите ответ на задачу.
# x = float(input())
# print(int(x), '{0:.0f}'.format((x - int(x)) * 100))

# По российский правилам числа округляются до ближайшего целого числа,а если дробная часть числа равна 0.5, то число
# округляется вверх. Дано неотрицательное число x, округлите его по этим правилам. Обратите внимание, что функция round
# не годится для этой задачи!
# Формат ввода - Вводится неотрицательное число.
# Формат вывода - Выведите ответ на задачу.
# x = float(input())
# if round(x - int(x), 10) >= 0.5:
#     print(int(x) + 1)
# else:
#     print(int(x))

# Процентная ставка по вкладу составляет P процентов годовых, которые прибавляются к сумме вклада. Вклад составляет X
# рублей Y копеек. Определите размер вклада через год. Рельзя пользоваться условными инструкциями и циклами.
# Формат ввода - Программа получает на вход целые числа P, X, Y.
# Формат вывода - Программа должна вывести два числа: величину вклада через год в рублях и копейках. Дробная часть
# копеек отбрасывается. Поэтому надо сделать - my_input * 100 % 100
# 17
# 94
# 41
# Ответ: 110 45.
# p, x, y = int(input()), int(input()), int(input())
# my_input = ((x * 100 + y) + (x * 100 + y) * p / 100) / 100
# print(int(my_input), int(my_input * 100 % 100))

# Процентная ставка по вкладу составляет P процентов годовых, которые прибавляются к сумме вклада через год. Вклад
# составляет X рублей Y копеек. Определите размер вклада через K лет.
# Формат ввода - Программа получает на вход целые числа  P, X, Y, K.
# Формат вывода - Программа должна вывести два числа: величину вклада через K лет в рублях и копейках. Дробное число
# копеек по истечение года отбрасывается. Перерасчет суммы вклада (с отбрасыванием дробных частей копеек) происходит
# ежегодно.
# p, x, y, k = int(input()), int(input()), int(input()), int(input())
# my_input = (x * 100 + y)
# i = 0
# while k > i:
#     my_input = (my_input + my_input * p / 100) // 1
#     i += 1
# print(int(my_input / 100), int(my_input % 100))

# Дан многочлен P(x) = a[n] xⁿ+a[n-1] xⁿ⁻¹+...+a[1] x+a[0] и число x. Вычислите значение этого многочлена,
# воспользовавшись схемой Горнера: P(x) = ( ... ( ( ( a[n] x + a[n-1] ) x + a[n-2] ) x + a[n-3] ) ... ) x + a[0]
# Формат ввода - Сначала программе подается на вход целое неотрицательное число n ≤ 20, затем действительное число x,
# затем следует n+1 вещественных чисел — коэффициенты многочлена от старшего к младшему.
# Формат вывода - Программа должна вывести значение многочлена.
# Примечания - При решении этой задачи нельзя использовать массивы и операцию возведения в степень. Программа должна
# иметь сложность O(n), то есть при увеличении количества входных данных в k раз время выполнения программы должно
# вырастать примерно в k раз.
# n, x, a = int(input()), float(input()), float(input())
# i, summa = 0, a
# while n > i:
#     summa *= x
#     a = float(input())
#     summa += a
#     i += 1
# print(round(summa, 6))

# Дана последовательность натуральных чисел x₁, x₂ ..., xn. Стандартным отклонением называется величина
# σ=sqrt(((x₁-s)²+(x₂-s)²+…+(xn-s)²) / (n-1)), где s = ((x₁+x₂+…+xn) / n) — среднее арифметическое последовательности,
# а sqrt - квадратный корень. Определите стандартное отклонение для данной последовательности натуральных чисел,
# завершающейся числом 0.
# Формат ввода - Вводится последовательность целых чисел, оканчивающаяся числом 0 (само число 0 в последовательность не
# входит, а служит как признак ее окончания).
# Формат вывода - Выведите ответ на задачу.
# from math import sqrt
# number, n, summa, summa_squares = 1, -1, 0, 0
# while number != 0:
#     number = int(input())
#     summa += number
#     summa_squares += number ** 2
#     n += 1
# print(sqrt((summa_squares - summa ** 2 / n) / (n - 1)))

# Даны действительные коэффициенты a, b, c, при этом a != 0. Решите квадратное уравнение ax²+bx+c=0 и выведите его корни
# Формат ввода - Вводятся три действительных числа.
# Формат вывода - Если уравнение имеет два корня, выведите два корня в порядке возрастания, если один корень — выведите
# одно число, если нет корней — не выводите ничего.
# from math import sqrt
# a, b, c = float(input()), float(input()), float(input())
# d = b ** 2 - 4 * a * c
# if d > 0:
#     x_1 = (-b + sqrt(d)) / (2 * a)
#     x_2 = (-b - sqrt(d)) / (2 * a)
#     if x_1 > x_2:
#         x_1, x_2 = x_2, x_1
#     print(round(x_1, 6), round(x_2, 6))
# elif d == 0:
#     x = -b / (2 * a)
#     print(round(x, 6))

# Даны произвольные действительные коэффициенты a, b, c. Решите уравнение ax²+bx+c=0.
# Формат ввода - Вводятся три действительных числа.
# Формат вывода - Если данное уравнение не имеет корней, выведите число 0. Если уравнение имеет один корень, выведите
# число 1, а затем этот корень. Если уравнение имеет два корня, выведите число 2, а затем два корня в порядке
# возрастания. Если уравнение имеет бесконечно много корней, выведите число 3.
# from math import sqrt
# a, b, c = float(input()), float(input()), float(input())
# if a == 0:
#     if b == 0 and c == 0:
#         print(3)
#     elif b != 0:
#         print(1, -c / b)
#     elif b == 0 and c != 0:
#         print(0)
# else:
#     d = b ** 2 - 4 * a * c
#     if d > 0:
#         x_1 = (-b + sqrt(d)) / (2 * a)
#         x_2 = (-b - sqrt(d)) / (2 * a)
#         if x_1 > x_2:
#             x_1, x_2 = x_2, x_1
#         print(2, round(x_1, 6), round(x_2, 6))
#     elif d == 0:
#         x = -b / (2 * a)
#         print(1, round(x, 6))
#     elif d < 0:
#         print(0)

# Даны вещественные числа a, b, c, d, e, input_file. Известно, что система линейных уравнений:
# ax + by = e
# cx + dy = input_file
# имеет ровно одно решение. Выведите два числа x и y, являющиеся решением этой системы.
# Формат ввода - Вводятся шесть чисел a, b, c, d, e, input_file - коэффициенты уравнений системы.
# Формат вывода - Выведите ответ на задачу. Вариант округления - *1 00000000 // 100000000
# a, b, c, d = float(input()), float(input()), float(input()), float(input())
# e, input_file = float(input()), float(input())
# x, y = 0, 0
# if a != 0:
#     y = (input_file - c * e / a) / (d - c * b / a)  # a != 0
# if b != 0:
#     x = (input_file - d * e / b) / (c - d * a / b)  # b != 0
# if c != 0:
#     y = (e - a * input_file / c) / (b - a * d / c)  # c != 0
# if d != 0:
#     x = (e - b * input_file / d) / (a - b * c / d)  # d != 0
# print(round(x, 6), round(y, 6))
#
# a, b, c = float(input()), float(input()), float(input())
# d, e, input_file = float(input()), float(input()), float(input())
# x = (e * d - b * input_file) / (a * d - b * c)
# y = (a * input_file - c * e) / (a * d - b * c)
# print(x, y)  # *100000000//100000000

# Даны числа a, b, c, d, e, input_file. Решите систему линейных уравнений
# ax + by = e
# cx + dy = input_file
# ормат ввода - Вводятся 6 чисел a, b, c, d, e, input_file — коэффициенты уравнений.
# Формат вывода - Вывод программы зависит от вида решения этой системы.
# Если система не имеет решений, то программа должна вывести единственное число 0.
# Если система имеет бесконечно много решений, каждое из которых имеет вид y=px+q, то программа должна вывести число 1,
# а затем значения p и q.
# Если система имеет единственное решение (x₀,y₀), то программа должна вывести число 2, а затем значения x₀ и y₀.
# Если система имеет бесконечно много решений вида x=x₀, y—любое, то программа должна вывести число 3, а затем значение x₀.
# Если система имеет бесконечно много решений вида y=y₀, x—любое, то программа должна вывести число 4, а затем значение y₀.
# Если любая пара чисел (x,y) является решением, то программа должна вывести число 5.
# a, b, c, d = float(input()), float(input()), float(input()), float(input())
# e, input_file = float(input()), float(input())
# if a * d == b * c and a * input_file != c * e:
#     print(0)
# elif a == b == 0 and e != 0:
#     print(0)
# elif c == d == 0 and input_file != 0:
#     print(0)
# elif a == c == 0 and b * input_file != d * e:
#     print(0)
# elif b == d == 0 and a * input_file != c * e:
#     print(0)
# elif a == b == c == d == e == input_file == 0:
#     print(5)
# elif a * d == b * c and a * input_file == c * e:
#     if b == d == 0:
#         if a != 0 and c != 0:
#             print(3, e / a)
#         elif a == 0 and e == 0:
#             print(3, input_file / c)
#         elif c == 0 and input_file == 0:
#             print(3, e / a)
#     elif a == c == 0:
#         if b:
#             print(4, e / b)
#         elif d:
#             print(4, input_file / d)
#     elif b:
#         print(1, -a / b, e / b)
#     elif d:
#         print(1, -c / d, input_file / d)
# else:
#     x = (e * d - b * input_file) / (a * d - b * c)
#     y = (a * input_file - c * e) / (a * d - b * c)
#     print(2, x, y)

# Дана строка. Если в этой строке буква input_file встречается только один раз, выведите её индекс. Если она встречается два и
# более раз, выведите индекс её первого и последнего появления. Если буква input_file в данной строке не встречается, ничего не
# выводите. При решении этой задачи нельзя использовать метод count и циклы.
# string = input()
# first = string.find('input_file')
# last = string.rfind('input_file')
# if first != -1:
#     if first == last:
#         print(first)
#     else:
#         print(first, last)

# Дана строка, в которой буква h встречается минимум два раза.Удалите из этой строки первое и последнее вхождение буквы
# h,а также все символы, находящиеся между ними.
# string = input()
# first = string.find('h')
# last = string.rfind('h')
# first = string[:first]
# last = string[last + 1:]
# print(first + last)

# Дана строка, в которой буква h встречается как минимум два раза. Выведите измененную строку: повторите
# последовательность символов, заключенную между первым и последним появлением буквы h два раза (сами буквы h не
# в повторяемый фрагмент, т. е. их повторять не надо).
# string = input()
# first = string.find('h')
# last = string.rfind('h')
# first = string[first + 1:]
# last = string[:last]
# print(last + first)

# Дана строка. Найдите в этой строке второе вхождение буквы input_file и выведите индекс этого вхождения. Если буква input_file в данной
# строке встречается только один раз, выведите число -1, а если не встречается ни разу, выведите число -2. При решении
# этой задачи нельзя использовать метод count.
# string = input()
# first = string.find('input_file')
# if first == -1:
#     print(-2)
# else:
#     first = string.find('input_file', first + 1)
#     if first == -1:
#         print(-1)
#     else:
#         print(first)

# Дана строка, состоящая ровно из двух слов, разделенных пробелом. Переставьте эти слова местами. Результат запишите в
# строку и выведите получившуюся строку. При решении этой задачи нельзя пользоваться циклами и инструкцией if.
# string = input()
# space = string.find(' ')
# first = string[space + 1:]
# second = string[:space]
# print(first, second)

# Дана строка. Удалите из этой строки все символы @.
# string = input()
# s = string.replace('@', '')
# print(s)

# Дана строка. Замените в этой строке все появления буквы h на букву H, кроме первого и последнего вхождения.
# string = input()
# pos_min = string.find('h')
# pos_max = string.rfind('h')
# fragment = string[pos_min + 1:pos_max]
# fragment = fragment.replace('h', 'H')
# print(string[:pos_min + 1] + fragment + string[pos_max:])

# Дана строка. Получите новую строку, вставив между каждыми двумя символами исходной строки символ *. Выведите
# полученную строку.
# string, count, = input(), 1,
# my_input = string[0]
# while len(string) > count:
#     my_input = my_input + '*' + string[count]
#     count += 1
# print(my_input)

# Дана строка. Удалите из нее все символы, чьи индексы делятся на 3.Символы строки нумеруются, начиная с нуля.
# string, count, = input(), 0,
# my_input = ''
# while len(string) > count:
#     if count % 3 != 0:
#         my_input = my_input + string[count]
#     count += 1
# print(my_input)

# Вызовы функций из функции
# Функцию подсчета факториала можно использовать для подсчета биномиальных коэффициентов (числа сочетаний). Формула для
# подсчета числа сочетаний выглядит так: n! / (k! * (n - k)!).
# Если бы мы не пользовались функциями, то нам потребовалось бы три раза записать почти одно и то же. С помощью функций
# вычисление выглядит намного проще:
# def factorial(num):
#     fact = 1
#     i = 2
#     while i <= num:
#         fact *= i
#         i += 1
#     return fact
# def binomial(n, k):
#     return factorial(n) // (factorial(k) * factorial(n - k))
# n, k = int(input()), int(input())  # n > k
# print(binomial(n, k))

# Напишите функцию min4(a, b, c, d), вычисляющую минимум четырех чисел, которая не содержит инструкции if, а использует
# стандартную функцию min от двух чисел. Считайте четыре целых числа и выведите их минимум.
# def min4(a, b, c, d):
#     return min(min(a, b), min(c, d))
# a1, b1, c1, d1 = int(input()), int(input()), int(input()), int(input())
# print(min4(a1, b1, c1, d1))

# Даны четыре действительных числа: x₁, y₁, x₂, y₂. Напишите функцию distance(x1, y1, x2, y2), вычисляющую расстояние
# между точками (x₁,y₁) и (x₂,y₂). Считайте четыре действительных числа и выведите результат работы этой функции.
# def distance(x_1, y_1, x_2, y_2):
#     return ((x_2 - x_1) ** 2 + (y_2 - y_1) ** 2) ** 0.5
# x1, y1, x2, y2 = float(input()), float(input()), float(input()), float(input())
# print(round(distance(x1, y1, x2, y2), 5))

# Напишите функцию, вычисляющую длину отрезка по координатам его концов. С помощью этой функции напишите программу,
# вычисляющую периметр треугольника по координатам трех его вершин.
# def perimeter_triangle(x_1, y_1, x_2, y_2, x_3, y_3):
#     a = ((x_2 - x_1) ** 2 + (y_2 - y_1) ** 2) ** 0.5
#     b = ((x_3 - x_2) ** 2 + (y_3 - y_2) ** 2) ** 0.5
#     c = ((x_3 - x_1) ** 2 + (y_3 - y_1) ** 2) ** 0.5
#     return a + b + c
# x1, y1, x2, y2 = float(input()), float(input()), float(input()), float(input())
# x3, y3 = float(input()), float(input())
# print(round(perimeter_triangle(x1, y1, x2, y2, x3, y3), 6))

# Даны два действительных числа x и y. Проверьте, принадлежит ли точка с координатами(x,y) заштрихованному квадрату
# (включая его границу). Если точка принадлежит квадрату, выведите слово YES, иначе выведите слово NO. На рисунке сетка
# проведена с шагом 1. (нарисован ромб с координатами (диагоналями) -1, 1 по оси и x и y).
# def IsPointInSquare(x, y):
#     x_f = round(1 - abs(y), 6)
#     y_f = round(1 - abs(x), 6)
#     return -x_f <= x <= x_f and -y_f <= y <= y_f
# x, y = float(input()), float(input())
# if IsPointInSquare(x, y):
#     print('YES')
# else:
#     print('NO')

# Даны пять действительных чисел: x, y, xc, yc, r.
# Проверьте, принадлежит ли точка (x,y) кругу с центром (xc, yc) и радиусом r.
# Если точка принадлежит кругу, выведите слово YES, иначе выведите слово NO.
# Решение должно содержать функцию IsPointInCircle(x, y, xc, yc, r), возвращающую True, если точка принадлежит кругу и
# False, если не принадлежит.
# Основная программа должна считать координаты точки, вызвать функцию IsPointInCircle и в зависимости от возвращенного
# значения вывести на экран необходимое сообщение. Функция IsPointInCircle не должна содержать инструкцию if.
# Формат ввода - Вводится пять действительных чисел.
# Формат вывода - Выведите ответ на задачу.
# x, y = float(input()), float(input())
# xc, yc, r = float(input()), float(input()), float(input())
# def IsPointInCircle(x, y, xc, yc, r):
#     return ((x - xc) ** 2 + (y - yc) ** 2) ** 0.5 <= r
# print('YES' if IsPointInCircle(x, y, xc, yc, r) else 'NO')

# Проверьте, принадлежит ли точка данной закрашенной области:
# Если точка принадлежит области (область включает границы), выведите слово YES, иначе выведите слово NO. Решение должно
# содержать функцию IsPointInArea(x, y), возвращающую True, если точка принадлежит области и False, если не принадлежит.
# Основная программа должна считать координаты точки, вызвать функцию IsPointInArea и в зависимости от возвращенного
# значения вывести на экран необходимое сообщение. Функция IsPointInArea не должна содержать инструкцию if.
# x, y = float(input()), float(input()),
# def IsPointInArea(x, y):
#     in_circle_top = ((x + 1) ** 2 + (y - 1) ** 2) ** 0.5 <= 2
#     in_circle_bottom = ((x + 1) ** 2 + (y - 1) ** 2) ** 0.5 < 2
#     top_area = y >= 2 / 3 and -y <= x <= (y - 2) / 2
#     bottom_area = y <= 2 / 3 and (y - 2) / 2 <= x <= -y
#     top = in_circle_top and top_area
#     bottom = bottom_area and not in_circle_bottom
#     return top or bottom
# # y = -x
# # y = 2 + 2x
# #
# # x = -2 /3
# # y = 2 /3
# print('YES' if IsPointInArea(x, y) else 'NO')

# Дано натуральное число n>1. Проверьте, является ли оно простым. Программа должна вывести слово YES, если число простое
# и NO, если число составное. Решение оформите в виде функции IsPrime(n), которая возвращает True для простых чисел и
# False для составных чисел. Программа должна иметь сложность O(корень из n): количество действий в программе должно
# быть пропорционально квадратному корню из n (иначе говоря, при увеличении входного числа в k раз, время выполнения
# программы должно увеличиваться примерно в корень из k раз).
# n = int(input())
# def isPrime(n):
#     i = 2
#     while i <= n ** 0.5:
#         if n % i == 0:
#             return False
#         i += 1
#     return True
# print('YES' if isPrime(n) else 'NO')

# Формализуем задачу. Пусть задается последовательность натуральных чисел, заканчивающаяся нулем. Необходимо развернуть
# ее с помощью рекурсии.
# def rec():
#     n = int(input())
#     if n != 0:
#         rec()
#         print(n)
# rec()

# Дано действительное положительное число a и целое неотрицательное число n. Вычислите aⁿ, не используя циклы и
# стандартную функцию pow, но используя рекуррентное соотношение aⁿ=a⋅aⁿ⁻¹.
# Решение оформите в виде функции power(a, n) (которая возвращает aⁿ).
# Формат ввода - Вводятся действительное положительное число a и целое неотрицательное число n.
# Формат вывода - Выведите ответ на задачу: print(power(a, n)).
# a, n = float(input()), int(input())
# def power(a, n):
#     if n == 0:
#         return 1
#     elif n == 1:
#         return a
#     return a * power(a, n - 1)
# print(power(a, n))

# Дано действительное положительное число a и целоe число n. Вычислите aⁿ. Решение оформите в виде функции power(a, n).
# Стандартной функцией возведения в степерь пользоваться нельзя.
# Формат ввода - Вводится действительное положительное число a и целоe число n.
# Формат вывода - Выведите ответ на задачу.
# Примечания - Здесь не нужна рекурсия.
# a, n = float(input()), int(input())
# def power(a, n):
#     s = 1
#     for i in range(abs(n)):
#         if n > 0:
#             s *= a
#         else:
#             s /= a
#     return s
# print(power(a, n))

# Напишите рекурсивную функцию sum(a, b), возвращающую сумму двух целых неотрицательных чисел. Из всех арифметических
# операций допускаются только +1 и -1. Также нельзя использовать циклы.
# Формат ввода
# Вводятся два удовлетворяющих условию задачи числа. Числа не превышают 900.
# Формат вывода
# Выведите ответ на задачу.
# a, b = int(input()), int(input())
# def sum(a, b):
#     if b == 0:
#         return a
#     return 1 + sum(a, b - 1)
# print(sum(a, b))

# Возводить в степень можно гораздо быстрее, чем за n умножений! Для этого нужно воспользоваться следующими
# рекуррентными соотношениями: aⁿ = (a²)ⁿ/² при четном n, aⁿ=a⋅aⁿ⁻¹ при нечетном n. Реализуйте алгоритм быстрого
# возведения в степень. Если вы все сделаете правильно,то сложность вашего алгоритма будет O(logn).
# Формат ввода -  Вводится действительное число a и целое неотрицательное число n.
# Формат вывода - # Выведите ответ на задачу.
# a, n = float(input()), int(input())
# def power(a, n):
#     if n == 0:
#         return 1
#     if n == 2:
#         return a * a
#     if n % 2 == 1:
#         return a * power(a, n - 1)
#     return a ** (n / 2) * power(a, n / 2)
# print(power(a, n))

# Для быстрого вычисления наибольшего общего делителя двух чисел используют алгоритм Евклида. Он построен на следующем
# соотношении: НОД(a,b)=НОД(b,a % b).
# Реализуйте рекурсивный алгоритм Евклида в виде функции gcd(a, b).
# Формат ввода - Вводится два целых положительных числа.
# Формат вывода - Выведите ответ на задачу.
# a, b = int(input()), int(input())
# def gcd(a, b):
#     if b == 0:
#         return a
#     return gcd(b, a % b)
# print(gcd(a, b))

# Даны два натуральных числа n и m.
# Сократите дробь (n / m), то есть выведите два других числа p и q таких, что (n / m) = (p / q) и дробь (p / q) —
# несократимая.
# Решение оформите в виде функции ReduceFraction(n, m), получающая значения n и m и возвращающей кортеж из двух чисел:
# return p, q.
# Тогда вывод можно будет оформить как print(*ReduceFraction(n, m)).
# Формат ввода - Вводятся два натуральных числа.
# Формат вывода - Выведите ответ на задачу.
# n, m = int(input()), int(input())
# def gcd(a, b):
#     if b == 0:
#         return a
#     return gcd(b, a % b)
# def ReduceFraction(n, m):
#     s = gcd(n, m)
#     p = n // s
#     q = m // s
#     return p, q
# print(*ReduceFraction(n, m))


# Напишите функцию phib(n), которая по данному целому неотрицательному n возвращает n-e число Фибоначчи. В этой задаче
# нельзя использовать циклы - используйте рекурсию.
# Формат ввода - Вводится удовлетворяющее условию задачи число.
# Формат вывода - Выведите ответ на задачу.
# Примечание - Обратите внимание на нумерацию чисел, показанную в примерах.
# n = int(input())
# def phib(n):
#     a, b = 1, 2
#     if n < 3:
#         return 1
#     elif n > 3:
#         a, b = b, phib(n - 1) + phib(n - 2)
#     return b
# print(phib(n))
#
# def fib(n):
#     if n == 1 or n == 2:
#         return 1
#     else:
#         return fib(n - 1) + fib(n - 2)
# print(fib(int(input())))

# По данным целым числам n и k  (0≤k≤n) вычислите C из n по k. Решение оформите в виде функции C(n, k).
# Для решения используйте рекуррентное соотношение:
# И равенства:
# С(n, 1)=n
# C(n, n)=1
# Формат ввода - Вводятся удовлетворяющие условию задачи числа n и k.
# Формат вывода - Выведите ответ на задачу.
# def C(n, k):
#     if k == n or k == 0:
#         return 1
#     if k != 1:
#         return C(n - 1, k) + C(n - 1, k - 1)
#     else:
#         return n
# print(C(int(input()), int(input())))
# Через факториал медленно и не эффективно.
# В формуле n! / (k! (n - k)!), если сократить, то получится (n-k+1)(n-k+2)..n/k!
# def С(n, k):
#     if 0 <= k <= n:
#         nn = 1
#         kk = 1
#         for t in xrange(1, min(k, n - k) + 1):
#             nn *= n
#             kk *= t
#             n -= 1
#         return nn // kk
#     else:
#         return 0
# Также можно посмотреть библиотеку itertools:
# combinations('ABCD', 2)  # AB AC AD BC BD CD

# Дана последовательность чисел, завершающаяся числом 0. Найдите сумму всех этих чисел, не используя цикл.
# Формат ввода - Вводится последовательность целых чисел, оканчивающаяся числом 0 (само число 0 в последовательность не
# входит, а служит как признак ее окончания).
# Формат вывода - Выведите ответ на задачу.
# def summa():
#     n = int(input())
#     if n == 0:
#         return n
#     return n + summa()
# print(summa())

# Дана последовательность целых чисел, заканчивающаяся числом 0. Выведите эту последовательность в обратном порядке.
# При решении этой задачи нельзя пользоваться массивами и прочими динамическими структурами данных.Рекурсия вам поможет.
# Формат ввода -  Вводится последовательность целых чисел, оканчивающаяся числом 0.
# Формат вывода -  Выведите ответ на задачу.
# def summa():
#     n = int(input())
#     if n == 0:
#         return print(n)
#     summa()
#     return print(n)
# summa()

# Головоломка “Ханойские башни” состоит из трех стержней, пронумерованных числами 1, 2, 3. На стержень 1 надета
# пирамидка из n дисков различного диаметра в порядке убывания диаметра (снизу находится самый большой диск, а сверху —
# самый маленький). Диски можно перекладывать с одного стержня на другой по одному, при этом диск нельзя класть на диск
# меньшего диаметра. Необходимо переложить всю пирамидку со стержня 1 на стержень 3 за минимальное число перекладываний.
# Напишите программу, которая решает головоломку; для данного числа дисков n печатает последовательность перекладываний
# в формате a b c, где a — номер перекладываемого диска, b — номер стержня с которого снимается данный диск, c — номер
# стержня на который надевается данный диск.
# Например, строка 1 2 3 означает перемещение диска номер 1 со стержня 2 на стержень 3. В одной строке печатается одна
# команда. Диски пронумерованы числами от 1 до n в порядке возрастания диаметров.
# Программа должна вывести минимальный (по количеству произведенных операций) способ перекладывания пирамидки из данного
# числа дисков.
#      Указание: подумайте, как переложить пирамидку из одного диска? Из двух дисков? Из трех дисков? Из четырех дисков?
#      Пусть мы научились перекладывать пирамидку из n дисков с произвольного стержня на любой другой, как переложить
#      пирамидку из n+1 диска, если можно пользоваться решением для n дисков.
# Напишите функцию move (n, x, y), которая печатает последовательность перекладываний дисков для перемещения пирамидки
# высоты n со стержня номер x на стержень номер y.
# Формат ввода - Вводится натуральное число — количество дисков.
# Формат вывода - Выведите ответ на задачу.
# def move(n, x, y):
#     if n == 1:
#         print('1', x, y)
#     else:
#         tmp = 6 - x - y
#         move(n - 1, x, tmp)
#         print(n, x, y)
#         move(n - 1, tmp, y)
# n = int(input())
# move(n, 1, 3)

# Теорема Лагранжа утверждает, что любое натуральное число можно представить в виде суммы четырех точных квадратов. По
# данному числу n найдите такое представление: напечатайте от 1 до 4 натуральных чисел, квадраты которых дают в сумме
# данное число.
# Формат ввода
# Программа получает на вход одно натуральное число n < 10000.
# Формат вывода
# Программа должна вывести от 1 до 4 натуральных чисел, квадраты которых дают в сумме данное число.
# def lagrange_theorem(n, level):
#     if not level:
#         return False
#     number = int(n ** 0.5)
#     if number ** 2 == n:
#         return number
#     while number > 0:
#         if lagrange_theorem(n - number ** 2, level - 1):
#             return input_file"{number} {lagrange_theorem(n - number ** 2, level - 1)}"
#         number -= 1 # уменьшаем число, если не получается в четыре слагаемых
#     return False
# print(lagrange_theorem(int(input()), 4))

# Напишите программу, которая представляет переданное натуральное число в виде суммы не более чем 7 кубов других
# натуральных чисел.
# Формат ввода - Входная строка содержит целое число N, которое нужно представить в виде суммы кубов.
# Формат вывода - Программа должна вывести любое разложение переданного ей числа в виде суммы не более чем 7 кубов
# других натуральных чисел. Если такое разложение невозможно, программа должна вывести число 0.
# def sum_cube(n, level):
#     if not level:
#         return 0
#     number = int(pow(n, 1 / 3))
#     if number ** 3 == n:
#         return number ** 3
#     while number > 0:
#         if sum_cube(n - number ** 3, level - 1):
#             return input_file"{number ** 3} {sum_cube(n - number ** 3, level - 1)}"
#         number -= 1
#     return 0
# print(sum_cube(int(input()), 7))

# Напишите программу, которая выбирает из полученной последовательности квадраты целых чисел выводит их в обратном
# порядке. Использовать массив для хранения последовательности не разрешается.
# Формат ввода
# Во входных строках записаны целые числа, по одному в каждой строке. В последней строке записано число 0.
# Формат вывода
# Программа должна вывести элементы полученной последовательности, которые представляют собой квадраты целых чисел, в
# обратном порядке в одну строчку, разделив их пробелами. Если таких нет, программа должна вывести число 0.
# def squares():
#     number = int(input())
#     if number == 0:
#         return None
#     squares()
#     if number ** 0.5 % 1 == 0:
#         print(number, end=' ')
#         global s
#         s = 0
# s = 1
# squares()
# if s:
#     print(0)
#
# def kvadrat(counter):
#     n = int(input())
#     if n != 0:
#         counter = kvadrat(counter)
#         if (int(n ** 0.5)) ** 2 == n:
#             print(n)
#             return (counter + 1)
#         return counter
#     return 0
# if kvadrat(0) == 0:
#     print(0)

# def _sqonly(some_flag=False):
#     x = int(input())
#     if x != 0:
#         if _sqonly(some_flag):
#             some_flag = True
#         if x ** 0.5 % 1 == 0:
#             print(x, ' ', end='')
#             some_flag = True
#     return some_flag
# if _sqonly() is False:
#     print('0')

# Напишите программу, которая по данному числу n от 1 до 9 выводит на экран n флагов. Изображение одного флага имеет
# размер 4×4 символов, между двумя соседними флагами также имеется пустой (из пробелов) столбец. Разрешается вывести
# пустой столбец после последнего флага. Внутри каждого флага должен быть записан его номер — число от 1 до n.
# Формат ввода -  Вводится натуральное число.
# Формат вывода -  Выведите ответ на задачу.
# a = int(input())
# print('+___ ' * a)
# for i in range(1, a + 1):
#     print('|' + str(i) + ' /', end=' ')
# print()
# print('|__\\ ' * a)
# print('|    ' * a)

# Напишите программу, которая находит в массиве элемент, самый близкий по величине к  данному числу.
# Формат ввода - В первой строке задается одно натуральное число N, не превосходящее 1000 – размер массива.  Во второй
# строке содержатся N чисел – элементы массива (целые числа, не превосходящие по модулю 1000).  В третьей строке
# вводится одно целое число x, не превосходящее по модулю 1000.
# Формат вывода - Вывести значение элемента массива, ближайшее к x. Если таких чисел несколько, выведите любое из них.
# n = int(input())
# a = list(map(int, input().split()))
# x, b = int(input()), 1000
# if a[0] < 0:
#     b = -b
# for i in a:
#     if abs(i - x) < abs(b - x):
#         b = i
# print(b)

# Переставьте соседние элементы списка (A[0] c A[1],A[2] c A[3] и т.д.).Если элементов нечетное число, то последний
# элемент остается на своем месте.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
# a = list(map(int, input().split()))
# b = []
# for i in range(0, len(a), 2):
#     if len(a) - i != 1:
#         b.extend([a[i + 1], a[i]])
#     if len(a) - i == 1:
#         b.append(a[i])
# print(*b)

# Дан список, заполненный произвольными целыми числами. Найдите в этом списке два числа, произведение которых
# максимально. Выведите эти числа в порядке неубывания.
# Решение должно иметь сложность O(n), где n - размер списка. То есть сортировку использовать нельзя.
# a = list(map(int, input().split()))
# max_1, max_2 = 0, 0
# min_1, min_2 = None, None
# for i in a:
#     if i > 0:
#         if i > max_1:
#             max_1 = i
#             if max_1 > max_2:
#                 max_1, max_2 = max_2, max_1
#     if i < 0:
#         if min_1 is None:
#             min_1 = i
#         elif min_2 is None:
#             min_2 = i
#             if min_1 > min_2:
#                 min_1, min_2 = min_2, min_1
#         elif i < min_2:
#             min_2 = i
#             if min_1 > min_2:
#                 min_1, min_2 = min_2, min_1
# if len(a) != 1:
#     if min_2 is not None:
#         if max_1 * max_2 <= min_1 * min_2:
#             print(min_1, min_2)
#         else:
#             print(max_1, max_2)
#     else:
#         if min_1 is not None and len(a) == 2:
#             print(min_1, max_2)
#         else:
#             print(max_1, max_2)

# В данном списке из n≤10⁵ целых чисел найдите три числа,произведение которых максимально.
# Решение должно иметь сложность O(n), где n - размер списка. То есть сортировку использовать нельзя.
# Выведите три искомых числа в любом порядке.
# a = list(map(int, input().split()))
# max_1, max_2, max_3 = 0, 0, 0
# min_1, min_2 = None, None
# min_11, min_22, min_33 = None, None, None
# count_plus, count_minus = 0, 0
# for i in a:
#     if i >= 0:
#         count_plus += 1
#         if i > max_1:
#             max_1 = i
#             if max_1 > max_2:
#                 max_1, max_2 = max_2, max_1
#             if max_2 > max_3:
#                 max_2, max_3 = max_3, max_2
#     if i < 0:
#         count_minus += 1
#         if min_1 is None:
#             min_1 = i
#             min_11 = i
#         elif min_2 is None:
#             min_2 = i
#             min_22 = i
#             if min_1 > min_2:
#                 min_1, min_2 = min_2, min_1
#         elif i < min_2:
#             min_2 = i
#             if min_1 > min_2:
#                 min_1, min_2 = min_2, min_1
#         if count_minus == 3:
#             min_33 = i
#             if min_33 > min_22:
#                 min_22, min_33 = min_33, min_22
#             if min_22 > min_11:
#                 min_22, min_11 = min_11, min_22
#             if min_11 > min_33:
#                 min_33, min_11 = min_11, min_33
#         elif i > min_11 and count_minus > 2:
#             min_11 = i
#             if min_33 > min_22:
#                 min_22, min_33 = min_33, min_22
#             if min_22 > min_11:
#                 min_22, min_11 = min_11, min_22
#             if min_11 > min_33:
#                 min_33, min_11 = min_11, min_33
# if len(a) > 2:
#     if count_minus >= 2 and count_plus > 0:
#         if max_1 * max_2 * max_3 <= min_1 * min_2 * max_3:
#             print(max_3, min_2, min_1)  # +
#         else:
#             print(max_3, max_2, max_1)  # +
#     elif count_minus > 2 and count_plus == 0:
#         print(min_11, min_22, min_33)
#     elif count_minus == 1 and count_plus == 2:  # +
#         print(max_3, max_2, min_1)
#     elif count_minus <= 1 and count_plus > 2:
#         print(max_3, max_2, max_1)  # +

# Дан список чисел. Посчитайте, сколько в нем пар элементов, равных друг другу. Считается, что любые два элемента,
# равные друг другу образуют одну пару, которую необходимо посчитать.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
# a = list(map(int, input().split()))
# k = 0
# for i in range(len(a)):
#     k += a[i + 1:].count(a[i])
# print(k)

# Дан список. Выведите те его элементы, которые встречаются в списке только один раз. Элементы нужно выводить в том
# порядке, в котором они встречаются в списке.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
# a = list(map(int, input().split()))
# for i in range(len(a)):
#     if a.count(a[i]) == 1:
#         print(a[i], end=' ')

# Известно, что на доске 8×8 можно расставить 8 ферзей так, чтобы они не били друг друга. Вам дана расстановка 8 ферзей
# на доске, определите, есть ли среди них пара бьющих друг друга.
# Формат ввода - Программа получает на вход восемь пар чисел, каждое число от 1 до 8 - координаты 8 ферзей.
# Формат вывода - Если ферзи не бьют друг друга, выведите слово NO, иначе выведите YES.
# pos_list = []
# my_input = 'NO'
# for _ in range(8):
#     pos = list(map(int, input().split()))
#     pos_list.append(pos)
#     for i, pos in enumerate(pos_list):
#         for pos_next in pos_list[i + 1:]:
#             if abs(pos[0] - pos_next[0]) == abs(pos[1] - pos_next[1])\
#                     or pos[0] == pos_next[0] or pos[1] == pos_next[1]:
#                 my_input = 'YES'
#                 break
# print(my_input)

# Дан список целых чисел. Требуется “сжать” его, переместив все ненулевые элементы в левую часть списка, не меняя их
# порядок, а все нули - в правую часть. Порядок ненулевых элементов изменять нельзя, дополнительный список использовать
# нельзя, задачу нужно выполнить за один проход по списку. Распечатайте полученный список.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
# data_list = list(map(int, input().split()))
# j = 0
# for i in range(len(data_list)):
#     if data_list[i] != 0:
#         data_list[i], data_list[j] = data_list[j], data_list[i]
#         j += 1
# print(*data_list)

# Дан список. Не изменяя его и не используя дополнительные списки, определите, какое число в этом списке встречается
# чаще всего. Если таких чисел несколько, выведите любое из них.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
# data_list = list(map(int, input().split()))
# count, my_input = 0, 0
# for element in data_list:
#     if count < data_list.count(element):
#         count = data_list.count(element)
#         my_input = element
# print(my_input)

# Даны числа a, b, c, d, e. Подсчитайте количество таких целых чисел от 0 до 1000 (включительно), которые являются
# корнями уравнения (ax³+bx²+cx+d)/(x-e)=0, и выведите их количество.
# Формат ввода - Вводятся целые числа a, b, c, d и e.
# Формат вывода - Выведите ответ на задачу.
# a = int(input())
# b = int(input())
# c = int(input())
# d = int(input())
# e = int(input())
# s = 0
# for i in range(1001):
#     if i != e:
#         if (a * i ** 3 + b * i ** 2 + c * i + d) / (i - e) == 0:
#             s += 1
# print(s)

# Даны два целочисленных списка A и B, упорядоченных по неубыванию. Объедините их в один упорядоченный список С (то
# есть он должен содержать len(A)+len(B) элементов). Решение оформите в виде функции merge(A, B), возвращающей новый
# список. Алгоритм должен иметь сложность O(len(A)+len(B)). Модифицировать исходные списки запрещается. Использовать
# функцию sorted и метод sort запрещается.
# Формат ввода - Программа получает на вход два неубывающих списка, каждый в отдельной строке.
# Формат вывода - Программа должна вывести последовательность неубывающих чисел, полученных объединением двух данных
# списков.
# A = list(map(int, input().split()))
# B = list(map(int, input().split()))
# def merge(A, B):
#     C = []
#     count_a, count_b, end_a, end_b = 0, 0, False, False
#     while not end_a or not end_b:
#         if not end_b and (A[count_a] >= B[count_b] or
#                           end_a and count_a == len(A) - 1):
#             C.append(B[count_b])
#             if count_b < len(B) - 1:
#                 count_b += 1
#             else:
#                 end_b = True
#         if not end_a and (A[count_a] <= B[count_b] or
#                           end_b and count_b == len(B) - 1):
#             C.append(A[count_a])
#             if count_a < len(A) - 1:
#                 count_a += 1
#             else:
#                 end_a = True
#     return C
# print(*merge(A, B))

# Даны два списка, упорядоченных по возрастанию (каждый список состоит из различных элементов).
# Найдите пересечение множеств элементов этих списков, то есть те числа, которые являются элементами обоих списков.
# Алгоритм должен иметь сложность O(len(A)+len(B)).
# Решение оформите в виде функции Intersection(A, B). Функция должна возвращать список пересечения данных списков в
# порядке возрастания элементов. Модифицировать исходные списки запрещается.
# Формат ввода - Программа получает на вход два возрастающих списка, каждый в отдельной строке.
# Формат вывода - Программа должна вывести последовательность возрастающих чисел, являющихся элементами обоих списков.
# A = list(map(int, input().split()))
# B = list(map(int, input().split()))
# def Intersection(A, B):
#     C = []
#     count_a, count_b, end_a, end_b = 0, 0, False, False
#     while not end_a and not end_b:
#         # print(count_a, count_b, C)
#         if A[count_a] == B[count_b]:
#             C.append(A[count_a])
#         if not end_b and (A[count_a] >= B[count_b] or
#                           end_a and count_a == len(A) - 1):
#             # C.append(B[count_b])
#             if count_b < len(B) - 1:
#                 count_b += 1
#             else:
#                 end_b = True
#         elif not end_a and (A[count_a] <= B[count_b] or
#                             end_b and count_b == len(B) - 1):
#             # C.append(A[count_a])
#             if count_a < len(A) - 1:
#                 count_a += 1
#             else:
#                 end_a = True
#     return C
# print(*Intersection(A, B))

# В обувном магазине продается обувь разного размера. Известно, что одну пару обуви можно надеть на другую, если она
# хотя бы на три размера больше. В магазин пришел покупатель.Требуется определить, какое наибольшее количество пар обуви
# сможет предложить ему продавец так, чтобы он смог надеть их все одновременно.
# Формат ввода - Сначала вводится размер ноги покупателя (обувь меньшего размера он надеть не сможет), в следующей
# строке — размеры каждой пары обуви в магазине через пробел. Размер — натуральное число, не превосходящее 100.
# Формат вывода - Выведите единственное число — максимальное количество пар обуви, которое сможет надеть покупатель.
# n = int(input())
# number_list = list(map(int, input().split()))
# number_list.sort()
# count, memory = None, None
# for element in number_list:
#     if n <= element:
#         if count is None:
#             count = 1
#             memory = element
#         if element - memory >= 3:
#             count += 1
#             memory = element
#
# print(count if count is not None else 0)

# Напишите программу, которая по заданной информации о пользователях и свободному объему на архивном диске определит
# максимальное число пользователей, чьи данные можно поместить в архив.
# Формат ввода - Программа получает на вход в одной строке число S – размер свободного места на диске (натуральное, не
# превышает 10000), и число N – количество пользователей (натуральное, не превышает 100), после этого идет N чисел
# - объем данных каждого пользователя (натуральное, не превышает 1000), записанных каждое в отдельной строке.
# Формат вывода - Выведите наибольшее количество пользователей, чьи данные могут быть помешены в архив.
# free_place, n = list(map(int, input().split()))
# users_places, volume = [], 0
# for _ in range(n):
#     users_places.append(int(input()))
# for i, user_place in enumerate(sorted(users_places)):
#     volume += user_place
#     if volume == free_place:
#         print(i + 1)
#         break
#     elif volume > free_place:
#         print(i)
#         break
# else:
#     print(n)

# Штаб гражданской обороны Тридесятой области решил обновить план спасения на случай ядерной атаки. Известно, что все
# n селений Тридесятой области находятся вдоль одной прямой дороги. Вдоль дороги также расположены m бомбоубежищ, в
# которых жители селений могут укрыться на случай ядерной атаки.
# Чтобы спасение в случае ядерной тревоги проходило как можно эффективнее, необходимо для каждого селения определить
# ближайшее к нему бомбоубежище.
# Формат ввода - В первой строке вводится число n - количество селений (1 <= n <= 100000). Вторая строка содержит n
# различных целых чисел, i-е из этих чисел задает расстояние от начала дороги до i-го селения. В третьей строке входных
# данных задается число m - количество бомбоубежищ (1 <= m <= 100000). Четвертая строка содержит m различных целых
# чисел, i-е из этих чисел задает расстояние от начала дороги до i-го бомбоубежища. Все расстояния положительны и не
# превышают 10⁹. Селение и убежище могут располагаться в одной точке.
# Формат вывода - Выведите  n чисел - для каждого селения выведите номер ближайшего к нему бомбоубежища. Бомбоубежища
# пронумерованы от 1 до m в том порядке, в котором они заданы во входных данных.
# n_villages = int(input())
# resurs_keys = []
# for i, value in enumerate(map(int, input().split())):
#     resurs_keys.append((value, i))
# resurs_keys.sort()
# n_bomb_shelter = int(input())
# bomb_shelter = []
# for i, value in enumerate(map(int, input().split())):
#     bomb_shelter.append((value, i))
# bomb_shelter.sort()
# list_out, j = [None] * len(resurs_keys), 0
# for i in range(len(resurs_keys)):
#     if len(bomb_shelter) != 1:
#         while True:
#             if abs(resurs_keys[i][0] - bomb_shelter[j][0]) < \
#                     abs(resurs_keys[i][0] - bomb_shelter[j + 1][0]):
#                 list_out[resurs_keys[i][1]] = bomb_shelter[j][1] + 1
#                 break
#             elif len(bomb_shelter) == j + 2:
#                 list_out[resurs_keys[i][1]] = bomb_shelter[j + 1][1] + 1
#                 break
#             elif j < len(bomb_shelter) - 2:
#                 j += 1
#     else:
#         list_out[resurs_keys[i][1]] = bomb_shelter[j][1] + 1
# print(*list_out)

# В олимпиаде по информатике принимало участие несколько человек.
# Определите и выведите средние баллы участников олимпиады в 9 классе, в 10 классе, в 11 классе.
# Входные данные
# Информация о результатах олимпиады записана в файле, каждая строка которого имеет вид:
# фамилия имя класс балл.
# Фамилия и имя — текстовые строки, не содержащие пробелов. Класс - одно из трех чисел 9, 10, 11. Балл - целое число от
# 0 до 100.
# В этой задаче файл необходимо считывать построчно, не сохраняя содержимое файла в памяти целиком.
# Выходные данные
# Выведите три числа: средние баллы по 9 классу, по 10 классу, по 11 классу. Входной файл в кодировке utf-8
# (используйте open('input.txt', 'r', encoding='utf-8')).
# import sys
# count_a, count_b, count_c, a, b, c = 0, 0, 0, 0, 0, 0
# for line in sys.stdin:
#     s = line.split()
#     if s[2] == '9':
#         a += float(s[3])
#         count_a += 1
#     elif s[2] == '10':
#         b += float(s[3])
#         count_b += 1
#     elif s[2] == '11':
#         c += float(s[3])
#         count_c += 1
# print(round(a / count_a, 7), round(b / count_b, 7), round(c / count_c, 7))

# Известно, что фамилии всех участников — различны. Сохраните в массивах список всех участников и выведите его,
# отсортировав по фамилии в лексикографическом порядке. При выводе указываете фамилию, имя участника и его балл.
# Используйте для ввода и вывода файлы input.txt и output.txt с указанием кодировки utf8. Например, для чтения откройте
# файл с помощью open('input.txt', 'r', encoding='utf8').
# Входные данные - Строки вида "Фамилия Имя НомерШколы Балл".
# Выходные данные - Строки вида "Фамилия Имя Балл", отсортированные по фамилии.
# file = []
# with open('input.txt', 'r', encoding='utf8') as input_file, \
#         open('output.txt', 'w', encoding='utf8') as w:
#     for data in input_file.readlines():
#         s = data.split()
#         file.append(input_file'{s[0]} {s[1]} {s[3]}')
#     file.sort()
#     contents = '\n'.join(file)
#     w.write(contents)

# Дан список из N (N≤2*10⁵) элементов, которые принимают целые значения от 0 до 100 (100 включая).
# Отсортируйте этот список в порядке неубывания элементов. Выведите полученный список.
# Решение оформите в виде функции CountSort(A), которая модифицирует передаваемый ей список. Использовать встроенные
# функции сортировки нельзя.
# def CountSort(A):
#     count_list, out_list = [0] * 101, []
#     for i in A:
#         count_list[i] += 1
#     for number in range(len(count_list)):
#         if count_list[number]:
#             out_list.extend([str(number)] * count_list[number])
#     return out_list
# in_list = list(map(int, input().split()))
# print(*CountSort(in_list))

# При изготовлении клавиатуры изначально для каждой клавиши задается количество нажатий, которое она должна выдерживать.
# Если знать эти величины для используемой клавиатуры, то для определенной последовательности нажатых клавиш можно
# определить, какие клавиши в процессе их использования сломаются, а какие — нет.
# Требуется написать программу, определяющую, какие клавиши сломаются в процессе заданного варианта эксплуатации
# клавиатуры.
# Формат ввода - Первая строка входных данных содержит целое число n (1≤n≤1000) — количество клавиш на клавиатуре.
# Вторая строка содержит n целых чисел —с₁, с₂, … , сn, где сᵢ (1≤cᵢ≤100000) — количество нажатий,выдерживаемых i-ой
# клавишей. Третья строка содержит целое число k (1≤k≤100000) — общее количество нажатий клавиш, и последняя строка
# содержит k целых чисел pj (1≤pj≤n) — последовательность нажатых клавиш.
# Формат вывода - Программа должна вывести n строк, содержащих информацию об исправности клавиш. Если i-я клавиша
# сломалась, то i-ая строка должна содержать слово YES, если же клавиша работоспособна — слово NO.
# number_keys = int(input())
# resurs_keys = []
# for i, value in enumerate(map(int, input().split()), 1):
#     resurs_keys.append((i, value))
# pressing_count = int(input())
# pressing_keys = list(map(int, input().split()))
# count_list = [0] * (number_keys + 1)
# for i in pressing_keys:
#     count_list[i] += 1
# for element in resurs_keys:
#     if element[1] >= count_list[element[0]]:
#         print('NO')
#     else:
#         print('YES')

# В олимпиаде по информатике принимало участие несколько человек. Победителем олимпиады становится человек, набравший
# больше всех баллов. Победители определяются независимо по каждому классу. Определите количество баллов, которое набрал
# победитель в каждом классе. Гарантируется, что в каждом классе был хотя бы один участник.
# Формат ввода - Информация о результатах олимпиады записана в файле, каждая строка которого имеет вид:фамилия имя класс
# балл.
# Фамилия и имя — текстовые строки, не содержащие пробелов. Класс - одно из трех чисел 9, 10, 11. Балл - целое число от
# 0 до 100.
# В этой задаче файл необходимо считывать построчно, не сохраняя содержимое файла в памяти целиком.
# Формат вывода - Выведите три числа: баллы победителя олимпиады по 9 классу, по 10 классу, по 11 классу. Входной файл
# в кодировке utf-8 (В Python используйте open('input.txt', 'r', encoding='utf-8')).
# import sys
# max_9, max_10, max_11 = 0, 0, 0
# for line in sys.stdin:
#     s = line.split()
#     if s[2] == '9':
#         if max_9 < int(s[3]):
#             max_9 = int(s[3])
#     elif s[2] == '10':
#         if max_10 < int(s[3]):
#             max_10 = int(s[3])
#     elif s[2] == '11':
#         if max_11 < int(s[3]):
#             max_11 = int(s[3])
# print(max_9, max_10, max_11)

# В олимпиаде участвовало N человек. Каждый получил определенное количество баллов, при этом оказалось, что у всех
# участников разное число баллов. Упорядочите список участников олимпиады в порядке убывания набранных баллов.
# Формат ввода - Программа получает на вход число участников олимпиады N. Далее идет N строк, в каждой строке записана
# фамилия участника, затем, через пробел, набранное им количество баллов.
# Формат вывода - Выведите список участников (только фамилии) в порядке убывания набранных баллов.
# n, my_list = int(input()), []
# for i in range(n):
#     surname, score = input().split()
#     my_list.append((int(score), surname))
# for element in sorted(my_list, reverse=True):
#     print(element[1])

# В условиях предыдущей задачи определите количество школьников, ставших победителями в каждом классе. Победителями
# объявляются все, кто набрал наибольшее число баллов по данному классу. Гарантируется, что в каждом классе был хотя бы
# один участник.
# Формат вывода - Выведите три числа: количество победителей олимпиады по 9 классу, по 10 классу, по 11 классу.
# import sys
# max_9, max_10, max_11 = 0, 0, 0
# prev_max_9, prev_max_10, prev_max_11 = 0, 0, 0
# for line in sys.stdin:
#     s = line.split()
#     if s[2] == '9':
#         if max_9 < int(s[3]):
#             max_9 = int(s[3])
#             prev_max_9 = 1
#         elif max_9 == int(s[3]):
#             prev_max_9 += 1
#     elif s[2] == '10':
#         if max_10 < int(s[3]):
#             max_10 = int(s[3])
#             prev_max_10 = 1
#         elif max_10 == int(s[3]):
#             prev_max_10 += 1
#     elif s[2] == '11':
#         if max_11 < int(s[3]):
#             max_11 = int(s[3])
#             prev_max_11 = 1
#         elif max_11 == int(s[3]):
#             prev_max_11 += 1
# print(prev_max_9, prev_max_10, prev_max_11)

# Для поступления в вуз абитуриент должен предъявить результаты трех экзаменов в виде ЕГЭ, каждый из них оценивается
# целым числом от 0 до 100 баллов. При этом абитуриенты, набравшие менее 40 баллов (неудовлетворительную оценку) по
# любому экзамену из конкурса выбывают. Остальные абитуриенты участвуют в конкурсе по сумме баллов за три экзамена.
# В конкурсе участвует N человек, при этом количество мест равно K. Определите проходной балл, то есть такое количество
# баллов, что количество участников, набравших столько или больше баллов не превосходит K, а при добавлении к ним
# абитуриентов, набравших наибольшее количество баллов среди непринятых абитуриентов, общее число принятых абитуриентов
# станет больше K.
# Формат ввода - Программа получает на вход количество мест K. Далее идут строки с информацией об абитуриентах, каждая
# из которых состоит из имени (текстовая строка содержащая произвольное число пробелов) и трех чисел от 0 до 100,
# разделенных пробелами.
# спользуйте для ввода файл input.txt с указанием кодировки utf8 (для создания такого файла на своем компьютере в
# программе Notepad++ следует использовать кодировку UTF-8 без BOM).
# Формат вывода - Программа должна вывести проходной балл в конкурсе. Выведенное значение должно быть минимальным баллом
# который набрал абитуриент, прошедший по конкурсу.
# Также возможны две ситуации, когда проходной балл не определен.
# Если будут зачислены все абитуриенты, не имеющие неудовлетворительных оценок, программа должна вывести число 0.
# Если количество имеющих равный максимальный балл абитуриентов больше чем K, программа должна вывести число 1.
# Используйте для вывода файл output.txt с указанием кодировки utf8.
# file = []
# with open('input.txt', 'r', encoding='utf8') as input_file, \
#         open('output.txt', 'w', encoding='utf8') as w:
#     for data in input_file.readlines():
#         e = data.split()
#         if len(e) == 1:
#             a = int(e[0])
#         else:
#             s = e[-3:]
#             if min(int(s[0]), int(s[1]), int(s[2])) >= 40:
#                 file.append(int(s[0]) + int(s[1]) + int(s[2]))
#     file.sort(reverse=True)
#     if len(file) <= a or a == 0:
#         my_input = '0'
#     elif file.count(file[0]) > a:
#         my_input = '1'
#     elif len(file) > a:
#         if file[a - 1] != file[a]:
#             my_input = str(file[a - 1])
#         else:
#             for i in range(a - 2, -1, -1):
#                 if file[a - 1] != file[i]:
#                     my_input = str(file[i])
#                     break
#     w.write(my_input)

# В олимпиаде по информатике принимало участие N человек. Определите школы, из которых в олимпиаде принимало участие
# больше всего участников. В этой задаче необходимо считывать данные построчно, не сохраняя в памяти данные обо всех
# участниках, а только подсчитывая число участников для каждой школы.
# Формат ввода - Информация о результатах олимпиады записана в файле, каждая из строк которого имеет вид:
# фамилия имя школа балл
# Фамилия и имя — текстовые строки, не содержащие пробелов. Школа — целое число от 1 до 99. Балл — целое число от 0 до
# 100.
# Формат вывода - Выведите номера этих школ в порядке возрастания.
# import sys
# schools = [0] * 101
# for line in sys.stdin:
#     n = int(line.split()[2])
#     schools[n] += 1
# my_input = []
# for i in range(len(schools)):
#     if schools[i] == max(schools):
#         my_input.append(i)
# print(*my_input)

# Зачет проводится отдельно в каждом классе. Победителями олимпиады становятся школьники, которые набрали наибольший
# балл среди всех участников в данном классе.
# Для каждого класса определите максимальный балл, который набрал школьник, не ставший победителем в данном классе.
# Формат вывода - Выведите три целых числа.
# import sys
# max_9, max_10, max_11 = 0, 0, 0
# prev_max_9, prev_max_10, prev_max_11 = 0, 0, 0
# for line in sys.stdin:
#     s = line.split()
#     if s[2] == '9':
#         if max_9 < int(s[3]):
#             max_9, prev_max_9 = int(s[3]), max_9
#         elif prev_max_9 < int(s[3]) < max_9:
#             prev_max_9 = int(s[3])
#     elif s[2] == '10':
#         if max_10 < int(s[3]):
#             max_10, prev_max_10 = int(s[3]), max_10
#         elif prev_max_10 < int(s[3]) < max_10:
#             prev_max_10 = int(s[3])
#     elif s[2] == '11':
#         if max_11 < int(s[3]):
#             max_11, prev_max_11 = int(s[3]), max_11
#         elif prev_max_11 < int(s[3]) < max_11:
#             prev_max_11 = int(s[3])
# print(prev_max_9, prev_max_10, prev_max_11)

# После затянувшегося совещания директор фирмы решил заказать такси, чтобы развезти сотрудников по домам. Он заказал N
# машин — ровно столько, сколько у него сотрудников. Однако когда они подъехали, оказалось, что у каждого водителя такси
# свой тариф за 1 километр.
# Директор знает, какому сотруднику сколько километров от работы до дома (к сожалению, все сотрудники живут в разных
# направлениях, поэтому нельзя отправить двух сотрудников на одной машине). Теперь директор хочет определить, сколько
# придется заплатить за перевозку всех сотрудников. Естественно, директор хочет заплатить как можно меньшую сумму.
# Формат ввода - В первой строке записаны N чисел через пробел, задающих расстояния в километрах от работы до домов
# сотрудников компании. Во второй строке записаны N чисел — тарифы за проезд одного километра в такси.
# Формат вывода - Выведите одно целое число — наименьшую сумму, которую придется заплатить за доставку всех сотрудников.
# distances = list(map(int, input().split()))
# prices = list(map(int, input().split()))
# cost = 0
# distances.sort()
# prices.sort(reverse=True)
# for i in range(len(prices)):
#     cost += distances[i] * prices[i]
# print(cost)

# В Государственную Думу Федерального Собрания Российской Федерации выборы производятся по партийным спискам. Каждый
# избиратель указывает одну партию, за которую он отдает свой голос. В Государственную Думу попадают партии, которые
# набрали не менее 7% от числа голосов избирателей.
# Дан список партий и список голосов избирателей. Выведите список партий, которые попадут в Государственную Думу.
# Формат ввода - В первой строке входного файла написано слово PARTIES:. Далее идет список партий, участвующих в выборах
# Затем идет строка, содержащая слово VOTES:. За ним идут названия партий, за которые проголосовали избиратели, по
# одному названию в строке. Названия могут быть только строками из первого списка.
# Формат вывода - Программа должна вывести названия партий, получивших не менее 7% от числа голосов в том порядке, в
# котором они следуют в первом списке.
# import sys
# list_of_parties, voices = [], []
# PARTIES, VOTES = False, False
# for line in sys.stdin:
#     text = line.strip()
#     if text == 'PARTIES:':
#         PARTIES = True
#     elif text == 'VOTES:':
#         PARTIES = False
#         VOTES = True
#     elif PARTIES:
#         list_of_parties.append(text)
#     elif VOTES:
#         if not voices:
#             voices = [0] * len(list_of_parties)
#         voices[list_of_parties.index(text)] += 1
# for i, number in enumerate(voices):
#     if number / sum(voices) * 100 >= 7:
#         print(list_of_parties[i])

# from sys import stdin
# a, s, p = stdin.readlines(), 0, []
# for i in a:
#     p = [[a[i], 0] for i in range(1, a.index('VOTES:\n'))]
# for i in range(len(p)):
#     p[i][1] = a.count(p[i][0]) - 1
#     s += p[i][1]
# for i in range(len(p)):
#     print(' '.join(p[i][0].split())) if p[i][1] / s * 100 >= 7 else None

# Формат входных данных аналогичен предыдущей задаче. Выведите список всех партий, участвовавших в выборах, отсортировав
# его в порядке убывания количества голосов избирателей, а при равном количестве голосов - в лексикографическом порядке.
# import sys
# list_of_parties, voices = [], []
# PARTIES, VOTES = False, False
# for line in sys.stdin:
#     text = line.strip()
#     if text == 'PARTIES:':
#         PARTIES = True
#     elif text == 'VOTES:':
#         PARTIES = False
#         VOTES = True
#     elif PARTIES:
#         list_of_parties.append(text)
#     elif VOTES:
#         if not voices:
#             voices = [0] * len(list_of_parties)
#         voices[list_of_parties.index(text)] += 1
# for number, name in sorted(zip(voices, list_of_parties),
#                            key=lambda x: (-x[0], x[1])):
#     print(name)

# В первой строке входного файла записаны числа N и M — количество кубиков у Ани и Бори соответственно. В следующих N
# строках заданы номера цветов кубиков Ани. В последних M строках  номера цветов кубиков Бори.
# Формат вывода
# Выведите сначала количество, а затем отсортированные по возрастанию номера цветов таких, что кубики каждого цвета
# есть в обоих наборах, затем количество и отсортированные по возрастанию номера остальных цветов у Ани, потом
# количество и отсортированные по возрастанию номера остальных цветов у Бори.
# import sys
# n, m = None, None
# n_num, m_num = set(), set()
# i = 0
# for line in sys.stdin:
#     s = line.split()
#     if n is None:
#         n, m = int(s[0]),  int(s[1])
#     else:
#         if i < n:
#             n_num.add(int(s[0]))
#             i += 1
#         else:
#             m_num.add(int(s[0]))
#
# print(len(n_num & m_num))
# print(*sorted(n_num & m_num))
# print(len(n_num - (n_num & m_num)))
# print(*sorted(n_num - (n_num & m_num)))
# print(len(m_num - (n_num & m_num)))
# print(*sorted(m_num - (n_num & m_num)))

# Во входном файле (вы можете читать данные из sys.stdin, подключив библиотеку sys) записан текст. Словом считается
# последовательность непробельных символов идущих подряд, слова разделены одним или большим числом пробелов или
# символами конца строки. Определите, сколько различных слов содержится в этом тексте.
# import sys
# words = set()
# for line in sys.stdin:
#     s = line.split()
#     for word in s:
#         words.add(word)
# print(len(words))

# Август и Беатриса играют в игру. Август загадал натуральное число от 1 до n. Беатриса пытается угадать это число, для
# этого она называет некоторые множества натуральных чисел. Август отвечает Беатрисе YES, если среди названных ею чисел
# есть задуманное или NO в противном случае. После нескольких заданных вопросов Беатриса запуталась в том, какие вопросы
# она задавала и какие ответы получила и просит вас помочь ей определить, какие числа мог задумать Август.
# Формат ввода
# Первая строка входных данных содержит число n — наибольшее число, которое мог загадать Август. Далее идут строки,
# содержащие вопросы Беатрисы. Каждая строка представляет собой набор чисел, разделенных пробелами. После каждой строки
# с вопросом идет ответ Августа: YES или NO.  Наконец, последняя строка входных данных содержит одно слово HELP.
# Формат вывода
# Вы должны вывести (через пробел, в порядке возрастания) все числа, которые мог задумать Август.
# import sys
# numbers = set()
# n_max = None
# for line in sys.stdin:
#     s = line.split()
#     if n_max is None:
#         n_max = int(s[0])
#         numbers = set(i for i in range(1, n_max + 1))
#     else:
#         if s == ['HELP']:
#             print(*sorted(numbers))
#             exit()
#         elif s != ['YES'] and s != ['NO']:
#             input_num = set()
#             for number in s:
#                 input_num.add(int(number))
#         elif s == ['YES']:
#             numbers &= input_num
#         elif s == ['NO']:
#             numbers -= input_num

# Август и Беатриса продолжают играть в игру, но Август начал жульничать. На каждый из вопросов Беатрисы он выбирает
# такой вариант ответа YES или NO, чтобы множество возможных задуманных чисел оставалось как можно больше. Например,
# если Август задумал число от 1 до 5, а Беатриса спросила про числа 1 и 2, то Август ответит NO, а если Беатриса
# спросит про 1, 2, 3, то Август ответит YES. Если же Бетриса в своем вопросе перечисляет ровно половину из задуманных
# чисел, то Август из вредности всегда отвечает NO. Наконец, Август при ответе учитывает все предыдущие вопросы Беатрисы
# и свои ответы на них, то есть множество возможных задуманных чисел уменьшается.
# Формат ввода
# Вам дана последовательность вопросов Беатрисы. Приведите ответы Августа на них. Первая строка входных данных содержит
# число n — наибольшее число, которое мог загадать Август. Далее идут строки, содержащие вопросы Беатрисы. Каждая строка
# представляет собой набор чисел, разделенных пробелами. Последняя строка входных данных содержит одно слово HELP.
# Формат вывода
# Для каждого вопроса Беатрисы выведите ответ Августа на этот вопрос. После этого выведите (через пробел, в порядке
# возрастания) все числа, которые мог загадать Август после ответа на всевопросы Беатрисы.
# import sys
# numbers, responses = set(), []
# n_max = None
# for line in sys.stdin:
#     s = line.split()
#     if n_max is None:
#         n_max = int(s[0])
#         numbers = memory = set(i for i in range(1, n_max + 1))
#     else:
#         if s == ['HELP']:
#             for i in responses:
#                 print(i)
#             print(*sorted(numbers))
#             exit()
#         elif s != ['YES'] and s != ['NO']:
#             input_num = set()
#             for number in s:
#                 input_num.add(int(number))
#         if len(input_num & memory) * 2 > len(numbers):
#             numbers &= input_num
#             responses.append('YES')
#         else:
#             numbers -= input_num
#             responses.append('NO')

# Каждый из N школьников некоторой школы знает Mᵢ языков. Определите, какие языки знают все школьники и языки, которые
# знает хотя бы один из школьников.
# Формат ввода
# Первая строка входных данных содержит количество школьников N. Далее идет N чисел Mᵢ, после каждого из чисел идет
# Mᵢ строк, содержащих названия языков, которые знает i-й школьник. Длина названий языков не превышает 1000 символов,
# количество различных языков не более 1000. 1≤N≤1000, 1≤Mᵢ≤500.
# Формат вывода
# В первой строке выведите количество языков, которые знают все школьники. Начиная со второй строки - список таких
# языков. Затем - количество языков, которые знает хотя бы один школьник, на следующих строках - список таких языков.
# n, m_i = int(input()), {input() for _ in range(int(input()))}
# one_language, all_languages = m_i.copy(), m_i.copy()
# for _ in range(1, n):
#     m_i = {input() for _ in range(int(input()))}
#     all_languages |= m_i
#     one_language &= m_i
# for language in [one_language, all_languages]:
#     print(len(language), * language, sep='\n')

# На Новом проспекте для разгрузки было решено пустить два новых автобусных маршрута на разных участках проспекта.
# Известны конечные остановки каждого из автобусов. Определите количество остановок, на  которых можно пересесть с
# одного автобуса на другой.
# Формат ввода
# Вводятся четыре числа, не превосходящие 100, задающие номера конечных остановок. Сначала для первого, потом второго
# автобуса (см. примеры и рисунок).
# Формат вывода
# Ваша программа должна выводить одно число – искомое количество остановок.
# all = tuple(map(int, input().split()))
# bus1 = set(range(min(all[:2]), max(all[:2]) + 1))
# bus2 = set(range(min(all[2:]), max(all[2:]) + 1))
# print(len(bus1 & bus2))

# Политическая жизнь одной страны очень оживленная. В стране действует K политических партий, каждая из которых
# регулярно объявляет национальную забастовку. Дни, когда хотя бы одна из партий объявляет забастовку, при условии, что
# это не суббота или воскресенье (когда и так никто не работает), наносят большой ущерб экономике страны. i-я партия
# объявляет забастовки строго каждые bᵢ дней, начиная с дня с номером aᵢ. То есть i-я партия объявляет забастовки в дни
# aᵢ, aᵢ+bᵢ, aᵢ+2bᵢ и т.д. Если в какой-то день несколько партий объявляет забастовку, то это считается одной
# общенациональной забастовкой. В календаре страны N дней, пронумерованных от 1 до N. Первый день года является
# понедельником, шестой и седьмой дни года — выходные, неделя состоит из семи дней.
# Формат ввода
# Программа получает на вход число дней в году N (1≤N≤10⁶) и число политических партий K (1≤K≤100). Далее идет K строк,
# описывающие графики проведения забастовок.i-я строка содержит числа aᵢ и bᵢ (1≤aᵢ,bᵢ≤N).
# Формат вывода
# Выведите единственное число: количество забастовок, произошедших в течение года.
# Примечания
# Первая партия объявляет забастовки в дни 2, 5, 8, 11, 14, 17. Вторая партия объявляет забастовки в дни 3, 8, 13, 18.
# Третья партия — в дни 9 и 17. Дни номер 6, 7, 13, 14 являются выходными. Таким образом, забастовки пройдут в дни
# 2, 3, 5, 8, 9, 11, 17, 18.
# strike_days = set()
# days, k = map(int, input().split())
# for _ in range(k):
#     a, b = map(int, input().split())
#     for day in range(a, days + 1, b):
#         if day not in strike_days and day % 7 != 6 and day % 7 != 0:
#             strike_days.add(day)
#
# print(len(strike_days))

# Телефонные номера в адресной книге мобильного телефона имеют один из следующих форматов:
# - +7<код><номер>
# - 8<код><номер>
# - <номер>
# где <номер> — это семь цифр, а <код> — это три цифры или три цифры в круглых скобках. Если код не указан, то
# считается, что он равен 495. Кроме того, в записи телефонного номера может стоять знак “-” между любыми двумя цифрами
# (см. пример). На данный момент в адресной книге телефона Васи записано всего три телефонных номера, и он хочет
# записать туда еще один. Но он не может понять, не записан ли уже такой номер в телефонной книге. Помогите ему! Два
# телефонных номера совпадают, если у них равны коды и равны номера. Например, +7(916)0123456 и 89160123456 — это один
# и тот же номер.
# Формат ввода
# В первой строке входных данных записан номер телефона, который Вася хочет добавить в адресную книгу своего телефона.
# В следующих трех строках записаны три номера телефонов, которые уже находятся в адресной книге телефона Васи.
# Гарантируется, что каждая из записей соответствует одному из трех приведенных в условии форматов.
# Формат вывода
# Для каждого телефонного номера в адресной книге выведите YES, если он совпадает с тем телефонным номером,который Вася
# хочет добавить в адресную книгу или NO в противном случае.
# number_save = None
# for _ in range(4):
#     number = input()
#     number_input = ''
#     for symbol in number:
#         if symbol.isdigit():
#             number_input += symbol
#     if len(number_input) == 11:
#         number_input = number_input[-10:]
#     if len(number_input) == 7:
#         number_input = '495' + number_input
#     if number_save is None:
#         number_save = number_input
#     else:
#         if number_save == number_input:
#             print('YES')
#         else:
#             print('NO')

# n_l = []
# for i in range(4):
#     n_l.append(''.join(j for j in input() if j.isdigit()))
#     n_l[i] = "8495" + n_l[i] if len(n_l[i]) == 7 else n_l[i]
# [print(["NO", "YES"][n_l[0][1:] == n_l[i][1:]]) for i in range(1, 4)]

# Дан список стран и городов каждой страны. Затем даны названия городов. Для каждого города укажите, в какой стране он
# находится.
# Формат ввода
# Программа получает на вход количество стран N. Далее идет N строк, каждая строка начинается с названия страны, затем
# идут названия городов этой страны. Название каждого город состоит из одного слова. В следующей строке записано число
# M, далее идут M запросов — названия каких-то M городов, перечисленных выше.
# Формат вывода
# Для каждого из запроса выведите название страны, в котором находится данный город.
# towns_dict = {}
# for _ in range(int(input())):
#     country, towns = input().split(' ', 1)
#     for town in towns.split():
#         if town not in towns_dict:
#             towns_dict[town.strip()] = country.strip()
# for _ in range(int(input())):
#     town = input().strip()
#     if town in towns_dict:
#         print(towns_dict[town])

# Во входном файле (вы можете читать данные из файла input.txt) записан текст. Словом считается последовательность
# непробельных подряд идущих символов. Слова разделены одним или большим числом пробелов или символами конца строки. Для
# каждого слова из этого текста подсчитайте, сколько раз оно встречалось в этом тексте ранее.
# Формат ввода
# Вводится текст.
# Формат вывода
# Выведите ответ на задачу.
# count = {}
# my_input = []
# with open('input.txt') as s:
#     for line in s:
#         my_list = line.split()
#         for word in my_list:
#             if word not in count:
#                 count[word] = 0
#             else:
#                 count[word] += 1
#             my_input.append(count[word])
# print(*my_input)

# Вам дан словарь, состоящий из пар слов. Каждое слово является синонимом к парному ему слову. Все слова в словаре
# различны. Для одного данного слова определите его синоним.
# Формат ввода
# Программа получает на вход количество пар синонимов N. Далее следует N строк, каждая строка содержит ровно два
# слова-синонима. После этого следует одно слово.
# Формат вывода
# Программа должна вывести синоним к данному слову.
# Примечания
# Эту задачу можно решить и без словарей (сохранив все входные данные в списке), но решение со словарем будет более
# простым.
# my_dict = {}
# for _ in range(int(input())):
#     word_1, word_2 = input().split()
#     my_dict[word_1] = word_2
#     my_dict[word_2] = word_1
# print(my_dict[input()])

# Как известно, в США президент выбирается не прямым голосованием, а путем двухуровневого голосования. Сначала
# проводятся выборы в каждом штате и определяется победитель выборов в данном штате. Затем проводятся государственные
# выборы: на этих выборах каждый штат имеет определенное число голосов — число выборщиков от этого штата. На практике,
# все выборщики от штата голосуют в соответствии с результатами голосования внутри штата, то есть на заключительной
# стадии выборов в голосовании участвуют штаты, имеющие различное число голосов. Вам известно за кого проголосовал
# каждый штат и сколько голосов было отдано данным штатом. Подведите итоги выборов: для каждого из участника голосования
# определите число отданных за него голосов.
# Формат ввода
# Каждая строка входного файла содержит фамилию кандидата, за которого отдают голоса выборщики этого штата, затем через
# пробел идет количество выборщиков,отдавших голоса за этого кандидата.
# Формат вывода
# Выведите фамилии всех кандидатов в лексикографическом порядке,затем, через пробел, количество отданных за них голосов.
# import sys
# my_input = {}
# for line in sys.stdin:
#     family, number = line.split()
#     if family not in my_input:
#         my_input[family] = int(number)
#     else:
#         my_input[family] += int(number)
# for family in sorted(my_input):
#     print(family, my_input[family])

# Дан текст. Выведите слово, которое в этом тексте встречается чаще всего. Если таких слов несколько, выведите то,
# которое меньше в лексикографическом порядке.
# Формат ввода
# Вводится текст.
# Формат вывода
# Выведите ответ на задачу.
# import sys
# my_input, my_out = {}, {}
# for line in sys.stdin:
#     my_list = line.split()
#     for word in my_list:
#         if word not in my_input:
#             my_input[word] = 0
#         my_input[word] += 1
# for key, value in my_input.items():
#     if value not in my_out:
#         my_out[value] = []
#     my_out[value].append(key)
# g = sorted(my_out, reverse=True)[0]
# print(sorted(my_out[g])[0])
#
# import sys
#
# my_input = {}
# for line in sys.stdin:
#     my_list = line.split()
#     for word in my_list:
#         my_input[word] = my_input[word] + 1 if word in my_input else 1
# print(my_input)
# print(min(my_input.items(), key=lambda x: (-x[1], x[0]))[0])

# words = dict()
# for i in open('input.txt').read().split():
#     words[i] = words[i] + 1 if i in words else 1
# print(min(words.items(), key=lambda x: (-x[1],x[0]))[0])  # это работает более быстрее, так как вместо сортировки
# # всего словаря ищется только один элемент

# Дан текст. Выведите все слова, встречающиеся в тексте, по одному на каждую строку. Слова должны быть отсортированы по
# убыванию их количества появления в тексте, а при одинаковой частоте появления — в лексикографическом порядке.
# Указание.
# После того, как вы создадите словарь всех слов, вам захочется отсортировать его по частоте встречаемости слова.
# Желаемого можно добиться, если создать список, элементами которого будут кортежи из двух элементов: частота
# встречаемости слова и само слово. Например, [(2, 'hi'), (1, 'what'), (3, 'is')]. Тогда стандартная сортировка будет
# сортировать список кортежей, при этом кортежи сравниваются по первому элементу, а если они равны —то по второму. Это
# почти то, что требуется в задаче.
# Формат ввода - Вводится текст.
# Формат вывода - Выведите ответ на задачу.
# import sys
# my_input = {}
# for line in sys.stdin:
#     my_list = line.split()
#     for word in my_list:
#         my_input[word] = my_input[word] + 1 if word in my_input else 1
# my_out = sorted(my_input.items(), key=lambda x: (-x[1], x[0]))
# for i in my_out:
#     print(i[0])

# В выборах Президента Российской Федерации побеждает кандидат, набравший свыше половины числа голосов избирателей. Если
# такого кандидата нет, то во второй тур выборов выходят два кандидата, набравших наибольшее число голосов.
# Формат ввода
# Каждая строка входного файла содержит имя кандидата, за которого отдал голос один избиратель. Известно, что общее
# число кандидатов не превосходит 20, но в отличии от предыдущих задач список кандидатов явно не задан. Читайте данные
# из файла input.txt с указанием кодировки utf8.
# Формат вывода
# Если есть кандидат, набравший более 50% голосов, программа должна вывести его имя. Если такого кандидата нет,
# программа должна вывести имя кандидата, занявшего первое место, затем имя кандидата, занявшего второе место. Выводите
# данные в файл output.txt с указанием кодировки utf8.
# out_file = open("output.txt", "w", encoding='utf-8')
# input_file = open('input.txt', 'r', encoding='utf-8')
# count, my_input = 0, {}
# for line in input_file:
#     line = line.strip()
#     my_input[line] = my_input[line] + 1 if line in my_input else 1
#     count += 1
# my_out = sorted(my_input.items(), key=lambda x: (-x[1], x[0]))
# print(my_out[0][0], file=out_file)
# if my_out[0][1] * 2 <= count:
#     print(my_out[1][0], file=out_file)
# out_file.close()
# input_file.close()

# outFile = open("output.txt", "w", encoding='utf-8')
# fin = open('input.txt', 'r', encoding='utf-8')
# people = dict()
# count = 0
# for line in fin:
#     people[line.strip()] = people.get(line.strip(), 0) + 1
#     count += 1
# p = sorted(people, key=lambda x: (-people[x], x))
# if people[p[0]] > count / 2:
#     print(p[0], file=outFile)
# else:
#     print(p[0], p[1], sep='\n', file=outFile)
# outFile.close()
# fin.close()

# Необходимо распределить 450 мест между партиями, участвовавших в выборах. Сначала подсчитывается сумма голосов
# избирателей, поданных за каждую партию и подсчитывается сумма голосов, поданных за все партии. Эта сумма делится на
# 450, получается величина, называемая “первое избирательное частное” (смысл первого избирательного частного - это
# количество голосов избирателей, которое необходимо набрать для получения одного места в парламенте). Далее каждая
# партия получает столько мест в парламенте, чему равна целая часть от деления числа голосов за данную партию на первое
# избирательное частное.Если после первого раунда распределения мест сумма количества мест, отданных партиям, меньше 450
# , то оставшиеся места передаются по одному партиям, в порядке убывания дробной части частного от деления числа голосов
# за данную партию на первое избирательное частное. Если же для двух партий эти дробные части равны, то преимущество
# отдается той партии, которая получила большее число голосов.
# Формат ввода
# На вход программе подается список партий, участвовавших в выборах. Каждая строка входного файла содержит название
# партии (строка, возможно, содержащая пробелы), затем, через пробел, количество голосов, полученных данной партией
# – число, не превосходящее 10⁸.
# Формат вывода
# Программа должна вывести названия всех партий и количество голосов в парламенте, полученных данной партией. Названия
# необходимо выводить в том же порядке, в котором они шли во входных данных.
# import sys
# parties, score = {}, 0
# for line in sys.stdin:
#     name = line.strip().split()
#     parties[' '.join(name[:-1])] = int(name[-1])
#     score += int(name[-1])
# part = score / 450
# parties = [[key, int(parties[key] / part), parties[key] / part -
#             int(parties[key] / part)] for key in parties]
# summa = sum(element[1] for element in parties)
# for element in sorted(parties, key=lambda x: (-x[2], -x[1])):
#     if summa < 450:
#         element[1] += 1
#         summa += 1
#     else:
#         break
# print(*[' '.join(map(str, element[:2])) for element in parties], sep='\n')
#
# d, s, h = {}, 0, 450
# with open('input.txt') as in_file:
#     for line in in_file:
#         d[' '.join(line.split()[:-1])] = int(line.split()[-1])
#         s += int(line.split()[-1])
# d = [[m, int(h * d[m] / s), h * d[m] / s - int(h * d[m] / s)] for m in d]
# print(d)
# overall = sum(party[1] for party in d)
# for party in sorted(d, key=lambda x: (-x[2], -x[1])):
#     if overall == h:
#         break
#     party[1], overall = party[1] + 1, overall + 1
# print(*[' '.join(map(str, party[:2])) for party in d], sep='\n')

# Дана база данных о продажах некоторого интернет-магазина. Каждая строка входного файла представляет собой запись вида
# Покупатель товар количество, где
# Покупатель — имя покупателя (строка без пробелов),
# товар — название товара (строка без пробелов),
# количество — количество приобретенных единиц товара.
# Создайте список всех покупателей, а для каждого покупателя подсчитайте количество приобретенных им единиц каждого вида
# товаров.
# Формат ввода - Вводятся сведения о покупках в указанном формате.
# Формат вывода - Выведите список всех покупателей в лексикографическом порядке,после имени каждого покупателя выведите
# двоеточие, затем выведите список названий всех приобретенных данным покупателем товаров в лексикографическом порядке,
# после названия каждого товара выведите количество единиц товара, приобретенных данным покупателем.Информация о каждом
# товаре выводится в отдельной строке.
# import sys
# base = {}
# for line in sys.stdin:
#     family, product, cost = line.strip().split()
#     base.setdefault(family, {})
#     base[family].setdefault(product, 0)
#     base[family][product] += int(cost)
# for family in sorted(base):
#     print(family + ':')
#     for product in sorted(base[family]):
#         print(product, base[family][product])

# Некоторый банк хочет внедрить систему управления счетами клиентов, поддерживающую следующие операции:
# Пополнение счета клиента.
# Снятие денег со счета.
# Запрос остатка средств на счете.
# Перевод денег между счетами клиентов.
# Начисление процентов всем клиентам.
# Вам необходимо реализовать такую систему. Клиенты банка идентифицируются именами (уникальная строка, не содержащая
# пробелов). Первоначально у банка нет ни одного клиента. Как только для клиента проводится операция пополнения, снятия
# или перевода денег, ему заводится счет с нулевым балансом. Все дальнейшие операции проводятся только с этим счетом.
# Сумма на счету может быть как положительной, так и отрицательной, при этом всегда является целым числом.
# Формат ввода
# Входной файл содержит последовательность операций. Возможны следующие операции:
# DEPOSIT name sum - зачислить сумму sum на счет клиента name. Если у клиента нет счета, то счет создается.
# WITHDRAW name sum - снять сумму sum со счета клиента name. Если у клиента нет счета, то счет создается.
# BALANCE name - узнать остаток средств на счету клиента name.
# TRANSFER name1 name2 sum - перевести сумму sum со счета клиента name1 на счет клиента name2. Если у какого-либо
# клиента нет счета, то ему создается счет.
# INCOME p - начислить всем клиентам, у которых открыты счета, p% от суммы счета. Проценты начисляются только клиентам
# с положительным остатком на счету, если у клиента остаток отрицательный, то его счет не меняется. После начисления
# процентов сумма на счету остается целой, то есть начисляется только целое число денежных единиц. Дробная часть
# начисленных процентов отбрасывается.
# Формат вывода
# Для каждого запроса BALANCE программа должна вывести остаток на счету данного клиента. Если же у клиента с
# запрашиваемым именем не открыт счет в банке, выведите ERROR.
# import sys
# base = {}
# for line in sys.stdin:
#     command, family_summa = line.strip().split(' ', 1)
#     if command in ['DEPOSIT', 'WITHDRAW', 'TRANSFER']:
#         family, summa = family_summa.split(' ', 1)
#         base.setdefault(family, 0)
#         if command == 'DEPOSIT':
#             base[family] += int(summa)
#         elif command == 'WITHDRAW':
#             base[family] -= int(summa)
#         elif command == 'TRANSFER':
#             family_2, summa_transfer = summa.split()
#             base.setdefault(family_2, 0)
#             base[family] -= int(summa_transfer)
#             base[family_2] += int(summa_transfer)
#     elif command == 'BALANCE':
#         print(base.get(family_summa, 'ERROR'))
#     elif command == 'INCOME':
#         for key, value in base.items():
#             if value > 0:
#                 base[key] += int(value * (int(family_summa) / 100))














