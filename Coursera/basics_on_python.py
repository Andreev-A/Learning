

###################################################################################################################

# Для подсчета модуля числа в Питоне существует функция abs, которая избавляет от необходимости каждый раз писать
# подсчет модуля вручную.



###############3######################################################################################################

# В отличие от целых чисел, вещественные числа в языке Питон имеют ограниченную длину.
# Подумаем, как хранить десятичную дробь в памяти. Поскольку вещественных чисел бесконечно много (даже больше, чем
# натуральных), то нам придется ограничить точность. Например, мы можем хранить только несколько первых значащих цифр,
# не храня незначащие нули. Будем отдельно хранить целое число с первыми значащими цифрами и отдельно хранить
# числа 10, на которую нужно умножить это число.
# Например, число 5.972*10**24 (это масса Земли в килограммах) можно сохранить как 5972 (цифры числа, мантисса) и 21
# (на какую степень 10 нужно умножить число, экспонента). С помощью такого представления можно хранить вещественные
# числа любой размерности.
# Примерно так и хранятся числа в памяти компьютера, однако вместо десятичной системы используется двоичные. На
# большинстве аппаратных систем в языке Питон для хранения float используется 64 бита, из которых 1 бит уходит на знак,
# 52 бита - на мантиссу и 11 бит - на экспоненту. Это не совсем правда, но достаточно неплохо описывает реальность.
# 52 бита дают около 15-16 десятичных знаков, которые будут храниться точно. 11 бит на экспоненту также накладывает
# ограничения на размерность хранимых чисел (примерно от -1000 до 1000 степени числа 10).
# Любое вещественное число на языке Питон представимо в виде дроби, где в числителе хранится целое число, а в
# знаменателе находится какая-либо степень двойки. Например, 0.125 представимо как 1/8, а 0.1 как
# 3602879701896397/36028797018963968. Несложно заметить, что эта дробь не равно 0.1, т. е. хранение числа 0.1 точно в
# типе float невозможно, как и многих других "красивых" десятичных дробей.
# В целом будет полезно представлять себе вещественное число X как отрезок [X - epsilon; X + epsilon]. Как же определить
# величину epsilon?
# Для этого нужно понять, что погрешность не является абсолютной, т. е. одинаковой для всех чисел, а является
# относительной. Упрощенно, аппаратную погрешность хранения числа X можно оценить как X*2**(-54).
# Чаще всего в задачах входные данные имеют определенную точность. Рассмотрим на примере: заданы два числа X и Y с
# точностью 6 знаков после точки (значит epsilon=5*10**(-7)) и по модулю не превосходящие 10**9. Оценить абсолютную
# погрешность вычисления X * Y. Рассмотрим худший случай, когда X и Y равны 10**9 и отклонились на максимально возможное
# значение epsilon в одну сторону. Тогда результат вычисления будет выглядеть так:
# (X + epsilon) * (Y + epsilon) = XY + (X + Y) * epsilon + epsilon**2
# Величина epsilon**2 пренебрежимо мала, XY - это правильный ответ, а (X + Y) * epsilon - искомое значение абсолютной
# погрешности. Подставим числа и получим:
# 2 * 10**9 * 5 * 10**(-7) = 10**3                               |X - Y| < epsilon
# Абсолютная погрешность вычисления составила 1000 (одну тысячу). Что довольно неожиданно и грустно.
# Таким образом, становится понятно, что нужно аккуратно вычислять значение погрешности для сравнения вещественных чисел
# print(0.1.as_integer_ratio()) - вывод дроби
# Для записи констант или при вводе-выводе может использоваться как привычное представление в виде десятичной дроби,
# например 123.456, так и "инженерная" запись числа, где мантисса записывается в виде вещественного числа с одной цифрой
# до точки и некоторым количеством цифр после точки, затем следует буква ''e'' (или ''E'') и экспонента. Число 123.456 в
# инженерной записи будет выглядеть как 1.23456e2, что означает, что 1.23456 нужно умножить на 10**2. И мантисса и
# экспонента могут быть отрицательными и записываются в десятичной системе.
# Такая запись чисел может применяться при создании вещественных констант, а также при вводе и выводе. Инженерная запись
# удобна для хранения очень больших или очень маленьких чисел, чтобы не считать количество нулей в начале или конце
# числа.
# Если хочется вывести число не в инженерной записи, а с фиксированным количеством знаков после точки, то следует
# воспользоваться методом format, который имеет массу возможностей. Нам нужен только вывод фиксированного количества
# знаков, поэтому воспользуемся готовым рецептом для вывода 25 знаков после десятичной точки у числа 0.1:
# x = 0.1
# print('{0:.25f}'.format(x))
# Если запустить эту программу, то можно легко убедиться в том, что 0.1 + 0.2 не равно 0.3. Хотя можно было надеятся,
# что несмотря на неточное представление, оно окажется одинаково неточным для всех чисел.
# Поэтому при использовании вещественных чисел нужно следовать нескольким простым правилам:
# 1) Если можно обойтись без использования вещественных чисел - нужно это сделать. Вещественные числа проблемные,
# неточные и медленные.
# 2) Два вещественных числа равны между собой, если они отличаются не более чем на epsilon. Число X меньше числа Y,
# если X < Y - epsilon.
# Код для сравнения двух чисел, заданных с точностью 6 знаков после точки, выглядит так:
# x = float(input())
# y = float(input())
# epsilon = 10 ** -6
# if abs(x - y) < epsilon:
#     print('Equal')
# else:
#     print('Not equal')
# При использовании целых и вещественных чисел в одном выражении вычисления производятся в вещественных числах. Тем не
# менее, иногда возникает необходимость преобразовать вещественное число в целое. Для этого можно использовать несколько
# видов функций округления:
# int - округляет в сторону нуля и отрицательные также в сторону нуля (отбрасывет дробную часть)
# round - округляет до ближайшего целого, если ближайших целых несколько (дробная часть равно 0.5), то к чётному
# floor - округляет в меньшую сторону
# ceil - округляет в большую сторону
# Функции floor и ceil находятся в библиотеке math.
# В библиотеке math также есть функция округления trunc, которая работает аналогично int.




#######################################4########################################################33

# Вызовы функций из функции
# Функцию подсчета факториала можно использовать для подсчета биномиальных коэффициентов (числа сочетаний). Формула для
# подсчета числа сочетаний выглядит так: n! / (k! * (n - k)!).
# Если бы мы не пользовались функциями, то нам потребовалось бы три раза записать почти одно и то же. С помощью функций
# вычисление выглядит намного проще:
# def factorial(num):
#     fact = 1
#     i = 2
#     while i <= num:
#         fact *= i
#         i += 1
#     return fact
# def binomial(n, k):
#     return factorial(n) // (factorial(k) * factorial(n - k))
# n, k = int(input()), int(input())  # n > k
# print(binomial(n, k))






###################################5#############################################################################

# Напишите программу, которая по данному числу n от 1 до 9 выводит на экран n флагов. Изображение одного флага имеет
# размер 4×4 символов, между двумя соседними флагами также имеется пустой (из пробелов) столбец. Разрешается вывести
# пустой столбец после последнего флага. Внутри каждого флага должен быть записан его номер — число от 1 до n.
# Формат ввода -  Вводится натуральное число.
# Формат вывода -  Выведите ответ на задачу.
# a = int(input())
# print('+___ ' * a)
# for i in range(1, a + 1):
#     print('|' + str(i) + ' /', end=' ')
# print()
# print('|__\\ ' * a)
# print('|    ' * a)

# Напишите программу, которая находит в массиве элемент, самый близкий по величине к  данному числу.
# Формат ввода - В первой строке задается одно натуральное число N, не превосходящее 1000 – размер массива.  Во второй
# строке содержатся N чисел – элементы массива (целые числа, не превосходящие по модулю 1000).  В третьей строке
# вводится одно целое число x, не превосходящее по модулю 1000.
# Формат вывода - Вывести значение элемента массива, ближайшее к x. Если таких чисел несколько, выведите любое из них.
# n = int(input())
# a = list(map(int, input().split()))
# x, b = int(input()), 1000
# if a[0] < 0:
#     b = -b
# for i in a:
#     if abs(i - x) < abs(b - x):
#         b = i
# print(b)

# Переставьте соседние элементы списка (A[0] c A[1],A[2] c A[3] и т.д.).Если элементов нечетное число, то последний
# элемент остается на своем месте.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
# a = list(map(int, input().split()))
# b = []
# for i in range(0, len(a), 2):
#     if len(a) - i != 1:
#         b.extend([a[i + 1], a[i]])
#     if len(a) - i == 1:
#         b.append(a[i])
# print(*b)

# Даны числа a, b, c, d, e. Подсчитайте количество таких целых чисел от 0 до 1000 (включительно), которые являются
# корнями уравнения (ax³+bx²+cx+d)/(x-e)=0, и выведите их количество.
# Формат ввода - Вводятся целые числа a, b, c, d и e.
# Формат вывода - Выведите ответ на задачу.
# a = int(input())
# b = int(input())
# c = int(input())
# d = int(input())
# e = int(input())
# s = 0
# for i in range(1001):
#     if i != e:
#         if (a * i ** 3 + b * i ** 2 + c * i + d) / (i - e) == 0:
#             s += 1
# print(s)

# Дан список, заполненный произвольными целыми числами. Найдите в этом списке два числа, произведение которых
# максимально. Выведите эти числа в порядке неубывания.
# Решение должно иметь сложность O(n), где n - размер списка. То есть сортировку использовать нельзя.
# a = list(map(int, input().split()))
# max_1, max_2 = 0, 0
# min_1, min_2 = None, None
# for i in a:
#     if i > 0:
#         if i > max_1:
#             max_1 = i
#             if max_1 > max_2:
#                 max_1, max_2 = max_2, max_1
#     if i < 0:
#         if min_1 is None:
#             min_1 = i
#         elif min_2 is None:
#             min_2 = i
#             if min_1 > min_2:
#                 min_1, min_2 = min_2, min_1
#         elif i < min_2:
#             min_2 = i
#             if min_1 > min_2:
#                 min_1, min_2 = min_2, min_1
# if len(a) != 1:
#     if min_2 is not None:
#         if max_1 * max_2 <= min_1 * min_2:
#             print(min_1, min_2)
#         else:
#             print(max_1, max_2)
#     else:
#         if min_1 is not None and len(a) == 2:
#             print(min_1, max_2)
#         else:
#             print(max_1, max_2)

# В данном списке из n≤10⁵ целых чисел найдите три числа,произведение которых максимально.
# Решение должно иметь сложность O(n), где n - размер списка. То есть сортировку использовать нельзя.
# Выведите три искомых числа в любом порядке.
# a = list(map(int, input().split()))
# max_1, max_2, max_3 = 0, 0, 0
# min_1, min_2 = None, None
# min_11, min_22, min_33 = None, None, None
# count_plus, count_minus = 0, 0
# for i in a:
#     if i >= 0:
#         count_plus += 1
#         if i > max_1:
#             max_1 = i
#             if max_1 > max_2:
#                 max_1, max_2 = max_2, max_1
#             if max_2 > max_3:
#                 max_2, max_3 = max_3, max_2
#     if i < 0:
#         count_minus += 1
#         if min_1 is None:
#             min_1 = i
#             min_11 = i
#         elif min_2 is None:
#             min_2 = i
#             min_22 = i
#             if min_1 > min_2:
#                 min_1, min_2 = min_2, min_1
#         elif i < min_2:
#             min_2 = i
#             if min_1 > min_2:
#                 min_1, min_2 = min_2, min_1
#         if count_minus == 3:
#             min_33 = i
#             if min_33 > min_22:
#                 min_22, min_33 = min_33, min_22
#             if min_22 > min_11:
#                 min_22, min_11 = min_11, min_22
#             if min_11 > min_33:
#                 min_33, min_11 = min_11, min_33
#         elif i > min_11 and count_minus > 2:
#             min_11 = i
#             if min_33 > min_22:
#                 min_22, min_33 = min_33, min_22
#             if min_22 > min_11:
#                 min_22, min_11 = min_11, min_22
#             if min_11 > min_33:
#                 min_33, min_11 = min_11, min_33
# if len(a) > 2:
#     if count_minus >= 2 and count_plus > 0:
#         if max_1 * max_2 * max_3 <= min_1 * min_2 * max_3:
#             print(max_3, min_2, min_1)  # +
#         else:
#             print(max_3, max_2, max_1)  # +
#     elif count_minus > 2 and count_plus == 0:
#         print(min_11, min_22, min_33)
#     elif count_minus == 1 and count_plus == 2:  # +
#         print(max_3, max_2, min_1)
#     elif count_minus <= 1 and count_plus > 2:
#         print(max_3, max_2, max_1)  # +

# Дан список чисел. Посчитайте, сколько в нем пар элементов, равных друг другу. Считается, что любые два элемента,
# равные друг другу образуют одну пару, которую необходимо посчитать.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
# a = list(map(int, input().split()))
# k = 0
# for i in range(len(a)):
#     k += a[i + 1:].count(a[i])
# print(k)

# Дан список. Выведите те его элементы, которые встречаются в списке только один раз. Элементы нужно выводить в том
# порядке, в котором они встречаются в списке.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
# a = list(map(int, input().split()))
# for i in range(len(a)):
#     if a.count(a[i]) == 1:
#         print(a[i], end=' ')

# Известно, что на доске 8×8 можно расставить 8 ферзей так, чтобы они не били друг друга. Вам дана расстановка 8 ферзей
# на доске, определите, есть ли среди них пара бьющих друг друга.
# Формат ввода - Программа получает на вход восемь пар чисел, каждое число от 1 до 8 - координаты 8 ферзей.
# Формат вывода - Если ферзи не бьют друг друга, выведите слово NO, иначе выведите YES.
# pos_list = []
# my_input = 'NO'
# for _ in range(8):
#     pos = list(map(int, input().split()))
#     pos_list.append(pos)
#     for i, pos in enumerate(pos_list):
#         for pos_next in pos_list[i + 1:]:
#             if abs(pos[0] - pos_next[0]) == abs(pos[1] - pos_next[1])\
#                     or pos[0] == pos_next[0] or pos[1] == pos_next[1]:
#                 my_input = 'YES'
#                 break
# print(my_input)

# Дан список целых чисел. Требуется “сжать” его, переместив все ненулевые элементы в левую часть списка, не меняя их
# порядок, а все нули - в правую часть. Порядок ненулевых элементов изменять нельзя, дополнительный список использовать
# нельзя, задачу нужно выполнить за один проход по списку. Распечатайте полученный список.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
# data_list = list(map(int, input().split()))
# j = 0
# for i in range(len(data_list)):
#     if data_list[i] != 0:
#         data_list[i], data_list[j] = data_list[j], data_list[i]
#         j += 1
# print(*data_list)

# Дан список. Не изменяя его и не используя дополнительные списки, определите, какое число в этом списке встречается
# чаще всего. Если таких чисел несколько, выведите любое из них.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
# data_list = list(map(int, input().split()))
# count, my_input = 0, 0
# for element in data_list:
#     if count < data_list.count(element):
#         count = data_list.count(element)
#         my_input = element
# print(my_input)

####



#######################6#################################

# Даны два целочисленных списка A и B, упорядоченных по неубыванию. Объедините их в один упорядоченный список С (то
# есть он должен содержать len(A)+len(B) элементов). Решение оформите в виде функции merge(A, B), возвращающей новый
# список. Алгоритм должен иметь сложность O(len(A)+len(B)). Модифицировать исходные списки запрещается. Использовать
# функцию sorted и метод sort запрещается.
# Формат ввода - Программа получает на вход два неубывающих списка, каждый в отдельной строке.
# Формат вывода - Программа должна вывести последовательность неубывающих чисел, полученных объединением двух данных
# списков.
# A = list(map(int, input().split()))
# B = list(map(int, input().split()))
# def merge(A, B):
#     C = []
#     count_a, count_b, end_a, end_b = 0, 0, False, False
#     while not end_a or not end_b:
#         if not end_b and (A[count_a] >= B[count_b] or
#                           end_a and count_a == len(A) - 1):
#             C.append(B[count_b])
#             if count_b < len(B) - 1:
#                 count_b += 1
#             else:
#                 end_b = True
#         if not end_a and (A[count_a] <= B[count_b] or
#                           end_b and count_b == len(B) - 1):
#             C.append(A[count_a])
#             if count_a < len(A) - 1:
#                 count_a += 1
#             else:
#                 end_a = True
#     return C
# print(*merge(A, B))

# Даны два списка, упорядоченных по возрастанию (каждый список состоит из различных элементов).
# Найдите пересечение множеств элементов этих списков, то есть те числа, которые являются элементами обоих списков.
# Алгоритм должен иметь сложность O(len(A)+len(B)).
# Решение оформите в виде функции Intersection(A, B). Функция должна возвращать список пересечения данных списков в
# порядке возрастания элементов. Модифицировать исходные списки запрещается.
# Формат ввода - Программа получает на вход два возрастающих списка, каждый в отдельной строке.
# Формат вывода - Программа должна вывести последовательность возрастающих чисел, являющихся элементами обоих списков.
# A = list(map(int, input().split()))
# B = list(map(int, input().split()))
# def Intersection(A, B):
#     C = []
#     count_a, count_b, end_a, end_b = 0, 0, False, False
#     while not end_a and not end_b:
#         # print(count_a, count_b, C)
#         if A[count_a] == B[count_b]:
#             C.append(A[count_a])
#         if not end_b and (A[count_a] >= B[count_b] or
#                           end_a and count_a == len(A) - 1):
#             # C.append(B[count_b])
#             if count_b < len(B) - 1:
#                 count_b += 1
#             else:
#                 end_b = True
#         elif not end_a and (A[count_a] <= B[count_b] or
#                             end_b and count_b == len(B) - 1):
#             # C.append(A[count_a])
#             if count_a < len(A) - 1:
#                 count_a += 1
#             else:
#                 end_a = True
#     return C
# print(*Intersection(A, B))

# В обувном магазине продается обувь разного размера. Известно, что одну пару обуви можно надеть на другую, если она
# хотя бы на три размера больше. В магазин пришел покупатель.Требуется определить, какое наибольшее количество пар обуви
# сможет предложить ему продавец так, чтобы он смог надеть их все одновременно.
# Формат ввода - Сначала вводится размер ноги покупателя (обувь меньшего размера он надеть не сможет), в следующей
# строке — размеры каждой пары обуви в магазине через пробел. Размер — натуральное число, не превосходящее 100.
# Формат вывода - Выведите единственное число — максимальное количество пар обуви, которое сможет надеть покупатель.
# n = int(input())
# number_list = list(map(int, input().split()))
# number_list.sort()
# count, memory = None, None
# for element in number_list:
#     if n <= element:
#         if count is None:
#             count = 1
#             memory = element
#         if element - memory >= 3:
#             count += 1
#             memory = element
#
# print(count if count is not None else 0)

# Напишите программу, которая по заданной информации о пользователях и свободному объему на архивном диске определит
# максимальное число пользователей, чьи данные можно поместить в архив.
# Формат ввода - Программа получает на вход в одной строке число S – размер свободного места на диске (натуральное, не
# превышает 10000), и число N – количество пользователей (натуральное, не превышает 100), после этого идет N чисел
# - объем данных каждого пользователя (натуральное, не превышает 1000), записанных каждое в отдельной строке.
# Формат вывода - Выведите наибольшее количество пользователей, чьи данные могут быть помешены в архив.
# free_place, n = list(map(int, input().split()))
# users_places, volume = [], 0
# for _ in range(n):
#     users_places.append(int(input()))
# for i, user_place in enumerate(sorted(users_places)):
#     volume += user_place
#     if volume == free_place:
#         print(i + 1)
#         break
#     elif volume > free_place:
#         print(i)
#         break
# else:
#     print(n)

# Штаб гражданской обороны Тридесятой области решил обновить план спасения на случай ядерной атаки. Известно, что все
# n селений Тридесятой области находятся вдоль одной прямой дороги. Вдоль дороги также расположены m бомбоубежищ, в
# которых жители селений могут укрыться на случай ядерной атаки.
# Чтобы спасение в случае ядерной тревоги проходило как можно эффективнее, необходимо для каждого селения определить
# ближайшее к нему бомбоубежище.
# Формат ввода - В первой строке вводится число n - количество селений (1 <= n <= 100000). Вторая строка содержит n
# различных целых чисел, i-е из этих чисел задает расстояние от начала дороги до i-го селения. В третьей строке входных
# данных задается число m - количество бомбоубежищ (1 <= m <= 100000). Четвертая строка содержит m различных целых
# чисел, i-е из этих чисел задает расстояние от начала дороги до i-го бомбоубежища. Все расстояния положительны и не
# превышают 10⁹. Селение и убежище могут располагаться в одной точке.
# Формат вывода - Выведите  n чисел - для каждого селения выведите номер ближайшего к нему бомбоубежища. Бомбоубежища
# пронумерованы от 1 до m в том порядке, в котором они заданы во входных данных.
# n_villages = int(input())
# resurs_keys = []
# for i, value in enumerate(map(int, input().split())):
#     resurs_keys.append((value, i))
# resurs_keys.sort()
# n_bomb_shelter = int(input())
# bomb_shelter = []
# for i, value in enumerate(map(int, input().split())):
#     bomb_shelter.append((value, i))
# bomb_shelter.sort()
# list_out, j = [None] * len(resurs_keys), 0
# for i in range(len(resurs_keys)):
#     if len(bomb_shelter) != 1:
#         while True:
#             if abs(resurs_keys[i][0] - bomb_shelter[j][0]) < \
#                     abs(resurs_keys[i][0] - bomb_shelter[j + 1][0]):
#                 list_out[resurs_keys[i][1]] = bomb_shelter[j][1] + 1
#                 break
#             elif len(bomb_shelter) == j + 2:
#                 list_out[resurs_keys[i][1]] = bomb_shelter[j + 1][1] + 1
#                 break
#             elif j < len(bomb_shelter) - 2:
#                 j += 1
#     else:
#         list_out[resurs_keys[i][1]] = bomb_shelter[j][1] + 1
# print(*list_out)

# В олимпиаде по информатике принимало участие несколько человек.
# Определите и выведите средние баллы участников олимпиады в 9 классе, в 10 классе, в 11 классе.
# Входные данные
# Информация о результатах олимпиады записана в файле, каждая строка которого имеет вид:
# фамилия имя класс балл.
# Фамилия и имя — текстовые строки, не содержащие пробелов. Класс - одно из трех чисел 9, 10, 11. Балл - целое число от
# 0 до 100.
# В этой задаче файл необходимо считывать построчно, не сохраняя содержимое файла в памяти целиком.
# Выходные данные
# Выведите три числа: средние баллы по 9 классу, по 10 классу, по 11 классу. Входной файл в кодировке utf-8
# (используйте open('input.txt', 'r', encoding='utf-8')).
# import sys
# count_a, count_b, count_c, a, b, c = 0, 0, 0, 0, 0, 0
# for line in sys.stdin:
#     s = line.split()
#     if s[2] == '9':
#         a += float(s[3])
#         count_a += 1
#     elif s[2] == '10':
#         b += float(s[3])
#         count_b += 1
#     elif s[2] == '11':
#         c += float(s[3])
#         count_c += 1
# print(round(a / count_a, 7), round(b / count_b, 7), round(c / count_c, 7))

# Известно, что фамилии всех участников — различны. Сохраните в массивах список всех участников и выведите его,
# отсортировав по фамилии в лексикографическом порядке. При выводе указываете фамилию, имя участника и его балл.
# Используйте для ввода и вывода файлы input.txt и output.txt с указанием кодировки utf8. Например, для чтения откройте
# файл с помощью open('input.txt', 'r', encoding='utf8').
# Входные данные - Строки вида "Фамилия Имя НомерШколы Балл".
# Выходные данные - Строки вида "Фамилия Имя Балл", отсортированные по фамилии.
# file = []
# with open('input.txt', 'r', encoding='utf8') as input_file, \
#         open('output.txt', 'w', encoding='utf8') as w:
#     for data in input_file.readlines():
#         s = data.split()
#         file.append(input_file'{s[0]} {s[1]} {s[3]}')
#     file.sort()
#     contents = '\n'.join(file)
#     w.write(contents)

# Дан список из N (N≤2*10⁵) элементов, которые принимают целые значения от 0 до 100 (100 включая).
# Отсортируйте этот список в порядке неубывания элементов. Выведите полученный список.
# Решение оформите в виде функции CountSort(A), которая модифицирует передаваемый ей список. Использовать встроенные
# функции сортировки нельзя.
# def CountSort(A):
#     count_list, out_list = [0] * 101, []
#     for i in A:
#         count_list[i] += 1
#     for number in range(len(count_list)):
#         if count_list[number]:
#             out_list.extend([str(number)] * count_list[number])
#     return out_list
# in_list = list(map(int, input().split()))
# print(*CountSort(in_list))

# При изготовлении клавиатуры изначально для каждой клавиши задается количество нажатий, которое она должна выдерживать.
# Если знать эти величины для используемой клавиатуры, то для определенной последовательности нажатых клавиш можно
# определить, какие клавиши в процессе их использования сломаются, а какие — нет.
# Требуется написать программу, определяющую, какие клавиши сломаются в процессе заданного варианта эксплуатации
# клавиатуры.
# Формат ввода - Первая строка входных данных содержит целое число n (1≤n≤1000) — количество клавиш на клавиатуре.
# Вторая строка содержит n целых чисел —с₁, с₂, … , сn, где сᵢ (1≤cᵢ≤100000) — количество нажатий,выдерживаемых i-ой
# клавишей. Третья строка содержит целое число k (1≤k≤100000) — общее количество нажатий клавиш, и последняя строка
# содержит k целых чисел pj (1≤pj≤n) — последовательность нажатых клавиш.
# Формат вывода - Программа должна вывести n строк, содержащих информацию об исправности клавиш. Если i-я клавиша
# сломалась, то i-ая строка должна содержать слово YES, если же клавиша работоспособна — слово NO.
# number_keys = int(input())
# resurs_keys = []
# for i, value in enumerate(map(int, input().split()), 1):
#     resurs_keys.append((i, value))
# pressing_count = int(input())
# pressing_keys = list(map(int, input().split()))
# count_list = [0] * (number_keys + 1)
# for i in pressing_keys:
#     count_list[i] += 1
# for element in resurs_keys:
#     if element[1] >= count_list[element[0]]:
#         print('NO')
#     else:
#         print('YES')

# В олимпиаде по информатике принимало участие несколько человек. Победителем олимпиады становится человек, набравший
# больше всех баллов. Победители определяются независимо по каждому классу. Определите количество баллов, которое набрал
# победитель в каждом классе. Гарантируется, что в каждом классе был хотя бы один участник.
# Формат ввода - Информация о результатах олимпиады записана в файле, каждая строка которого имеет вид:фамилия имя класс
# балл.
# Фамилия и имя — текстовые строки, не содержащие пробелов. Класс - одно из трех чисел 9, 10, 11. Балл - целое число от
# 0 до 100.
# В этой задаче файл необходимо считывать построчно, не сохраняя содержимое файла в памяти целиком.
# Формат вывода - Выведите три числа: баллы победителя олимпиады по 9 классу, по 10 классу, по 11 классу. Входной файл
# в кодировке utf-8 (В Python используйте open('input.txt', 'r', encoding='utf-8')).
# import sys
# max_9, max_10, max_11 = 0, 0, 0
# for line in sys.stdin:
#     s = line.split()
#     if s[2] == '9':
#         if max_9 < int(s[3]):
#             max_9 = int(s[3])
#     elif s[2] == '10':
#         if max_10 < int(s[3]):
#             max_10 = int(s[3])
#     elif s[2] == '11':
#         if max_11 < int(s[3]):
#             max_11 = int(s[3])
# print(max_9, max_10, max_11)

# В олимпиаде участвовало N человек. Каждый получил определенное количество баллов, при этом оказалось, что у всех
# участников разное число баллов. Упорядочите список участников олимпиады в порядке убывания набранных баллов.
# Формат ввода - Программа получает на вход число участников олимпиады N. Далее идет N строк, в каждой строке записана
# фамилия участника, затем, через пробел, набранное им количество баллов.
# Формат вывода - Выведите список участников (только фамилии) в порядке убывания набранных баллов.
# n, my_list = int(input()), []
# for i in range(n):
#     surname, score = input().split()
#     my_list.append((int(score), surname))
# for element in sorted(my_list, reverse=True):
#     print(element[1])

# В условиях предыдущей задачи определите количество школьников, ставших победителями в каждом классе. Победителями
# объявляются все, кто набрал наибольшее число баллов по данному классу. Гарантируется, что в каждом классе был хотя бы
# один участник.
# Формат вывода - Выведите три числа: количество победителей олимпиады по 9 классу, по 10 классу, по 11 классу.
# import sys
# max_9, max_10, max_11 = 0, 0, 0
# prev_max_9, prev_max_10, prev_max_11 = 0, 0, 0
# for line in sys.stdin:
#     s = line.split()
#     if s[2] == '9':
#         if max_9 < int(s[3]):
#             max_9 = int(s[3])
#             prev_max_9 = 1
#         elif max_9 == int(s[3]):
#             prev_max_9 += 1
#     elif s[2] == '10':
#         if max_10 < int(s[3]):
#             max_10 = int(s[3])
#             prev_max_10 = 1
#         elif max_10 == int(s[3]):
#             prev_max_10 += 1
#     elif s[2] == '11':
#         if max_11 < int(s[3]):
#             max_11 = int(s[3])
#             prev_max_11 = 1
#         elif max_11 == int(s[3]):
#             prev_max_11 += 1
# print(prev_max_9, prev_max_10, prev_max_11)

# Для поступления в вуз абитуриент должен предъявить результаты трех экзаменов в виде ЕГЭ, каждый из них оценивается
# целым числом от 0 до 100 баллов. При этом абитуриенты, набравшие менее 40 баллов (неудовлетворительную оценку) по
# любому экзамену из конкурса выбывают. Остальные абитуриенты участвуют в конкурсе по сумме баллов за три экзамена.
# В конкурсе участвует N человек, при этом количество мест равно K. Определите проходной балл, то есть такое количество
# баллов, что количество участников, набравших столько или больше баллов не превосходит K, а при добавлении к ним
# абитуриентов, набравших наибольшее количество баллов среди непринятых абитуриентов, общее число принятых абитуриентов
# станет больше K.
# Формат ввода - Программа получает на вход количество мест K. Далее идут строки с информацией об абитуриентах, каждая
# из которых состоит из имени (текстовая строка содержащая произвольное число пробелов) и трех чисел от 0 до 100,
# разделенных пробелами.
# спользуйте для ввода файл input.txt с указанием кодировки utf8 (для создания такого файла на своем компьютере в
# программе Notepad++ следует использовать кодировку UTF-8 без BOM).
# Формат вывода - Программа должна вывести проходной балл в конкурсе. Выведенное значение должно быть минимальным баллом
# который набрал абитуриент, прошедший по конкурсу.
# Также возможны две ситуации, когда проходной балл не определен.
# Если будут зачислены все абитуриенты, не имеющие неудовлетворительных оценок, программа должна вывести число 0.
# Если количество имеющих равный максимальный балл абитуриентов больше чем K, программа должна вывести число 1.
# Используйте для вывода файл output.txt с указанием кодировки utf8.
# file = []
# with open('input.txt', 'r', encoding='utf8') as input_file, \
#         open('output.txt', 'w', encoding='utf8') as w:
#     for data in input_file.readlines():
#         e = data.split()
#         if len(e) == 1:
#             a = int(e[0])
#         else:
#             s = e[-3:]
#             if min(int(s[0]), int(s[1]), int(s[2])) >= 40:
#                 file.append(int(s[0]) + int(s[1]) + int(s[2]))
#     file.sort(reverse=True)
#     if len(file) <= a or a == 0:
#         my_input = '0'
#     elif file.count(file[0]) > a:
#         my_input = '1'
#     elif len(file) > a:
#         if file[a - 1] != file[a]:
#             my_input = str(file[a - 1])
#         else:
#             for i in range(a - 2, -1, -1):
#                 if file[a - 1] != file[i]:
#                     my_input = str(file[i])
#                     break
#     w.write(my_input)

# В олимпиаде по информатике принимало участие N человек. Определите школы, из которых в олимпиаде принимало участие
# больше всего участников. В этой задаче необходимо считывать данные построчно, не сохраняя в памяти данные обо всех
# участниках, а только подсчитывая число участников для каждой школы.
# Формат ввода - Информация о результатах олимпиады записана в файле, каждая из строк которого имеет вид:
# фамилия имя школа балл
# Фамилия и имя — текстовые строки, не содержащие пробелов. Школа — целое число от 1 до 99. Балл — целое число от 0 до
# 100.
# Формат вывода - Выведите номера этих школ в порядке возрастания.
# import sys
# schools = [0] * 101
# for line in sys.stdin:
#     n = int(line.split()[2])
#     schools[n] += 1
# my_input = []
# for i in range(len(schools)):
#     if schools[i] == max(schools):
#         my_input.append(i)
# print(*my_input)

# Зачет проводится отдельно в каждом классе. Победителями олимпиады становятся школьники, которые набрали наибольший
# балл среди всех участников в данном классе.
# Для каждого класса определите максимальный балл, который набрал школьник, не ставший победителем в данном классе.
# Формат вывода - Выведите три целых числа.
# import sys
# max_9, max_10, max_11 = 0, 0, 0
# prev_max_9, prev_max_10, prev_max_11 = 0, 0, 0
# for line in sys.stdin:
#     s = line.split()
#     if s[2] == '9':
#         if max_9 < int(s[3]):
#             max_9, prev_max_9 = int(s[3]), max_9
#         elif prev_max_9 < int(s[3]) < max_9:
#             prev_max_9 = int(s[3])
#     elif s[2] == '10':
#         if max_10 < int(s[3]):
#             max_10, prev_max_10 = int(s[3]), max_10
#         elif prev_max_10 < int(s[3]) < max_10:
#             prev_max_10 = int(s[3])
#     elif s[2] == '11':
#         if max_11 < int(s[3]):
#             max_11, prev_max_11 = int(s[3]), max_11
#         elif prev_max_11 < int(s[3]) < max_11:
#             prev_max_11 = int(s[3])
# print(prev_max_9, prev_max_10, prev_max_11)

# После затянувшегося совещания директор фирмы решил заказать такси, чтобы развезти сотрудников по домам. Он заказал N
# машин — ровно столько, сколько у него сотрудников. Однако когда они подъехали, оказалось, что у каждого водителя такси
# свой тариф за 1 километр.
# Директор знает, какому сотруднику сколько километров от работы до дома (к сожалению, все сотрудники живут в разных
# направлениях, поэтому нельзя отправить двух сотрудников на одной машине). Теперь директор хочет определить, сколько
# придется заплатить за перевозку всех сотрудников. Естественно, директор хочет заплатить как можно меньшую сумму.
# Формат ввода - В первой строке записаны N чисел через пробел, задающих расстояния в километрах от работы до домов
# сотрудников компании. Во второй строке записаны N чисел — тарифы за проезд одного километра в такси.
# Формат вывода - Выведите одно целое число — наименьшую сумму, которую придется заплатить за доставку всех сотрудников.
# distances = list(map(int, input().split()))
# prices = list(map(int, input().split()))
# cost = 0
# distances.sort()
# prices.sort(reverse=True)
# for i in range(len(prices)):
#     cost += distances[i] * prices[i]
# print(cost)

# В Государственную Думу Федерального Собрания Российской Федерации выборы производятся по партийным спискам. Каждый
# избиратель указывает одну партию, за которую он отдает свой голос. В Государственную Думу попадают партии, которые
# набрали не менее 7% от числа голосов избирателей.
# Дан список партий и список голосов избирателей. Выведите список партий, которые попадут в Государственную Думу.
# Формат ввода - В первой строке входного файла написано слово PARTIES:. Далее идет список партий, участвующих в выборах
# Затем идет строка, содержащая слово VOTES:. За ним идут названия партий, за которые проголосовали избиратели, по
# одному названию в строке. Названия могут быть только строками из первого списка.
# Формат вывода - Программа должна вывести названия партий, получивших не менее 7% от числа голосов в том порядке, в
# котором они следуют в первом списке.
# import sys
# list_of_parties, voices = [], []
# PARTIES, VOTES = False, False
# for line in sys.stdin:
#     text = line.strip()
#     if text == 'PARTIES:':
#         PARTIES = True
#     elif text == 'VOTES:':
#         PARTIES = False
#         VOTES = True
#     elif PARTIES:
#         list_of_parties.append(text)
#     elif VOTES:
#         if not voices:
#             voices = [0] * len(list_of_parties)
#         voices[list_of_parties.index(text)] += 1
# for i, number in enumerate(voices):
#     if number / sum(voices) * 100 >= 7:
#         print(list_of_parties[i])

# from sys import stdin
# a, s, p = stdin.readlines(), 0, []
# for i in a:
#     p = [[a[i], 0] for i in range(1, a.index('VOTES:\n'))]
# for i in range(len(p)):
#     p[i][1] = a.count(p[i][0]) - 1
#     s += p[i][1]
# for i in range(len(p)):
#     print(' '.join(p[i][0].split())) if p[i][1] / s * 100 >= 7 else None

# Формат входных данных аналогичен предыдущей задаче. Выведите список всех партий, участвовавших в выборах, отсортировав
# его в порядке убывания количества голосов избирателей, а при равном количестве голосов - в лексикографическом порядке.
# import sys
# list_of_parties, voices = [], []
# PARTIES, VOTES = False, False
# for line in sys.stdin:
#     text = line.strip()
#     if text == 'PARTIES:':
#         PARTIES = True
#     elif text == 'VOTES:':
#         PARTIES = False
#         VOTES = True
#     elif PARTIES:
#         list_of_parties.append(text)
#     elif VOTES:
#         if not voices:
#             voices = [0] * len(list_of_parties)
#         voices[list_of_parties.index(text)] += 1
# for number, name in sorted(zip(voices, list_of_parties),
#                            key=lambda x: (-x[0], x[1])):
#     print(name)

####################################7########################################################

# Аня и Боря любят играть в разноцветные кубики, причем у каждого из них свой набор и в каждом наборе все кубики
# различны по цвету. Однажды дети заинтересовались, сколько существуют цветов таких, что кубики каждого цвета
# присутствуют в обоих наборах. Для этого они занумеровали все цвета случайными числами. На этом их энтузиазм иссяк,
# поэтому вам предлагается помочь им в оставшейся части. Номер любого цвета — это целое число в пределах от 0 до 10⁹.
# Формат ввода
# В первой строке входного файла записаны числа N и M — количество кубиков у Ани и Бори соответственно. В следующих N
# строках заданы номера цветов кубиков Ани. В последних M строках  номера цветов кубиков Бори.
# Формат вывода
# Выведите сначала количество, а затем отсортированные по возрастанию номера цветов таких, что кубики каждого цвета
# есть в обоих наборах, затем количество и отсортированные по возрастанию номера остальных цветов у Ани, потом
# количество и отсортированные по возрастанию номера остальных цветов у Бори.
# import sys
# n, m = None, None
# n_num, m_num = set(), set()
# i = 0
# for line in sys.stdin:
#     s = line.split()
#     if n is None:
#         n, m = int(s[0]),  int(s[1])
#     else:
#         if i < n:
#             n_num.add(int(s[0]))
#             i += 1
#         else:
#             m_num.add(int(s[0]))
#
# print(len(n_num & m_num))
# print(*sorted(n_num & m_num))
# print(len(n_num - (n_num & m_num)))
# print(*sorted(n_num - (n_num & m_num)))
# print(len(m_num - (n_num & m_num)))
# print(*sorted(m_num - (n_num & m_num)))

# Во входном файле (вы можете читать данные из sys.stdin, подключив библиотеку sys) записан текст. Словом считается
# последовательность непробельных символов идущих подряд, слова разделены одним или большим числом пробелов или
# символами конца строки. Определите, сколько различных слов содержится в этом тексте.
# import sys
# words = set()
# for line in sys.stdin:
#     s = line.split()
#     for word in s:
#         words.add(word)
# print(len(words))

# Август и Беатриса играют в игру. Август загадал натуральное число от 1 до n. Беатриса пытается угадать это число, для
# этого она называет некоторые множества натуральных чисел. Август отвечает Беатрисе YES, если среди названных ею чисел
# есть задуманное или NO в противном случае. После нескольких заданных вопросов Беатриса запуталась в том, какие вопросы
# она задавала и какие ответы получила и просит вас помочь ей определить, какие числа мог задумать Август.
# Формат ввода
# Первая строка входных данных содержит число n — наибольшее число, которое мог загадать Август. Далее идут строки,
# содержащие вопросы Беатрисы. Каждая строка представляет собой набор чисел, разделенных пробелами. После каждой строки
# с вопросом идет ответ Августа: YES или NO.  Наконец, последняя строка входных данных содержит одно слово HELP.
# Формат вывода
# Вы должны вывести (через пробел, в порядке возрастания) все числа, которые мог задумать Август.
# import sys
# numbers = set()
# n_max = None
# for line in sys.stdin:
#     s = line.split()
#     if n_max is None:
#         n_max = int(s[0])
#         numbers = set(i for i in range(1, n_max + 1))
#     else:
#         if s == ['HELP']:
#             print(*sorted(numbers))
#             exit()
#         elif s != ['YES'] and s != ['NO']:
#             input_num = set()
#             for number in s:
#                 input_num.add(int(number))
#         elif s == ['YES']:
#             numbers &= input_num
#         elif s == ['NO']:
#             numbers -= input_num

# Август и Беатриса продолжают играть в игру, но Август начал жульничать. На каждый из вопросов Беатрисы он выбирает
# такой вариант ответа YES или NO, чтобы множество возможных задуманных чисел оставалось как можно больше. Например,
# если Август задумал число от 1 до 5, а Беатриса спросила про числа 1 и 2, то Август ответит NO, а если Беатриса
# спросит про 1, 2, 3, то Август ответит YES. Если же Бетриса в своем вопросе перечисляет ровно половину из задуманных
# чисел, то Август из вредности всегда отвечает NO. Наконец, Август при ответе учитывает все предыдущие вопросы Беатрисы
# и свои ответы на них, то есть множество возможных задуманных чисел уменьшается.
# Формат ввода
# Вам дана последовательность вопросов Беатрисы. Приведите ответы Августа на них. Первая строка входных данных содержит
# число n — наибольшее число, которое мог загадать Август. Далее идут строки, содержащие вопросы Беатрисы. Каждая строка
# представляет собой набор чисел, разделенных пробелами. Последняя строка входных данных содержит одно слово HELP.
# Формат вывода
# Для каждого вопроса Беатрисы выведите ответ Августа на этот вопрос. После этого выведите (через пробел, в порядке
# возрастания) все числа, которые мог загадать Август после ответа на всевопросы Беатрисы.
# import sys
# numbers, responses = set(), []
# n_max = None
# for line in sys.stdin:
#     s = line.split()
#     if n_max is None:
#         n_max = int(s[0])
#         numbers = memory = set(i for i in range(1, n_max + 1))
#     else:
#         if s == ['HELP']:
#             for i in responses:
#                 print(i)
#             print(*sorted(numbers))
#             exit()
#         elif s != ['YES'] and s != ['NO']:
#             input_num = set()
#             for number in s:
#                 input_num.add(int(number))
#         if len(input_num & memory) * 2 > len(numbers):
#             numbers &= input_num
#             responses.append('YES')
#         else:
#             numbers -= input_num
#             responses.append('NO')

# Каждый из N школьников некоторой школы знает Mᵢ языков. Определите, какие языки знают все школьники и языки, которые
# знает хотя бы один из школьников.
# Формат ввода
# Первая строка входных данных содержит количество школьников N. Далее идет N чисел Mᵢ, после каждого из чисел идет
# Mᵢ строк, содержащих названия языков, которые знает i-й школьник. Длина названий языков не превышает 1000 символов,
# количество различных языков не более 1000. 1≤N≤1000, 1≤Mᵢ≤500.
# Формат вывода
# В первой строке выведите количество языков, которые знают все школьники. Начиная со второй строки - список таких
# языков. Затем - количество языков, которые знает хотя бы один школьник, на следующих строках - список таких языков.
# n, m_i = int(input()), {input() for _ in range(int(input()))}
# one_language, all_languages = m_i.copy(), m_i.copy()
# for _ in range(1, n):
#     m_i = {input() for _ in range(int(input()))}
#     all_languages |= m_i
#     one_language &= m_i
# for language in [one_language, all_languages]:
#     print(len(language), * language, sep='\n')

# На Новом проспекте для разгрузки было решено пустить два новых автобусных маршрута на разных участках проспекта.
# Известны конечные остановки каждого из автобусов. Определите количество остановок, на  которых можно пересесть с
# одного автобуса на другой.
# Формат ввода
# Вводятся четыре числа, не превосходящие 100, задающие номера конечных остановок. Сначала для первого, потом второго
# автобуса (см. примеры и рисунок).
# Формат вывода
# Ваша программа должна выводить одно число – искомое количество остановок.
# all = tuple(map(int, input().split()))
# bus1 = set(range(min(all[:2]), max(all[:2]) + 1))
# bus2 = set(range(min(all[2:]), max(all[2:]) + 1))
# print(len(bus1 & bus2))

# Политическая жизнь одной страны очень оживленная. В стране действует K политических партий, каждая из которых
# регулярно объявляет национальную забастовку. Дни, когда хотя бы одна из партий объявляет забастовку, при условии, что
# это не суббота или воскресенье (когда и так никто не работает), наносят большой ущерб экономике страны. i-я партия
# объявляет забастовки строго каждые bᵢ дней, начиная с дня с номером aᵢ. То есть i-я партия объявляет забастовки в дни
# aᵢ, aᵢ+bᵢ, aᵢ+2bᵢ и т.д. Если в какой-то день несколько партий объявляет забастовку, то это считается одной
# общенациональной забастовкой. В календаре страны N дней, пронумерованных от 1 до N. Первый день года является
# понедельником, шестой и седьмой дни года — выходные, неделя состоит из семи дней.
# Формат ввода
# Программа получает на вход число дней в году N (1≤N≤10⁶) и число политических партий K (1≤K≤100). Далее идет K строк,
# описывающие графики проведения забастовок.i-я строка содержит числа aᵢ и bᵢ (1≤aᵢ,bᵢ≤N).
# Формат вывода
# Выведите единственное число: количество забастовок, произошедших в течение года.
# Примечания
# Первая партия объявляет забастовки в дни 2, 5, 8, 11, 14, 17. Вторая партия объявляет забастовки в дни 3, 8, 13, 18.
# Третья партия — в дни 9 и 17. Дни номер 6, 7, 13, 14 являются выходными. Таким образом, забастовки пройдут в дни
# 2, 3, 5, 8, 9, 11, 17, 18.
# strike_days = set()
# days, k = map(int, input().split())
# for _ in range(k):
#     a, b = map(int, input().split())
#     for day in range(a, days + 1, b):
#         if day not in strike_days and day % 7 != 6 and day % 7 != 0:
#             strike_days.add(day)
#
# print(len(strike_days))

# Телефонные номера в адресной книге мобильного телефона имеют один из следующих форматов:
# - +7<код><номер>
# - 8<код><номер>
# - <номер>
# где <номер> — это семь цифр, а <код> — это три цифры или три цифры в круглых скобках. Если код не указан, то
# считается, что он равен 495. Кроме того, в записи телефонного номера может стоять знак “-” между любыми двумя цифрами
# (см. пример). На данный момент в адресной книге телефона Васи записано всего три телефонных номера, и он хочет
# записать туда еще один. Но он не может понять, не записан ли уже такой номер в телефонной книге. Помогите ему! Два
# телефонных номера совпадают, если у них равны коды и равны номера. Например, +7(916)0123456 и 89160123456 — это один
# и тот же номер.
# Формат ввода
# В первой строке входных данных записан номер телефона, который Вася хочет добавить в адресную книгу своего телефона.
# В следующих трех строках записаны три номера телефонов, которые уже находятся в адресной книге телефона Васи.
# Гарантируется, что каждая из записей соответствует одному из трех приведенных в условии форматов.
# Формат вывода
# Для каждого телефонного номера в адресной книге выведите YES, если он совпадает с тем телефонным номером,который Вася
# хочет добавить в адресную книгу или NO в противном случае.
# number_save = None
# for _ in range(4):
#     number = input()
#     number_input = ''
#     for symbol in number:
#         if symbol.isdigit():
#             number_input += symbol
#     if len(number_input) == 11:
#         number_input = number_input[-10:]
#     if len(number_input) == 7:
#         number_input = '495' + number_input
#     if number_save is None:
#         number_save = number_input
#     else:
#         if number_save == number_input:
#             print('YES')
#         else:
#             print('NO')

# n_l = []
# for i in range(4):
#     n_l.append(''.join(j for j in input() if j.isdigit()))
#     n_l[i] = "8495" + n_l[i] if len(n_l[i]) == 7 else n_l[i]
# [print(["NO", "YES"][n_l[0][1:] == n_l[i][1:]]) for i in range(1, 4)]

# Дан список стран и городов каждой страны. Затем даны названия городов. Для каждого города укажите, в какой стране он
# находится.
# Формат ввода
# Программа получает на вход количество стран N. Далее идет N строк, каждая строка начинается с названия страны, затем
# идут названия городов этой страны. Название каждого город состоит из одного слова. В следующей строке записано число
# M, далее идут M запросов — названия каких-то M городов, перечисленных выше.
# Формат вывода
# Для каждого из запроса выведите название страны, в котором находится данный город.
# towns_dict = {}
# for _ in range(int(input())):
#     country, towns = input().split(' ', 1)
#     for town in towns.split():
#         if town not in towns_dict:
#             towns_dict[town.strip()] = country.strip()
# for _ in range(int(input())):
#     town = input().strip()
#     if town in towns_dict:
#         print(towns_dict[town])

# Во входном файле (вы можете читать данные из файла input.txt) записан текст. Словом считается последовательность
# непробельных подряд идущих символов. Слова разделены одним или большим числом пробелов или символами конца строки. Для
# каждого слова из этого текста подсчитайте, сколько раз оно встречалось в этом тексте ранее.
# Формат ввода
# Вводится текст.
# Формат вывода
# Выведите ответ на задачу.
# count = {}
# my_input = []
# with open('input.txt') as s:
#     for line in s:
#         my_list = line.split()
#         for word in my_list:
#             if word not in count:
#                 count[word] = 0
#             else:
#                 count[word] += 1
#             my_input.append(count[word])
# print(*my_input)

# Вам дан словарь, состоящий из пар слов. Каждое слово является синонимом к парному ему слову. Все слова в словаре
# различны. Для одного данного слова определите его синоним.
# Формат ввода
# Программа получает на вход количество пар синонимов N. Далее следует N строк, каждая строка содержит ровно два
# слова-синонима. После этого следует одно слово.
# Формат вывода
# Программа должна вывести синоним к данному слову.
# Примечания
# Эту задачу можно решить и без словарей (сохранив все входные данные в списке), но решение со словарем будет более
# простым.
# my_dict = {}
# for _ in range(int(input())):
#     word_1, word_2 = input().split()
#     my_dict[word_1] = word_2
#     my_dict[word_2] = word_1
# print(my_dict[input()])

# Как известно, в США президент выбирается не прямым голосованием, а путем двухуровневого голосования. Сначала
# проводятся выборы в каждом штате и определяется победитель выборов в данном штате. Затем проводятся государственные
# выборы: на этих выборах каждый штат имеет определенное число голосов — число выборщиков от этого штата. На практике,
# все выборщики от штата голосуют в соответствии с результатами голосования внутри штата, то есть на заключительной
# стадии выборов в голосовании участвуют штаты, имеющие различное число голосов. Вам известно за кого проголосовал
# каждый штат и сколько голосов было отдано данным штатом. Подведите итоги выборов: для каждого из участника голосования
# определите число отданных за него голосов.
# Формат ввода
# Каждая строка входного файла содержит фамилию кандидата, за которого отдают голоса выборщики этого штата, затем через
# пробел идет количество выборщиков,отдавших голоса за этого кандидата.
# Формат вывода
# Выведите фамилии всех кандидатов в лексикографическом порядке,затем, через пробел, количество отданных за них голосов.
# import sys
# my_input = {}
# for line in sys.stdin:
#     family, number = line.split()
#     if family not in my_input:
#         my_input[family] = int(number)
#     else:
#         my_input[family] += int(number)
# for family in sorted(my_input):
#     print(family, my_input[family])

# Дан текст. Выведите слово, которое в этом тексте встречается чаще всего. Если таких слов несколько, выведите то,
# которое меньше в лексикографическом порядке.
# Формат ввода
# Вводится текст.
# Формат вывода
# Выведите ответ на задачу.
# import sys
# my_input, my_out = {}, {}
# for line in sys.stdin:
#     my_list = line.split()
#     for word in my_list:
#         if word not in my_input:
#             my_input[word] = 0
#         my_input[word] += 1
# for key, value in my_input.items():
#     if value not in my_out:
#         my_out[value] = []
#     my_out[value].append(key)
# g = sorted(my_out, reverse=True)[0]
# print(sorted(my_out[g])[0])
#
# import sys
#
# my_input = {}
# for line in sys.stdin:
#     my_list = line.split()
#     for word in my_list:
#         my_input[word] = my_input[word] + 1 if word in my_input else 1
# print(my_input)
# print(min(my_input.items(), key=lambda x: (-x[1], x[0]))[0])

# words = dict()
# for i in open('input.txt').read().split():
#     words[i] = words[i] + 1 if i in words else 1
# print(min(words.items(), key=lambda x: (-x[1],x[0]))[0])  # это работает более быстрее, так как вместо сортировки
# # всего словаря ищется только один элемент

# Дан текст. Выведите все слова, встречающиеся в тексте, по одному на каждую строку. Слова должны быть отсортированы по
# убыванию их количества появления в тексте, а при одинаковой частоте появления — в лексикографическом порядке.
# Указание.
# После того, как вы создадите словарь всех слов, вам захочется отсортировать его по частоте встречаемости слова.
# Желаемого можно добиться, если создать список, элементами которого будут кортежи из двух элементов: частота
# встречаемости слова и само слово. Например, [(2, 'hi'), (1, 'what'), (3, 'is')]. Тогда стандартная сортировка будет
# сортировать список кортежей, при этом кортежи сравниваются по первому элементу, а если они равны —то по второму. Это
# почти то, что требуется в задаче.
# Формат ввода - Вводится текст.
# Формат вывода - Выведите ответ на задачу.
# import sys
# my_input = {}
# for line in sys.stdin:
#     my_list = line.split()
#     for word in my_list:
#         my_input[word] = my_input[word] + 1 if word in my_input else 1
# my_out = sorted(my_input.items(), key=lambda x: (-x[1], x[0]))
# for i in my_out:
#     print(i[0])

# В выборах Президента Российской Федерации побеждает кандидат, набравший свыше половины числа голосов избирателей. Если
# такого кандидата нет, то во второй тур выборов выходят два кандидата, набравших наибольшее число голосов.
# Формат ввода
# Каждая строка входного файла содержит имя кандидата, за которого отдал голос один избиратель. Известно, что общее
# число кандидатов не превосходит 20, но в отличии от предыдущих задач список кандидатов явно не задан. Читайте данные
# из файла input.txt с указанием кодировки utf8.
# Формат вывода
# Если есть кандидат, набравший более 50% голосов, программа должна вывести его имя. Если такого кандидата нет,
# программа должна вывести имя кандидата, занявшего первое место, затем имя кандидата, занявшего второе место. Выводите
# данные в файл output.txt с указанием кодировки utf8.
# out_file = open("output.txt", "w", encoding='utf-8')
# input_file = open('input.txt', 'r', encoding='utf-8')
# count, my_input = 0, {}
# for line in input_file:
#     line = line.strip()
#     my_input[line] = my_input[line] + 1 if line in my_input else 1
#     count += 1
# my_out = sorted(my_input.items(), key=lambda x: (-x[1], x[0]))
# print(my_out[0][0], file=out_file)
# if my_out[0][1] * 2 <= count:
#     print(my_out[1][0], file=out_file)
# out_file.close()
# input_file.close()

# outFile = open("output.txt", "w", encoding='utf-8')
# fin = open('input.txt', 'r', encoding='utf-8')
# people = dict()
# count = 0
# for line in fin:
#     people[line.strip()] = people.get(line.strip(), 0) + 1
#     count += 1
# p = sorted(people, key=lambda x: (-people[x], x))
# if people[p[0]] > count / 2:
#     print(p[0], file=outFile)
# else:
#     print(p[0], p[1], sep='\n', file=outFile)
# outFile.close()
# fin.close()

# Необходимо распределить 450 мест между партиями, участвовавших в выборах. Сначала подсчитывается сумма голосов
# избирателей, поданных за каждую партию и подсчитывается сумма голосов, поданных за все партии. Эта сумма делится на
# 450, получается величина, называемая “первое избирательное частное” (смысл первого избирательного частного - это
# количество голосов избирателей, которое необходимо набрать для получения одного места в парламенте). Далее каждая
# партия получает столько мест в парламенте, чему равна целая часть от деления числа голосов за данную партию на первое
# избирательное частное.Если после первого раунда распределения мест сумма количества мест, отданных партиям, меньше 450
# , то оставшиеся места передаются по одному партиям, в порядке убывания дробной части частного от деления числа голосов
# за данную партию на первое избирательное частное. Если же для двух партий эти дробные части равны, то преимущество
# отдается той партии, которая получила большее число голосов.
# Формат ввода
# На вход программе подается список партий, участвовавших в выборах. Каждая строка входного файла содержит название
# партии (строка, возможно, содержащая пробелы), затем, через пробел, количество голосов, полученных данной партией
# – число, не превосходящее 10⁸.
# Формат вывода
# Программа должна вывести названия всех партий и количество голосов в парламенте, полученных данной партией. Названия
# необходимо выводить в том же порядке, в котором они шли во входных данных.
# import sys
# parties, score = {}, 0
# for line in sys.stdin:
#     name = line.strip().split()
#     parties[' '.join(name[:-1])] = int(name[-1])
#     score += int(name[-1])
# part = score / 450
# parties = [[key, int(parties[key] / part), parties[key] / part -
#             int(parties[key] / part)] for key in parties]
# summa = sum(element[1] for element in parties)
# for element in sorted(parties, key=lambda x: (-x[2], -x[1])):
#     if summa < 450:
#         element[1] += 1
#         summa += 1
#     else:
#         break
# print(*[' '.join(map(str, element[:2])) for element in parties], sep='\n')
#
# d, s, h = {}, 0, 450
# with open('input.txt') as in_file:
#     for line in in_file:
#         d[' '.join(line.split()[:-1])] = int(line.split()[-1])
#         s += int(line.split()[-1])
# d = [[m, int(h * d[m] / s), h * d[m] / s - int(h * d[m] / s)] for m in d]
# print(d)
# overall = sum(party[1] for party in d)
# for party in sorted(d, key=lambda x: (-x[2], -x[1])):
#     if overall == h:
#         break
#     party[1], overall = party[1] + 1, overall + 1
# print(*[' '.join(map(str, party[:2])) for party in d], sep='\n')

# Дана база данных о продажах некоторого интернет-магазина. Каждая строка входного файла представляет собой запись вида
# Покупатель товар количество, где
# Покупатель — имя покупателя (строка без пробелов),
# товар — название товара (строка без пробелов),
# количество — количество приобретенных единиц товара.
# Создайте список всех покупателей, а для каждого покупателя подсчитайте количество приобретенных им единиц каждого вида
# товаров.
# Формат ввода - Вводятся сведения о покупках в указанном формате.
# Формат вывода - Выведите список всех покупателей в лексикографическом порядке,после имени каждого покупателя выведите
# двоеточие, затем выведите список названий всех приобретенных данным покупателем товаров в лексикографическом порядке,
# после названия каждого товара выведите количество единиц товара, приобретенных данным покупателем.Информация о каждом
# товаре выводится в отдельной строке.
# import sys
# base = {}
# for line in sys.stdin:
#     family, product, cost = line.strip().split()
#     base.setdefault(family, {})
#     base[family].setdefault(product, 0)
#     base[family][product] += int(cost)
# for family in sorted(base):
#     print(family + ':')
#     for product in sorted(base[family]):
#         print(product, base[family][product])

# Некоторый банк хочет внедрить систему управления счетами клиентов, поддерживающую следующие операции:
# Пополнение счета клиента.
# Снятие денег со счета.
# Запрос остатка средств на счете.
# Перевод денег между счетами клиентов.
# Начисление процентов всем клиентам.
# Вам необходимо реализовать такую систему. Клиенты банка идентифицируются именами (уникальная строка, не содержащая
# пробелов). Первоначально у банка нет ни одного клиента. Как только для клиента проводится операция пополнения, снятия
# или перевода денег, ему заводится счет с нулевым балансом. Все дальнейшие операции проводятся только с этим счетом.
# Сумма на счету может быть как положительной, так и отрицательной, при этом всегда является целым числом.
# Формат ввода
# Входной файл содержит последовательность операций. Возможны следующие операции:
# DEPOSIT name sum - зачислить сумму sum на счет клиента name. Если у клиента нет счета, то счет создается.
# WITHDRAW name sum - снять сумму sum со счета клиента name. Если у клиента нет счета, то счет создается.
# BALANCE name - узнать остаток средств на счету клиента name.
# TRANSFER name1 name2 sum - перевести сумму sum со счета клиента name1 на счет клиента name2. Если у какого-либо
# клиента нет счета, то ему создается счет.
# INCOME p - начислить всем клиентам, у которых открыты счета, p% от суммы счета. Проценты начисляются только клиентам
# с положительным остатком на счету, если у клиента остаток отрицательный, то его счет не меняется. После начисления
# процентов сумма на счету остается целой, то есть начисляется только целое число денежных единиц. Дробная часть
# начисленных процентов отбрасывается.
# Формат вывода
# Для каждого запроса BALANCE программа должна вывести остаток на счету данного клиента. Если же у клиента с
# запрашиваемым именем не открыт счет в банке, выведите ERROR.
# import sys
# base = {}
# for line in sys.stdin:
#     command, family_summa = line.strip().split(' ', 1)
#     if command in ['DEPOSIT', 'WITHDRAW', 'TRANSFER']:
#         family, summa = family_summa.split(' ', 1)
#         base.setdefault(family, 0)
#         if command == 'DEPOSIT':
#             base[family] += int(summa)
#         elif command == 'WITHDRAW':
#             base[family] -= int(summa)
#         elif command == 'TRANSFER':
#             family_2, summa_transfer = summa.split()
#             base.setdefault(family_2, 0)
#             base[family] -= int(summa_transfer)
#             base[family_2] += int(summa_transfer)
#     elif command == 'BALANCE':
#         print(base.get(family_summa, 'ERROR'))
#     elif command == 'INCOME':
#         for key, value in base.items():
#             if value > 0:
#                 base[key] += int(value * (int(family_summa) / 100))

# Учительница задала Пете домашнее задание — в заданном тексте расставить ударения в словах, после чего поручила Васе
# проверить это домашнее задание. Вася очень плохо знаком с данной темой,поэтому он нашел словарь, в котором указано,
# как ставятся ударения в словах. К сожалению, в этом словаре присутствуют не все слова. Вася решил, что в словах,
# которых нет в словаре, он будет считать, что Петя поставил ударения правильно, если в этом слове Петей поставлено
# ровно одно ударение.
# Оказалось, что в некоторых словах ударение может быть поставлено больше, чем одним способом. Вася решил, что в этом
# случае если то, как Петя поставил ударение, соответствует одному из приведенных в словаре вариантов, он будет
# засчитывать это как правильную расстановку ударения, а если не соответствует, то как ошибку. Вам дан словарь, которым
# пользовался Вася и домашнее задание, сданное Петей. Ваша задача — определить количество ошибок,которое в этом задании
# насчитает Вася.
# Формат ввода
# Вводится сначала число N — количество слов в словаре (0≤N≤20000). Далее идет N строк со словами из словаря. Каждое
# слово состоит не более чем из 30 символов. Все слова состоят из маленьких и заглавных латинских букв. В каждом слове
# заглавная ровно одна буква — та, на которую попадает ударение. Слова в словаре расположены в алфавитном порядке. Если
# есть несколько возможностей расстановки ударения в одном и том же слове, то эти варианты в словаре идут в произвольном
# порядке.
# Далее идет упражнение, выполненное Петей. Упражнение представляет собой строку текста, суммарным объемом не более
# 300000 символов. Строка состоит из слов, которые разделяются между собой ровно одним пробелом. Длина каждого слова не
# превышает 30 символов. Все слова состоят из маленьких и заглавных латинских букв (заглавными обозначены те буквы, над
# которыми Петя поставил ударение). Петя мог по ошибке в каком-то слове поставить более одного ударения или не поставить
# ударения вовсе.
# Формат вывода - Выведите количество ошибок в Петином тексте, которые найдет Вася.
# with open('input.txt', 'r', encoding='utf-8') as inf:
#     words, lower_words, error = set(), set(), 0
#     n = int(inf.readline())
#     for _ in range(n):
#         word = inf.readline().strip()
#         words.add(word)
#         lower_words.add(word.lower())
#     for word in inf.readline().split():
#         if word not in words:
#             if word.lower() in lower_words:
#                 error += 1
#             elif word.islower():
#                 error += 1
#             elif sum(map(str.isupper, word)) != 1:
#                 error += 1
# print(error)

# В генеалогическом древе у каждого человека, кроме родоначальника, есть ровно один родитель. Каждом элементу дерева
# сопоставляется целое неотрицательное число, называемое высотой. У родоначальника высота равна 0, у любого другого
# элемента высота на 1 больше, чем у его родителя.Вам дано генеалогическое древо, определите высоту всех его элементов.
# Формат ввода
# Программа получает на вход число элементов в генеалогическом древе N. Далее следует N-1 строка, задающие родителя для
# каждого элемента древа, кроме родоначальника.Каждая строка имеет вид имя_потомка имя_родителя.
# Формат вывода
# Программа должна вывести список всех элементов древа в лексикографическом порядке.После вывода имени каждого элемента
# необходимо вывести его высоту.
# Примечания
# Эта задача имеет решение сложности O(n), но вам достаточнонаписать решение сложности O(n²) (не считая сложности
# обращенияк элементам словаря).Пример ниже соответствует приведенному древу рода Романовых.
# def height(child, tree):
#     if child not in tree:
#         return 0
#     return height(tree[child], tree) + 1
#
# with open('input.txt', 'r', encoding='utf-8') as inf:
#     tree, list_all = {}, set()
#     n = int(inf.readline())
#     for _ in range(n - 1):
#         child, parent = inf.readline().split()
#         tree.setdefault(child, parent)
#         list_all.add(child)
#         list_all.add(parent)
# [print(name, height(name, tree)) for name in sorted(list_all)]

# def height(name, d):
#     return 0 if name not in d else height(d[name], d) + 1
# a = {}
# for i in range(1, int(input())):
#     nCh, nPr = input().split()
#     a[nCh] = nPr
# [print(i, height(i, a)) for i in sorted(set(a.keys()) | (set(a.values())))]

##############8########################################################################

# Дан список чисел, который может содержать до 100000 чисел.Определите, сколько в нем встречается различных чисел.
# Формат ввода - Вводится список целых чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
# неразвернутое - print(len(set(map(int, input().split()))))
# print(
#     len(
#         set(
#             map(
#                 int,
#                 input().split()
#             )
#         )
#     )
# )

# Во входном файле (вы можете читать данные из sys.stdin, подключив библиотеку sys) записан текст. Словом считается
# последовательность непробельных символов идущих подряд, слова разделены одним или большим числом пробелов или символами
# конца строки. Определите, сколько различных слов содержится в этом тексте.
# Формат ввода - Вводится текст.
# Формат вывода - Выведите ответ на задачу.
# import sys
# print(
#     len(
#         set(
#             map(
#                 str,
#                 sys.stdin.read().split()
#             )
#         )
#     )
# )

# Выведите значение наименьшего нечетного элемента списка, гарантируется, что хотя бы один нечётный элемент в списке есть.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
# print(
#     min(
#         filter(
#             lambda x: x % 2 == 1,
#             map(
#                 int,
#                 input().split()
#             )
#         )
#     )
# )

# Проверьте, есть ли среди данных N чисел нули.
# Формат ввода - Вводится число N, а затем N чисел.
# Формат вывода - Выведите True, если среди введенных чисел есть хотя бы один нуль, или False в противном случае.
# неразвернутое - print(any(map(lambda x: x == 0, map(lambda x: int(input()), range(int(input()))))))
# print(
#     any(
#         map(
#             lambda x: x == 0,
#             map(
#                 lambda x: int(input()),
#                 range(int(input()))
#             )
#         )
#     )
# )

# print(any(map(lambda x: int(x) == 0, (open('input.txt', 'r', encoding='utf8').read()).split())))
# print('0' in set(open('input.txt').read().split()))
# print(any(map(lambda x: x == '0', map(lambda x: input(), range(int(input()))))))

# На вход подаётся последовательность натуральных чисел длины n≤1000.Посчитайте произведение пятых степеней чисел в
# последовательности.
# Формат ввода - Вводится последовательность чисел
# Формат вывода - Выведите ответ на задачу
# Примечания - Для решения задачи используйте функцию reduce из модуля functools
# неразвернутое - print(reduce(lambda x, y: x * y, map(lambda x: x ** 5, map(int, input().split()))))
# from functools import reduce
# print(
#     reduce(
#         lambda x, y: x * y,
#         map(
#             lambda x: x ** 5,
#             map(
#                 int,
#                 input().split()
#             )
#         )
#     )
# )

# Булева функция XOR (сложение по модулю два) задаётся следующей таблицей истинности:
# xor(0,0)=0
# xor(0,1)=1
# xor(1,0)=1
# xor(1,1)=0
# На вход подаются две последовательности (a₁,…,an) и (b₁,…,bn) из 0 и 1.
# Вычислите последовательность из (c₁,…,cn), где каждая cᵢ=xor(aᵢ,bᵢ).
# Формат ввода - На вход подаются две строки из 0 и 1, разделённых пробелами.
# Первая строка  —  это последовательность (a₁,…,an).
# Вторая строка  —  это последовательность (b₁,…,bn).
# Формат вывода - Выведите последовательность (c₁,…,cn), разделяя каждый элемент пробелом
# Примечания
# Для решения задачи можете использовать функцию zip.
# неразвернутое - print(*map(lambda xy: xy[0] ^ xy[1], zip(map(int, input().split()), map(int, (input().split())))))
# print(
#     *map(
#         lambda xy: xy[0] ^ xy[1],
#         zip(
#             map(
#                 int,
#                 input().split()
#             ),
#             map(
#                 int,
#                 input().split()
#             )
#         )
#     )
# )

# По заданной последовательности: (a₁,…,an)
# посчитайте последовательность частичных сумм: (S₁,…,Sn), где Sk=a₁+a₂+…+ak.
# Формат ввода - Вводится последовательность чисел (a₁,…,an), разделённая пробелами.
# Формат вывода - Выведите последовательность (S₁,…,Sn), разделяя числа пробелами.
# Примечания
# Для решения задачи можно воспользоваться функцией accumulate из модуля itertools.
# неразвернутое - print(*accumulate(map(int, input().split())))
# from itertools import accumulate
# print(
#     *accumulate(
#         map(
#             int,
#             input().split()
#         )
#     )
# )

# По заданному на входе числу 0≤n≤2000 выведите последовательность факториалов: 0!,1!,2!,…,n!
# Формат ввода - Вводится число n.
# Формат вывода - Выведите последовательность факториалов, разделяя числа пробелами
# from itertools import accumulate
# print(
#     *accumulate(
#         map(
#             lambda x: max(x, 1),
#             range(int(input()) + 1)
#         ),
#         lambda x, y: x * y
#     )
# )

# a = [0, 1, 2, 3, 4, 5, 6]
# a = map(lambda x: max(x,1), a)
# print(*accumulate(a, lambda x, y: x * y))
# print(*a)

# По данному числу N выведите все перестановки чисел от 1 до N в лексикографическом порядке.
# Формат ввода - Задано 1 число: N (0<N<10).
# Формат вывода - Необходимо вывести все перестановки чисел от 1 до N в лексикографическом порядке. Перестановки
# выводятся по одной в строке, числа в перестановке выводятся без пробелов.
# неразвернутое - print(*map(lambda xyz: ''.join(map(str, xyz)), permutations(range(1, int(input()) + 1))), sep='\n')
# from itertools import permutations
# print(
#     *map(
#         lambda xyz: ''.join(map(str, xyz)),
#         permutations(
#             range(
#                 1,
#                 int(input()) + 1)
#         )
#     ),
#     sep='\n'
# )

# XOR для произвольного числа аргументов определяется следующим образом:
# xor(a₁,a₂,…,an)= xor(a₁, xor(a₂, xor(a₃,… xor(an))…)
# XOR от n последовательностей A₁,…,An (Aᵢ=Aᵢ₁,…,Aᵢk) равных длин k  —  это последовательность C=xor(A₁,…,An),такая, что:
# cᵢ=xor(A₁ᵢ,…Anᵢ)
# Посчитайте XOR от n последовательностей равной длины k.
# Формат ввода - На первой строке записано число 2≤n≤1000  —  количество последовательностей.
# На последующих n строках записаны последовательности A₁,…,An из 0 и 1, разделённых пробелами равной длины 1≤k≤1000.
# Формат вывода - Выведите последовательность C=xor(A₁,…,An), разделяя числа последовательности пробелами.
# from functools import reduce
# print(
#     *map(
#         lambda x: (
#             reduce(
#                 lambda a, b: (a ^ b),
#                 x
#             )
#         ),
#         zip(
#             *map(
#                 lambda x: map(
#                     int,
#                     input().split()
#                 ),
#                 range(int(input()))
#             )
#         )
#     )
# )

# print(
#     *map(
#         lambda x: (reduce(lambda a, b: (a ^ b), x)),
#         zip(*map(lambda x: map(int, input().split()), range(int(input()))))
#     )
# )
# У нас списки с содержимым строк, а для xor от последовательности нужно бы получить списки столбцов. Похоже, самый
# простой способ это сделать - zip. При чём на вход ему нужно отправить не список строк, а список списков чисел в
# строках: lambda x: map(int, x.split()). Не забываем распаковать map звёздочкой, всё это в zip, красота.
# Ну а теперь список столбцов превращаем в финальный список: lambda x: reduce(lambda a, b: a ^ b, x). Перед принтом
# снова распаковываем map звёздочкой.
# Помогло разобраться, как работает map. В качестве lambda функции можно передавать другой map, в качестве параметров
# несколько списков.
# from sys import stdin
# from functools import reduce
# from operator import xor
#
# print(
#     *reduce(
#         lambda a, b: map(xor, a, b),
#         list(
#             map(
#                 lambda _: map(
#                     int, stdin.readline().strip().split()
#                 ), range(
#                     int(
#                         stdin.readline()
#                     )
#                 )
#             )
#         )
#     )
# )

# Выведите все простые на отрезке [2;n].
# Формат ввода - Вводится число 2≤n≤100000.
# Формат вывода - Выведите все простые числа из отрезка [2,n] в порядке возрастания
# Примечания
# Напомним, что проверить число на то, простое ли оно можно за количество операций порядка √(N). Также напомним, что
# функция math.sqrt работает значительно быстрее, чем (x ** 1/2).
# from math import sqrt
# print(
#     2,
#     *filter(
#         lambda i: all(
#             map(
#                 lambda x: i % x,
#                 range(2, int(sqrt(i)) + 1)
#             )
#         ),
#         range(3, int(input()) + 1, 2)
#     )
# )

################################################################################################################
# Перед началом тараканьих бегов всем болельщикам было предложено сделать по две ставки на результаты бегов. Каждая
# ставка имеет вид "Таракан №A придет раньше, чем таракан №B". Организаторы бегов решили выяснить, могут ли тараканы
# прийти в таком порядке, чтобы у каждого болельщика сыграла ровно одна ставка из двух (то есть чтобы ровно одно из двух
# утверждений каждого болельщика оказалось верным). Считается, что никакие два таракана не могут прийти к финишу
# одновременно.
# Формат ввода
# В первой строке входных данных содержатся два разделенных пробелом натуральных числа: число K, не превосходящее 10,
# - количество тараканов и число N, не превосходящее 100, - количество болельщиков. Все тараканы пронумерованы числами
# от 1 до K. Каждая из следующих N строк содержит 4 натуральных числа A, B, C, D, не превосходящих K, разделенных
# пробелами. Они соответствуют ставкам болельщика "Таракан №A придет раньше, чем таракан №B" и "Таракан №C придет
# раньше, чем таракан №D".
# Формат вывода
# Если завершить бега так, чтобы у каждого из болельщиков сыграла ровно одна из двух ставок, можно, то следует вывести
# номера тараканов в том порядке, в котором они окажутся в итоговой таблице результатов (сначала номер таракана,
# пришедшего первым, затем номер таракана, пришедшего вторым и т. д.) в одну строку через пробел. Если таких вариантов
# несколько, выведите любой из них. Если требуемого результата добиться нельзя, выведите одно число 0.
# Тест 1
# Входные данные:
# 3 2
# 2 1 2 3
# 1 2 3 2
# Вывод программы:
# 3 2 1
#
# Тест 2
# Входные данные:
# 3 4
# 1 2 1 3
# 1 2 3 1
# 1 2 2 3
# 1 2 3 2
# Вывод программы:
# 0
# import itertools
# import operator
#
# print(next(map(lambda a:
#                ' '.join(map(str, a[0])),
#                filter(lambda a: all(map(lambda b: operator.xor(
#                    *map(lambda c: c in itertools.combinations(a[0], 2), b, )),
#                                         a[1])), (
#                           lambda a, b: zip(itertools.permutations(a),
#                                            itertools.repeat(b)))(
#                    *(lambda k, n: (range(1, k + 1),
#                                    tuple(map(lambda i: (i[:2], i[2:]),
#                                              map(lambda _: tuple(
#                                                  map(int, input().split())),
#                                                  range(n)))))
#                      )(*map(int, input().split()))))), 0))

# from itertools import permutations
# from sys import stdin
# from operator import xor
#
# print(
#     *next(
#         map(
#             lambda d:
#             next(
#                 filter(
#                     lambda y:
#                     all(
#                         map(
#                             lambda x:
#                             xor(y.index(x[0]) < y.index(x[1]), y.index(x[2]) < y.index(x[3])),
#                             d[-1])
#                     ),
#                     d[:-1]
#                 ),
#                 [0, ]
#             ),
#
#             map(
#                 lambda j: [
#                     *permutations(range(j, 0, -1), j),
#                     list(map(lambda z: tuple(map(int, z.split())),
#                              stdin.readlines()))
#                 ],
#                 map(int, input().split())
#             )
#
#         ),
#         [0, ]
#     )
# )
# Т.к. во входных данных через map(int, input().split()) идёт и K и N, то у нас будет считаться два permutations. Чтобы
# не использовать второй мы используем next. Следовательно у Вас ошибка в последовательности. next на 9-й строке должен
# быть перед map на 7-й, а lambda d это filter.
#
# И посмотрите на то, что выдаёт map на 23-й строке (кстати не пойму зачем * на 25-й строке). Вы неправильно берёте из
# неё данные.
#
# И по поводу xor, не факт что грейдер импортирует библиотеку operator. Есть встроенный логический оператор, который
# подходит для наших нужд - ^. Используется как обычно: a ^ b.
#####################99999999999999###############################################################################################

# Реализуйте класс Matrix. Он должен содержать:
# Конструктор от списка списков. Гарантируется, что списки состоят из чисел, не пусты и все имеют одинаковый размер.
# Конструктор должен копировать содержимое списка списков, т. е. при изменении списков, от которых была сконструирована
# матрица, содержимое матрицы изменяться не должно.
# Метод __str__, переводящий матрицу в строку. При этом элементы внутри одной строки должны быть разделены знаками
# табуляции, а строки  —  переносами строк. После каждой строки не должно быть символа табуляции и в конце не должно
# быть переноса строки.
# Метод size без аргументов, возвращающий кортеж вида (число строк, число столбцов). Пример теста с участием этого
# метода есть в следующей задаче этой недели.
# from sys import stdin
# class Matrix:
#     def __init__(self, cls):
#         self._cls = [lst[:] for lst in cls]
#
#     def __str__(self):
#         s = ''
#         for i in self._cls:
#             if s:
#                 s += '\n'
#             s += '\t'.join(map(str, i))
#         return s
#
#     def size(self):
#         return len(self._cls), len(self._cls[0])
# exec(stdin.read())
######################################################################################################################

# Добавьте в предыдущий класс следующие методы:
#  __add__, принимающий вторую матрицу того же размера и возвращающий сумму матриц.
#  __mul__, принимающий число типа int или float и возвращающий матрицу, умноженную на скаляр.
#  __rmul__, делающий то же самое, что и __mul__. Этот метод будет вызван в том случае, аргумент находится справа. Для
# реализации этого метода в коде класса достаточно написать __rmul__ = __mul__.
# Иллюстрация:
#  В следующем случае вызовется __mul__: Matrix([[0, 1], [1, 0]) * 10.
#  В следующем случае вызовется __rmul__ (так как у int не определен __mul__ для матрицы справа):
#  10 * Matrix([[0, 1], [1, 0]).
# Разумеется, данные методы не должны менять содержимое матрицы.
# Формат ввода - Как в предыдущей задаче.
# Формат вывода - Как в предыдущей задаче.
# from sys import stdin
# class Matrix:
#     def __init__(self, cls):
#         self.cls = [lst[:] for lst in cls]
#
#     def __str__(self):
#         s = ''
#         for i in self.cls:
#             if s:
#                 s += '\n'
#             s += '\t'.join(map(str, i))
#         return s
#
#     def __add__(self, other):
#         return Matrix([[num + other.cls[j][i] for i, num in enumerate(number)]
#                        for j, number in enumerate(self.cls)])
#
#     def __mul__(self, other):
#         return Matrix([[num * other for num in number]
#                        for number in self.cls])
#
#     __rmul__ = __mul__
#
#     def size(self):
#         return len(self.cls), len(self.cls[0])
# exec(stdin.read())

# from sys import stdin
# from copy import deepcopy
# class Matrix:
#     def __init__(self, matrix):
#         self.matrix = deepcopy(matrix)
#
#     def __str__(self):  # без аргументов
#         return '\n'.join(['\t'.join(map(str, list)) for list in self.matrix])
#
#     def __add__(self, other):
#         return Matrix()
#
#     def size(self):  # без аргументов!
#         return (len(self.matrix), len(self.matrix[0]))
#
#     def __add__(self, other):
#         return Matrix(list(map(
#             lambda x, y: list(map(lambda z, w: z + w, x, y)),
#             self.matrix, other.matrix)))
#
#     def __mul__(self, other):
#         return Matrix([[i * other for i in list] for list in self.matrix])
#
#     __rmul__ = __mul__
# # exec(stdin.read())
# m1 = Matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
# m2 = Matrix([[0, 1, 0], [20, 0, -1], [-1, -2, 0]])
# print(m1 + m2)
# m = Matrix([[1, 1, 0], [0, 2, 10], [10, 15, 30]])
# alpha = 15
# print(m * alpha)
# print(alpha * m)
####################################################################################################################

# Добавьте в программу из предыдущей задачи класс MatrixError, содержащий внутри self поля matrix1 и matrix2 — ссылки на
# матрицы.
# В класс Matrix внесите следующие изменения:
# Добавьте в метод __add__ проверку на ошибки в размере входных данных, чтобы при попытке сложить матрицы разных
# размеров было выброшено исключение MatrixError таким образом, чтобы matrix1 поле MatrixError стало первым аргументом
# __add__ (просто self), а matrix2  —  вторым (второй операнд для сложения).
# Реализуйте метод transpose, транспонирующий матрицу и возвращающую результат (данный метод модифицирует экземпляр
# класса Matrix)
# Реализуйте статический метод transposed, принимающий Matrix и возвращающий транспонированную матрицу. Пример
# статического метода.
# Формат ввода - Как в предыдущей задаче.
# Формат вывода - Как в предыдущей задаче.

# from sys import stdin
#
# class MatrixError(BaseException):
#     def __init__(self, cls, other):
#         self.matrix1 = cls
#         self.matrix2 = other
#
#
# class Matrix:
#     def __init__(self, cls):
#         self.cls = [lst[:] for lst in cls]
#
#     def __str__(self):
#         s = ''
#         for i in self.cls:
#             if s:
#                 s += '\n'
#             s += '\t'.join(map(str, i))
#         return s
#
#     def __add__(self, other):
#         if len(self.cls) == len(other.cls):
#             return Matrix(
#                 [[num + other.cls[j][i] for i, num in enumerate(number)]
#                  for j, number in enumerate(self.cls)])
#
#         else:
#             raise MatrixError(self, other)
#
#     def __mul__(self, other):
#         return Matrix([[num * other for num in number]
#                        for number in self.cls])
#
#     __rmul__ = __mul__
#
#     def size(self):
#         return len(self.cls), len(self.cls[0])
#
#     def transpose(self):
#         if isinstance(self, Matrix):
#             self.cls = [*zip(*self.cls)]
#             return Matrix(self.cls)
#
#     @staticmethod
#     def transposed(cls):
#         return Matrix([*zip(*cls.cls)])
#
# exec(stdin.read())


#
# from sys import stdin
#
# class MatrixError(BaseException):
#     def __init__(self, cls, other):
#         self.matrix1 = cls
#         self.matrix2 = other
#
#
# class Matrix:
#     def __init__(self, cls):
#         self.cls = [lst[:] for lst in cls]
#
#     def __str__(self):
#         s = ''
#         for i in self.cls:
#             if s:
#                 s += '\n'
#             s += '\t'.join(map(str, i))
#         return s
#
#     def __add__(self, other):
#         if len(self.cls) == len(other.cls):
#             return Matrix(
#                 [[num + other.cls[j][i] for i, num in enumerate(number)]
#                  for j, number in enumerate(self.cls)])
#
#         else:
#             raise MatrixError(self, other)
#
#     def __mul__(self, other):
#         return Matrix([[num * other for num in number]
#                        for number in self.cls])
#
#     __rmul__ = __mul__
#
#     def size(self):
#         return len(self.cls), len(self.cls[0])
#
#     def transpose(self):
#         if isinstance(self, Matrix):
#             self.cls = [*zip(*self.cls)]  #  list(map(list, zip(*self.matrix)))
#             return Matrix(self.cls)
#
#     @staticmethod
#     def transposed(cls):
#         return Matrix([*zip(*cls.cls)])
#
# exec(stdin.read())
#######################################################################################################################

# Внесите следующие изменение в предыдущую программу:
# Измените метод __mul__ таким образом, чтобы матрицы можно было умножать как на скаляры, так и на другие матрицы. В
# случае, если две матрицы перемножить невозможно, то тогда выбросьте ошибку MatrixError. Первая матрице в ошибке  —
# это self, вторая  —  это второй операнд умножения.
# Формат ввода - Как в предыдущей задаче.
# Формат вывода - Как в предыдущей задаче.

# from sys import stdin
#
# class MatrixError(BaseException):
#     def __init__(self, cls, other):
#         self.matrix1 = cls
#         self.matrix2 = other
#
#
# class Matrix:
#     def __init__(self, cls):
#         self.cls = [lst[:] for lst in cls]
#
#     def __str__(self):
#         s = ''
#         for i in self.cls:
#             if s:
#                 s += '\n'
#             s += '\t'.join(map(str, i))
#         return s
#
#     def __add__(self, other):
#         if len(self.cls) == len(other.cls):
#             return Matrix(
#                 [[num + other.cls[j][i] for i, num in enumerate(number)]
#                  for j, number in enumerate(self.cls)])
#
#         else:
#             raise MatrixError(self, other)
#
#     def __mul__(self, other):
#         if isinstance(other, int) or isinstance(other, float):
#             return Matrix([[num * other for num in number]
#                            for number in self.cls])
#         elif isinstance(other, Matrix):
#             if self.size()[1] != other.size()[0]:
#                 raise MatrixError(self, other)
#             return Matrix(
#                 list(map(
#                     lambda x: list(
#                         map(
#                             lambda y: sum(map(
#                                 lambda z: z[0] * z[1],
#                                 zip(x, y))
#                             ),
#                             zip(*other.cls))),
#                     zip(*Matrix.transposed(self).cls))
#                 )
#             )
#
#     __rmul__ = __mul__
#
#     def size(self):
#         return len(self.cls), len(self.cls[0])
#
#     def transpose(self):
#         if isinstance(self, Matrix):
#             self.cls = [*zip(*self.cls)]
#             return Matrix(self.cls)
#
#     @staticmethod
#     def transposed(cls):
#         return Matrix([*zip(*cls.cls)])
#
# exec(stdin.read())

# Тест 1
# Входные данные:
# # Task 4 check 1
# mid = Matrix([[1, 0, 0],[0, 1, 0],[0, 0, 1]])
# m1 = Matrix([[3, 2], [-10, 0], [14, 5]])
# m2 = Matrix([[5, 2, 10], [-0.5, -0.25, 18], [-22, -2.5, -0.125]])
# print(mid * m1)
# print(mid * m2)
# print(m2 * m1)
# try:
#     m = m1 * m2
#     print("WA It should be error")
# except MatrixError as e:
#     print(e.matrix1)
#     print(e.matrix2)
#
# Вывод программы:
# 3	2
# -10	0
# 14	5
# 5.0	2.0	10.0
# -0.5	-0.25	18.0
# -22.0	-2.5	-0.125
# 135	60
# 253.0	89.0
# -42.75	-44.625
# 3	2
# -10	0
# 14	5
# 5	2	10
# -0.5	-0.25	18
# -22	-2.5	-0.125
#
#
#
# Тест 2
# Входные данные:
# # Task 4 check 2
# mid = Matrix([[1, 0, 0],[0, 1, 0],[0, 0, 1]])
# m1 = Matrix([[3, 2], [-10, 0], [14, 5]])
# m2 = Matrix([[5, 2, 10], [-0.5, -0.25, 18], [-22, -2.5, -0.125]])
# print(0.5 * m2)
# print(m2 * (0.5 * mid * m1))
#
# Вывод программы:
# 2.5	1.0	5.0
# -0.25	-0.125	9.0
# -11.0	-1.25	-0.0625
# 67.5	30.0
# 126.5	44.5
# -21.375	-22.3125
#
#
#
# Тест 3
# Входные данные:
# # Task 4 check 3
# mid = Matrix([[1, 0, 0],[0, 1, 0],[0, 0, 1]])
# m1 = Matrix([[3, 2], [-10, 0], [14, 5]])
# m2 = Matrix([[5, 2, 10], [-0.5, -0.25, 18], [-22, -2.5, -0.125]])
# print(5 * m2)
# print(m2 * (120 * mid * m1))
#
# Вывод программы:
# 25	10	50
# -2.5	-1.25	90
# -110	-12.5	-0.625
# 16200	7200
# 30360.0	10680.0
# -5130.0	-5355.0

# Тест 5
# Task 4 check 5
# m1 = Matrix([[3, 2], [-10, 0], [14, 5]])
# m2 = Matrix([[5, 2, 10], [-0.5, -0.25, 18], [-22, -2.5, -0.125]])
# print(m2 * m1)
# print(Matrix.transposed(m2 * m1))
# print(m1.transpose() * m2.transpose())
# Ответ:
# 135	60
# 253.0	89.0
# -42.75	-44.625
# 135	253.0	-42.75
# 60	89.0	-44.625
# 135	253.0	-42.75
# 60	89.0	-44.625

#
# from sys import stdin
#
# class MatrixError(BaseException):
#     def __init__(self, Mtx, other):
#         self.matrix1 = Mtx
#         self.matrix2 = other
#
#
# class Matrix:
#     def __init__(self, l4l):
#         self.Mtx = [_.copy() for _ in l4l]
#
#     def __str__(self):
#         return '\n'.join(['\t'.join(map(str, self.Mtx[i]))
#                           for i in range(len(self.Mtx))])
#
#     def size(self):
#         return len(self.Mtx), len(self.Mtx[0])
#
#     def __add__(self, other):
#         if self.size() != other.size():
#             raise MatrixError(self, other)
#         return Matrix(list(map(
#             lambda a, b: list(map(
#                 lambda x, y: x + y, a, b)), self.Mtx, other.Mtx)))
#
#     def __mul__(self, other):
#         if isinstance(other, int) or isinstance(other, float):
#             return Matrix([list(map(
#                 lambda x: x * other, self.Mtx[i]))
#                 for i in range(len(self.Mtx))])
#         elif isinstance(other, Matrix):
#             if self.size()[1] != other.size()[0]:
#                 raise MatrixError(self, other)
#             return Matrix(
#                 list(map(
#                         lambda x: list(
#                             map(
#                                 lambda y: sum(map(
#                                     lambda z: z[0] * z[1],
#                                     zip(x, y))
#                                 ),
#                             zip(*other.Mtx))),
#                     zip(*Matrix.transposed(self).Mtx))
#                 )
#             )
#
#     __rmul__ = __mul__
#
#     def transpose(self):
#         self.Mtx = list(map(lambda *args: list(args), *self.Mtx))
#         return Matrix(self.Mtx)
#
#     @staticmethod
#     def transposed(M):
#         return Matrix(list(map(lambda *args: list(args), *M.Mtx)))
#
# exec(stdin.read())
#
#
# def __mul__(self, n):
#     if isinstance(n, list):
#         if len(self.l[0]) != len(n):
#             return MatrixError
#         else:
#             tmp, res = [], [] * len(self.l)
#             for i in range(len(self.l)):
#                 for j in range(len(n[0])):
#                     s = 0
#                     for k in range(len(self.l[0])):
#                         s += self.l[i][k] * n[k][j]
#                     tmp.append(s)
#                 res.append(tmp)
#                 tmp = []
#             return Matrix(res)
#     else:
#         return ([n * j for j in i] for i in self.l)
#######################################################################################################################

# Пусть экземпляр класса Matrix задаёт систему линейных алгебраических уравнений.
# Тогда добавьте в класс метод solve, принимающий вектор-строку свободных членов и возвращающий строку-список, состоящую
# из float  —  решение системы, если оно единственно. Если решений нет или оно не единственно  — выдайте какую-нибудь
# ошибку.
# Формат ввода - Как в предыдущей задаче.
# Формат вывода - Как в предыдущей задаче.

# def solve(self, vector):
#     if self.size()[1] != self.size()[0]:
#         raise Exception("The Matrix is not square!")
#     elif self.size()[1] != len(vector):
#         raise Exception("The Matrix and vector have different length!")
#     helperD = []
#     for i in range(len(vector)):
#         M = Matrix(self.cls)
#         for j in range(len(vector)):
#             M.cls[j][i] = vector[j]
#         helperD.append(Matrix.determinator(M))
#     return list(map(lambda x: x / Matrix.determinator(self), helperD))
#
#
# @staticmethod
# def determinator(M):
#     if M.size()[0] == 2:
#         return M.cls[0][0] * M.cls[1][1] - M.cls[0][1] * M.cls[1][0]
#     elif M.size()[0] == 3:
#         return \
#             M.cls[0][0] * M.cls[1][1] * M.cls[2][2] \
#             + M.cls[2][0] * M.cls[0][1] * M.cls[1][2] \
#             + M.cls[1][0] * M.cls[2][1] * M.cls[0][2] \
#             - M.cls[2][0] * M.cls[1][1] * M.cls[0][2] \
#             - M.cls[0][0] * M.cls[2][1] * M.cls[1][2] \
#             - M.cls[1][0] * M.cls[0][1] * M.cls[2][2]
#     else:
#         raise Exception("Matrix's range more than 3")

# Тест 1
# Входные данные:
# # Task 5 check 1
# m = Matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
# print(m.solve([1,1,1]))
# Вывод программы:
# [1.0, 1.0, 1.0]
#
# Тест 2
# Входные данные:
# # Task 5 check 2
# m = Matrix([[1, 1, 1], [0, 2, 0], [0, 0, 4]])
# print(m.solve([1,1,1]))
# Вывод программы:
# [0.25, 0.5, 0.25]
#
# Тест 3
# Входные данные:
# # Task 5 check 3
# m = Matrix([[1, 1, 1], [0, 1, 2], [0.5, 1, 1.5]])
# try:
#     s = m.solve([1,1,1])
#     print('WA No solution')
# except Exception as e:
#     print('OK')
# Вывод программы:
# OK
#####################################################################################################################

# К программе в предыдущей задаче добавьте класс SquareMatrix  —  наследник Matrix с операцией возведения в степень
# __pow__, принимающей натуральную степень (включая ноль), в которую нужно возвести матрицу. Используйте быстрое
# возведение в степень.
# Формат ввода - Как в предыдущей задаче.
# Формат вывода - Как в предыдущей задаче.
# Возводить в степень можно гораздо быстрее, чем за n умножений! Для этого нужно воспользоваться следующими
# рекуррентными соотношениями: aⁿ = (a²)ⁿ/² при четном n, aⁿ=a⋅aⁿ⁻¹ при нечетном n. Реализуйте алгоритм быстрого
# возведения в степень. Если вы все сделаете правильно,то сложность вашего алгоритма будет O(logn).
# def power(a, n):
#     if n == 0:
#         return 1
#     if n % 2 == 0:
#         return power(a, n/2)**2
#     else:
#         return a*power(a, n-1)
# a = int(input())
# n = int(input())
# print(power(a, n))

# class SquareMatrix(Matrix):
#     def __mul__(self, other):
#         return SquareMatrix(super().__mul__(other).cls)
#
#     def __pow__(self, n):
#         if n in [0, 1]:
#             return self
#         elif n == 2:
#             return self * self
#         if n % 2 != 0:
#             return self * (self ** (n - 1))
#         else:
#             return (self * self) ** (n // 2)
#
# m = SquareMatrix([[1, 1, 0, 0, 0, 0],
#                   [0, 1, 1, 0, 0, 0],
#                   [0, 0, 1, 1, 0, 0],
#                   [0, 0, 0, 1, 1, 0],
#                   [0, 0, 0, 0, 1, 1],
#                   [0, 0, 0, 0, 0, 1]]
#                 )
# print(m)
# print('----------')
# print(m ** 1)
# print('----------')
# print(m ** 2)
# print('----------')
# print(m ** 3)
# print('----------')
# print(m ** 4)
# print('----------')
# print(m ** 5)

# класс полностью ###############################################################################################
from sys import stdin


class MatrixError(BaseException):
    def __init__(self, cls, other):
        self.matrix1 = cls
        self.matrix2 = other


class Matrix:
    def __init__(self, cls):
        self.cls = [lst[:] for lst in cls]

    def __str__(self):
        s = ''
        for i in self.cls:
            if s:
                s += '\n'
            s += '\t'.join(map(str, i))
        return s

    def __add__(self, other):
        if len(self.cls) == len(other.cls):
            return Matrix(
                [[num + other.cls[j][i] for i, num in enumerate(number)]
                 for j, number in enumerate(self.cls)])

        else:
            raise MatrixError(self, other)

    def __mul__(self, other):
        if isinstance(other, int) or isinstance(other, float):
            return Matrix([[num * other for num in number]
                           for number in self.cls])
        elif isinstance(other, Matrix):
            if self.size()[1] != other.size()[0]:
                raise MatrixError(self, other)
            return Matrix(
                list(map(
                    lambda x: list(
                        map(
                            lambda y: sum(map(
                                lambda z: z[0] * z[1],
                                zip(x, y))
                            ),
                            zip(*other.cls))),
                    zip(*Matrix.transposed(self).cls))
                )
            )

    __rmul__ = __mul__

    def size(self):
        return len(self.cls), len(self.cls[0])

    def transpose(self):
        if isinstance(self, Matrix):
            self.cls = [*zip(*self.cls)]
            return Matrix(self.cls)

    @staticmethod
    def transposed(cls):
        return Matrix([*zip(*cls.cls)])

    def solve(self, vector):
        if self.size()[1] != self.size()[0]:
            raise Exception("The Matrix is not square!")
        elif self.size()[1] != len(vector):
            raise Exception("The Matrix and vector have different length!")
        helperD = []
        for i in range(len(vector)):
            M = Matrix(self.cls)
            for j in range(len(vector)):
                M.cls[j][i] = vector[j]
            helperD.append(Matrix.determinator(M))
        return list(map(lambda x: x / Matrix.determinator(self), helperD))

    @staticmethod
    def determinator(M):
        if M.size()[0] == 2:
            return M.cls[0][0] * M.cls[1][1] - M.cls[0][1] * M.cls[1][0]
        elif M.size()[0] == 3:
            return \
                M.cls[0][0] * M.cls[1][1] * M.cls[2][2] \
                + M.cls[2][0] * M.cls[0][1] * M.cls[1][2] \
                + M.cls[1][0] * M.cls[2][1] * M.cls[0][2] \
                - M.cls[2][0] * M.cls[1][1] * M.cls[0][2] \
                - M.cls[0][0] * M.cls[2][1] * M.cls[1][2] \
                - M.cls[1][0] * M.cls[0][1] * M.cls[2][2]
        else:
            raise Exception("Matrix's range more than 3")


class SquareMatrix(Matrix):
    def __mul__(self, other):
        return SquareMatrix(super().__mul__(other).cls)

    def __pow__(self, n):
        if n in [0, 1]:
            return self
        elif n == 2:
            return self * self
        if n % 2 != 0:
            return self * (self ** (n - 1))
        else:
            return (self * self) ** (n // 2)


exec(stdin.read())
