1***словарь печать***ключ - значение: for key, value in notes.items(): print(key, ':', value)___ключ: for key in notes.keys(): print(key)___значение: for value in notes.values(): print(value)
2***словарь создание***пустой словарь: dict_sample = {}___ключи являются целыми числами: dict_sample = {1: 'mango', 2: 'pawpaw'}___с ключами разных типов (только неизменяемые объекты): dict_sample = {'fruit': 'mango', 1: [4, 6, 8]}___явно вызвав метод dict(): dict_sample = dict({1:'mango', 2:'pawpaw'})___с помощью последовательности: dict_sample = dict([(1,'mango'), (2,'pawpaw')])___могут быть вложенными: dict_sample = {___1: {'student1': 'Nicholas', 'student2': 'John', 'student3': 'Mercy'}, ___2: {'course1': 'Computer Science', 'course2': 'Mathematics', 'course3': 'Accounting'}___}___создание копии словаря: x = dict.copy() -> изменения в скопированном словаре не затрагивают оригинальный словарь___с указанными ключами и значениями: dict_sample.fromkeys(keys, value) -> keys = ('1, 2, 3'), value = 25 (если одинаковое значение), если value нет - то None___поменять местами ключи и значения в словаре: {v: k for k, v in a.items()}
3***словарь доступ***нужно передать ключ в квадратных скобках []: x = dict_sample["model"] -> выдаст ошибку при отсутствии такого ключа___функция get() (нет ошибки при отсутствии ключа): x = dict_sample.get("model"), x = dict_sample.get('model', 'return') -> нет ключа - вернет значение 'return',___функция .setdefault(): dict_sample.setdefault('model', 'return') -> нет ключа - запишет ключ 'model' и значение 'return' в словарь
4***словарь удаление***удаление элемента del dict_sample['year'] или dict_sample.pop('year') -> с конкретным ключом, dict_sample.popitem() -> удаляет последний элемент в словаре___очистка или удаление словаря: dict_sample.clear() -> удаляет все элементы словаря, del dict_sample -> удаление всего словаря
5***переменная тип***тип (взять): type(x)___идентификатор (проверить на связь с другими): id(x), a is b -> сравнить идентификаторы, a is None лучше, чем a == None___логическая проверка: isinstanse(x, int) -> True, False___две переменные ссылаются на один объект: list is new_list -> возвращает булево значение___число без знака: abs(-1)___список всех атрибутов объектов: dir()___посмотреть свойства и подсказки: help()___значение хэша для обьекта: hash(profit) -> лучше сравнивать по хешу неизменяемые объекты (быстрее)___логические: all() -> True если ВСЕ элементы списка/множества True, any() -> True если ХОТЯ БЫ ОДИН элемент списка True
6***ввод в консоли***два числа: x, y = map(int, input().split())___x, y, z = some_list
7***методы строк***длина строки: len()___поиск в строке (номер элемента): .find('a') и .rfind('a') -> с конца___замена в строке: .replase('a', 'b') -> создается новая строка___улучшалки строк: .lower() -> нижний регистр, .upper() -> верхний регистр, .strip() -> убрать пробелы___проверка строк: .isalpha() -> все буквы, isdigit() или isnumeric() -> все цифры
8***методы списка***добавить в конец: .append() и .extend([5, 5])___добавить в определенное место: .insert(3, 'a')___удалить элемент: del my_list[5] -> с конкретного места, my_list.remove('s')-> первый по порядку элемент 's'___генератор списка: list(range(10))___создать список: a = [2, 3, 4], a = list([1, 2, 3])___найти мин, макс, сумму: min(my_list), max(my_list), sum(my_list) -> для списка чисел___сортировать список: my_list.sort(), sorted(my_list) -> если не надо изменить сам список___количество в списке: my_list.count('d')___заменить в списке: my_list[1] = 200___индекс элемента: .index('i', 5, 7) -> необязательные - (5-начало, 7-конец), возвращает только первое вхождение, если нет элемента - то возвращает ошибку___попарная компоновка элементов двух списков: zip() - profit = [100, 20] days = ['пн', 'вт'] res = zip(profit, days) print(list(res)) или res = list(zip(profit, days)) или print(dict(zip(days, profit)))
9***кортеж***неизменяемый список (const): my_tuple = (1, 2, 3), x = tuple()___добавить, изменить нельзя - можно сложить с таким-же: my_tuple + (5, 6)
10***множества***(как список, но хранит только уникальные объекты) создание: my_set = set([1, 2, 3]), my_set = {1, 2, 3}___действия: my_set | i_set -> объединение, my_set & i_set -> пересечение, my_set - i.set -> вычитание___методы множеств: .add -> добавление, .pop() discard() -> удаление, .update() -> обновление
11***операторы ветвления***сокращенная запись: if a: -> True !=0, False =0, if my_list: -> True - (список не пустой), False - (список пустой)___оператор pass: ничего не делать в этой строке, пропустить___проверка на отсутствие значения: val = none if val: print(str(val))
12***стиль языка***используется: i j k - для циклов, x y z - для координат, l I O - не называть так переменные___переменные, набранные в верхнем регистре - обычно константы - CONST (определяются глобально в начале)___если переменная цикла не важна используем подчеркивание: for _ in range(10):___в функции переменные обозначают: -_a, _d___переменные определяются не в начале, а перед использованием (лучше передать в функцию параметры и их использовать как локальные переменные)___делать много вычислений внутри print() - плохой стиль___произвольное число позиционных параметров - (*args), произвольное число именованных параметров - (**kwargs) kw - key word
13***полезные функции в цикле***вывод пар - номер в списке, значение: for i, animal in enumerate(zoo_pets): print(i, animal)
14***функции***параметры: позиционные, именованные или должны быть явно указаны - (x, y, *, z) ->  все после звездочки именованные___распаковка параметров: позиционных - res = module(*some_list) some_list = [1, 2, 3], именованных - ** (обычно словари), можно комбинировать все___самый лучший и устойчивый вызов - именованными параметрами___функция должна принимать от 3 до 7 параметров (больше - разбиваем), оптиум 2-5___по умолчанию: указываются при задании функции, применяются, если не изменили при вызове___значения по умолчанию вычисляются в точке определения функции, при компиляции___нельзя задавать изменяемый обьект в качестве параметра по умолчанию (список, словарь): def add_element_to_list(element, list_to_add=[]):___решение проблемы выше: def add_element_to_list(element, list_to_add=None): внутри кода -if list_to_add is None:list_to_add = []___произвольное число позиционных параметров: def print_them_all(*args): print(args) или for i, arg in enumerate(args): print('позиционный параметр:', i, arg)___произвольное число позиционных параметров можно использовать для заполнения базы данных___произвольное число именованных параметров: def print_them_all(**kwargs): print(kwargs) или for key, value in kwargs.items(): print('именованный аргумент:', key, '=', value)___комбинация произвольного числа позиционных и именованных параметров: def print_them_all_v3(*args, **kwargs): -> вызовы как на двух строках выше___при создании функции можно указывать как обычные параметры, так и произвольные параметры: def print_them_all_v4(a, b=5, *args, **kwargs) -> a и b не более пяти
15***быстрый вызов в pycharm***Ctrl +навести на функцию + кнопка мыши: вызвать определение функции
