# -*- coding: utf-8 -*-
"""Копия блокнота "ChatBot - Day 3.ipynb"

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1X7z5_eJbAyVffDdKw0DNeRzHfI_RzXfw
"""

import random
import nltk
import json
from sklearn.feature_extraction.text import CountVectorizer, TfidfVectorizer
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split

"""## День 1"""

BOT_CONFIG = {
    'intents': {
        'hello': {
            'examples': ['привет!', 'хай', 'Здравствуйте!!'],
            'responses': ['Добрый день', 'Здравия желаю!', 'Добрый вечер']
        },
        'bye': {
            'examples': ['пОкА!', 'до свидания', 'Увидимся!'],
            'responses': ['До связи', 'Саонара!!', 'Покеда']
        },
        'howdoyoudo': {
            'examples': ['как дела?', 'как жизнь?'],
            'responses': ['не жалуюсь!!']
        }
    },
    'not_found': {
        'responses': ['Извините, не удалось определить интент', 'Я пока еще глупый бот, ничего не понимаю!!']
    }
}
with open('D:\\BOT_CONFIG.json', encoding='utf-8') as f:
    BOT_CONFIG = json.load(f)

def clean(text):
    cleaned_text = ''
    for ch in text.lower():
        if ch in 'абвгдеёжзийклмнопрстуфхцчшщъыьэюя ':
            cleaned_text = cleaned_text + ch
    return cleaned_text


def get_intent(text):
    for intent in BOT_CONFIG['intents'].keys():
        for example in BOT_CONFIG['intents'][intent]['examples']:
            cleaned_example = clean(example)
            cleaned_text = clean(text)
            if nltk.edit_distance(cleaned_example, cleaned_text) / max(len(cleaned_example), len(cleaned_text)) < 0.4:
                return intent
    return 'not_found'


def bot(text):
    intent = get_intent(text)
    if intent != 'not_found':
        return random.choice(BOT_CONFIG['intents'][intent]['responses'])
    else:
        return random.choice(BOT_CONFIG['not_found']['responses'])


"""## День 2"""

# text1 = 'мама мыла раму'
# text2 = 'корова шла и мама ее остановила'
# text3 = 'ее раму украли и сломали раму'

# vocab = ['мама', 'мыла', 'раму', 'корова', 'шла', 'и', 'ее', 'остановила', 'украли', 'сломали']
# vector_of_text1 = [1, 1, 1, 0, 0, 0, 0, 0, 0, 0]
# vector_of_text2 = [1, 0, 0, 1, 1, 1, 1, 1, 0, 0]
# vector_of_text3 = [0, 0, 2, 0, 0, 1, 1, 0, 1, 1]

X = []
y = []

for intent in BOT_CONFIG['intents'].keys():
    try:
        for example in BOT_CONFIG['intents'][intent]['examples']:
            X.append(example)
            y.append(intent)
    except:
        pass

print(len(X), len(y), len(set(y)))
# X = []
# y = []
# for intent in BOT_CONFIG['intents']:
#     for example in BOT_CONFIG['intents'][intent]['examples']:
#         X.append(example)
#         y.append(intent)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
print(len(X_train), len(X_test))

vectorizer = CountVectorizer(ngram_range=(1, 3), analyzer='char_wb')
# vectorizer = TfidfVectorizer(ngram_range=(1, 3), analyzer='char_wb')

X_train_vectorized = vectorizer.fit_transform(X_train)
X_test_vectorized = vectorizer.transform(X_test)
# len(vectorizer.get_feature_names())
print(len(vectorizer.get_feature_names_out()))

clf = RandomForestClassifier()
# clf = LogisticRegression(C=5, max_iter=300)
clf.fit(X_train_vectorized, y_train)

clf.score(X_train_vectorized, y_train)
print(clf.score(X_train_vectorized, y_train))
clf.score(X_test_vectorized, y_test)
print(clf.score(X_test_vectorized, y_test))
clf.predict(vectorizer.transform(['где ты живешь?']))

"""## Тестирование"""


def get_intent_by_model(text):
    return clf.predict(vectorizer.transform([text]))[0]


def bot(text):
    intent = get_intent_by_model(text)
    return random.choice(BOT_CONFIG['intents'][intent]['responses'])


input_text = ''
while input_text != 'exit':
    input_text = input()
    response = bot(input_text)
    print(response)

"""## Подключение бота к телеграмм"""

# !pip install python-telegram-bot --upgrade

# !/usr/bin/env python
# pylint: disable=C0116,W0613
# This program is dedicated to the public domain under the CC0 license.

"""
Simple Bot to reply to Telegram messages.
First, a few handler functions are defined. Then, those functions are passed to
the Dispatcher and registered at their respective places.
Then, the bot is started and runs until we press Ctrl-C on the command line.
Usage:
Basic Echobot example, repeats messages.
Press Ctrl-C on the command line or send a signal to the process to stop the
bot.
"""

# import logging
#
# from telegram import Update, ForceReply
# from telegram.ext import Updater, CommandHandler, MessageHandler, Filters, CallbackContext
#
# # Enable logging
# logging.basicConfig(
#     format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO
# )
#
# logger = logging.getLogger(__name__)
#
#
# # Define a few command handlers. These usually take the two arguments update and
# # context.
# def start(update: Update, context: CallbackContext) -> None:
#     """Send a message when the command /start is issued."""
#     user = update.effective_user
#     update.message.reply_markdown_v2(
#         fr'Hi {user.mention_markdown_v2()}\!',
#         reply_markup=ForceReply(selective=True),
#     )
#
#
# def help_command(update: Update, context: CallbackContext) -> None:
#     """Send a message when the command /help is issued."""
#     update.message.reply_text('Help!')
#
#
# def echo(update: Update, context: CallbackContext) -> None:
#     """Echo the user message."""
#     out_text = bot(update.message.text)
#     update.message.reply_text(out_text)
#
#
# def main() -> None:
#     """Start the bot."""
#     # Create the Updater and pass it your bot's token.
#     updater = Updater("2080298848:AAHWpPecrhRQFd_MCwhZ8e6j13rzgw8ykxk")
#
#     # Get the dispatcher to register handlers
#     dispatcher = updater.dispatcher
#
#     # on different commands - answer in Telegram
#     dispatcher.add_handler(CommandHandler("start", start))
#     dispatcher.add_handler(CommandHandler("help", help_command))
#
#     # on non command i.e message - echo the message on Telegram
#     dispatcher.add_handler(MessageHandler(Filters.text & ~Filters.command, echo))
#
#     # Start the Bot
#     updater.start_polling()
#
#     # Run the bot until you press Ctrl-C or the process receives SIGINT,
#     # SIGTERM or SIGABRT. This should be used most of the time, since
#     # start_polling() is non-blocking and will stop the bot gracefully.
#     updater.idle()
#
#
# main()
objects = [1, 2, 1, 5, True, False, True, 'false', [], [1,2], [1,2]]
ans = 0
asdd = [objects[0]]
for obj in objects:  # доступная переменная objects
    for i in range(len(asdd)):
        if obj is asdd[i]:
            asdd.insert(i, obj)
        else:
            asdd.append(obj)
    print(asdd)
    asd = list(asdd)
    if asdd:
        ans += 1

print(ans, asdd)