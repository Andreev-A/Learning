"""Дан список чисел, который может содержать до 100000 чисел.Определите, сколько в нем встречается различных чисел.
Формат ввода - Вводится список целых чисел. Все числа списка находятся на одной строке.
Формат вывода - Выведите ответ на задачу."""
# # неразвернутое - print(len(set(map(int, input().split()))))
# print(
#     len(
#         set(
#             map(
#                 int,
#                 input().split()
#             )
#         )
#     )
# )

"""Во входном файле (вы можете читать данные из sys.stdin, подключив библиотеку sys) записан текст. Словом считается
последовательность непробельных символов идущих подряд, слова разделены одним или большим числом пробелов или символами
конца строки. Определите, сколько различных слов содержится в этом тексте.
Формат ввода - Вводится текст.
Формат вывода - Выведите ответ на задачу."""
# import sys
# print(
#     len(
#         set(
#             map(
#                 str,
#                 sys.stdin.read().split()
#             )
#         )
#     )
# )

"""Выведите значение наименьшего нечетного элемента списка, гарантируется, что хотя бы один нечётный элемент есть.
Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
Формат вывода - Выведите ответ на задачу."""
# print(
#     min(
#         filter(
#             lambda x: x % 2 == 1,
#             map(
#                 int,
#                 input().split()
#             )
#         )
#     )
# )

"""Проверьте, есть ли среди данных N чисел нули.
Формат ввода - Вводится число N, а затем N чисел.
Формат вывода - Выведите True, если среди введенных чисел есть хотя бы один нуль, или False в противном случае."""
# # неразвернутое - print(any(map(lambda x: x == 0, map(lambda x: int(input()), range(int(input()))))))
# print(
#     any(
#         map(
#             lambda x: x == 0,
#             map(
#                 lambda x: int(input()),
#                 range(int(input()))
#             )
#         )
#     )
# )

# print(any(map(lambda x: int(x) == 0, (open('input.txt', 'r', encoding='utf8').read()).split())))
# print('0' in set(open('input.txt').read().split()))
# print(any(map(lambda x: x == '0', map(lambda x: input(), range(int(input()))))))

"""На вход подаётся последовательность натуральных чисел длины n≤1000.Посчитайте произведение пятых степеней чисел в
последовательности.
Формат ввода - Вводится последовательность чисел
Формат вывода - Выведите ответ на задачу
Примечания - Для решения задачи используйте функцию reduce из модуля functools"""
# # неразвернутое - print(reduce(lambda x, y: x * y, map(lambda x: x ** 5, map(int, input().split()))))
# from functools import reduce
# print(
#     reduce(
#         lambda x, y: x * y,
#         map(
#             lambda x: x ** 5,
#             map(
#                 int,
#                 input().split()
#             )
#         )
#     )
# )

"""Булева функция XOR (сложение по модулю два) задаётся следующей таблицей истинности:
xor(0,0)=0
xor(0,1)=1
xor(1,0)=1
xor(1,1)=0
На вход подаются две последовательности (a₁,…,an) и (b₁,…,bn) из 0 и 1.
Вычислите последовательность из (c₁,…,cn), где каждая cᵢ=xor(aᵢ,bᵢ).
Формат ввода - На вход подаются две строки из 0 и 1, разделённых пробелами.
Первая строка  —  это последовательность (a₁,…,an).
Вторая строка  —  это последовательность (b₁,…,bn).
Формат вывода - Выведите последовательность (c₁,…,cn), разделяя каждый элемент пробелом
Примечания
Для решения задачи можете использовать функцию zip."""
# # неразвернутое - print(*map(lambda xy: xy[0] ^ xy[1], zip(map(int, input().split()), map(int, (input().split())))))
# print(
#     *map(
#         lambda xy: xy[0] ^ xy[1],
#         zip(
#             map(
#                 int,
#                 input().split()
#             ),
#             map(
#                 int,
#                 input().split()
#             )
#         )
#     )
# )

"""По заданной последовательности: (a₁,…,an)
посчитайте последовательность частичных сумм: (S₁,…,Sn), где Sk=a₁+a₂+…+ak.
Формат ввода - Вводится последовательность чисел (a₁,…,an), разделённая пробелами.
Формат вывода - Выведите последовательность (S₁,…,Sn), разделяя числа пробелами.
Примечания
Для решения задачи можно воспользоваться функцией accumulate из модуля itertools."""
# # неразвернутое - print(*accumulate(map(int, input().split())))
# from itertools import accumulate
# print(
#     *accumulate(
#         map(
#             int,
#             input().split()
#         )
#     )
# )

"""По заданному на входе числу 0≤n≤2000 выведите последовательность факториалов: 0!,1!,2!,…,n!
Формат ввода - Вводится число n.
Формат вывода - Выведите последовательность факториалов, разделяя числа пробелами"""
# from itertools import accumulate
# print(
#     *accumulate(
#         map(
#             lambda x: max(x, 1),
#             range(int(input()) + 1)
#         ),
#         lambda x, y: x * y
#     )
# )

# a = [0, 1, 2, 3, 4, 5, 6]
# a = map(lambda x: max(x,1), a)
# print(*accumulate(a, lambda x, y: x * y))
# print(*a)

"""По данному числу N выведите все перестановки чисел от 1 до N в лексикографическом порядке.
Формат ввода - Задано 1 число: N (0<N<10).
Формат вывода - Необходимо вывести все перестановки чисел от 1 до N в лексикографическом порядке. Перестановки
выводятся по одной в строке, числа в перестановке выводятся без пробелов."""
# # неразвернутое - print(*map(lambda xyz: ''.join(map(str, xyz)), permutations(range(1, int(input()) + 1))), sep='\n')
# from itertools import permutations
# print(
#     *map(
#         lambda xyz: ''.join(map(str, xyz)),
#         permutations(
#             range(
#                 1,
#                 int(input()) + 1)
#         )
#     ),
#     sep='\n'
# )

"""XOR для произвольного числа аргументов определяется следующим образом:
xor(a₁,a₂,…,an)= xor(a₁, xor(a₂, xor(a₃,… xor(an))…)
XOR от n последовательностей A₁,…,An (Aᵢ=Aᵢ₁,…,Aᵢk) равных длин k  —  это последовательность C=xor(A₁,…,An),такая, что:
cᵢ=xor(A₁ᵢ,…Anᵢ)
Посчитайте XOR от n последовательностей равной длины k.
Формат ввода - На первой строке записано число 2≤n≤1000  —  количество последовательностей.
На последующих n строках записаны последовательности A₁,…,An из 0 и 1, разделённых пробелами равной длины 1≤k≤1000.
Формат вывода - Выведите последовательность C=xor(A₁,…,An), разделяя числа последовательности пробелами."""
# from functools import reduce
# print(
#     *map(
#         lambda x: (
#             reduce(
#                 lambda a, b: (a ^ b),
#                 x
#             )
#         ),
#         zip(
#             *map(
#                 lambda x: map(
#                     int,
#                     input().split()
#                 ),
#                 range(int(input()))
#             )
#         )
#     )
# )

# print(
#     *map(
#         lambda x: (reduce(lambda a, b: (a ^ b), x)),
#         zip(*map(lambda x: map(int, input().split()), range(int(input()))))
#     )
# )
# У нас списки с содержимым строк, а для xor от последовательности нужно бы получить списки столбцов. Похоже, самый
# простой способ это сделать - zip. При чём на вход ему нужно отправить не список строк, а список списков чисел в
# строках: lambda x: map(int, x.split()). Не забываем распаковать map звёздочкой, всё это в zip, красота.
# Ну а теперь список столбцов превращаем в финальный список: lambda x: reduce(lambda a, b: a ^ b, x). Перед принтом
# снова распаковываем map звёздочкой.
# Помогло разобраться, как работает map. В качестве lambda функции можно передавать другой map, в качестве параметров
# несколько списков.
# from sys import stdin
# from functools import reduce
# from operator import xor
#
# print(
#     *reduce(
#         lambda a, b: map(xor, a, b),
#         list(
#             map(
#                 lambda _: map(
#                     int, stdin.readline().strip().split()
#                 ), range(
#                     int(
#                         stdin.readline()
#                     )
#                 )
#             )
#         )
#     )
# )

"""Выведите все простые на отрезке [2;n].
Формат ввода - Вводится число 2≤n≤100000.
Формат вывода - Выведите все простые числа из отрезка [2,n] в порядке возрастания
Примечания
Напомним, что проверить число на то, простое ли оно можно за количество операций порядка √(N). Также напомним, что
функция math.sqrt работает значительно быстрее, чем (x ** 1/2)."""
# from math import sqrt
# print(
#     2,
#     *filter(
#         lambda i: all(
#             map(
#                 lambda x: i % x,
#                 range(2, int(sqrt(i)) + 1)
#             )
#         ),
#         range(3, int(input()) + 1, 2)
#     )
# )
